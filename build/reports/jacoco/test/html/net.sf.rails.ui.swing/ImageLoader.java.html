<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ImageLoader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.ui.swing</a> &gt; <span class="el_source">ImageLoader.java</span></div><h1>ImageLoader.java</h1><pre class="source lang-java linenums">package net.sf.rails.ui.swing;

import java.awt.image.BufferedImage;
import java.util.*;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import net.sf.rails.common.Config;
import net.sf.rails.common.ResourceLoader;
import net.sf.rails.util.*;

import org.apache.batik.transcoder.*;
import org.apache.batik.transcoder.image.ImageTranscoder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;

import com.google.common.collect.HashBasedTable;
import com.google.common.collect.Maps;


/**
 * This class handles loading our tile images. It provides BufferedImages to be
 * associated with the Hex.
 */
public class ImageLoader {
<span class="nc" id="L30">    private static final Logger log = LoggerFactory.getLogger(ImageLoader.class);</span>

    private final DocumentBuilder svgDocBuilder;

<span class="nc" id="L34">    private final Map&lt;String, Document&gt; svgMap = Maps.newHashMap();</span>
<span class="nc" id="L35">    private final HashBasedTable&lt;String, Integer, BufferedImage&gt; tileImages =</span>
<span class="nc" id="L36">            HashBasedTable.create();</span>

<span class="nc" id="L38">    private double[] zoomFactors = new double[21];</span>

    //defines adjustment of zoom factor (should be close to 1)
    //(used for perfect-fit sizing that requires arbitrary zoom)
<span class="nc" id="L42">    private double zoomAdjustmentFactor = 1;</span>

<span class="nc" id="L44">    private double svgWidth = 75;</span>
<span class="nc" id="L45">    private double svgHeight = svgWidth * 0.5 * Math.sqrt(3.0);</span>

<span class="nc" id="L47">    private String svgTileDir = &quot;tiles/svg&quot;;</span>
<span class="nc" id="L48">    private String tileRootDir = Config.get(&quot;tile.root_directory&quot;);</span>
    private String directory;


<span class="nc" id="L52">    public ImageLoader() {</span>
<span class="nc bnc" id="L53" title="All 4 branches missed.">        if (Util.hasValue(tileRootDir) &amp;&amp; !tileRootDir.endsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L54">            tileRootDir += &quot;/&quot;;</span>
        }
<span class="nc" id="L56">        directory = (tileRootDir + svgTileDir);</span>

        // Step 1: create a DocumentBuilderFactory and setNamespaceAware
<span class="nc" id="L59">        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L60">        dbf.setNamespaceAware(true);</span>
        // Step 2: create a DocumentBuilder
<span class="nc" id="L62">        DocumentBuilder db = null;</span>
        try{
<span class="nc" id="L64">            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span>
<span class="nc" id="L65">            db = dbf.newDocumentBuilder(); }</span>
<span class="nc" id="L66">        catch (ParserConfigurationException e) {</span>
            // do nothing
<span class="nc" id="L68">        }</span>
<span class="nc" id="L69">        svgDocBuilder = db;</span>
<span class="nc" id="L70">    }</span>

    private BufferedImage getSVGTile(String tileID, double zoomFactor) {
<span class="nc" id="L73">        String fn = &quot;tile&quot; + tileID + &quot;.svg&quot;;</span>

        BufferedImage image;

        try {
<span class="nc bnc" id="L78" title="All 2 branches missed.">            if (!svgMap.containsKey(tileID)) {</span>
<span class="nc" id="L79">                 Document doc = null;</span>

                // Step 3: parse the input file to get a Document object
<span class="nc" id="L82">                doc = svgDocBuilder.parse(ResourceLoader.getInputStream(fn, directory));</span>
                // Cache the doc
<span class="nc" id="L84">                svgMap.put(tileID, doc);</span>
<span class="nc" id="L85">                log.trace(&quot;SVG document for tile id {} succeeded &quot;, tileID);</span>
            }
<span class="nc" id="L87">            BufferedImageTranscoder t = new BufferedImageTranscoder();</span>
<span class="nc" id="L88">            t.addTranscodingHint(ImageTranscoder.KEY_MAX_WIDTH, (float) (svgWidth * zoomFactor));</span>
<span class="nc" id="L89">            t.addTranscodingHint(ImageTranscoder.KEY_MAX_HEIGHT, (float) (svgHeight * zoomFactor));</span>
<span class="nc" id="L90">            TranscoderInput input = new TranscoderInput(svgMap.get(tileID));</span>
<span class="nc" id="L91">            t.transcode(input, null);</span>
<span class="nc" id="L92">            image = t.getImage();</span>
<span class="nc" id="L93">            log.trace(&quot;SVG transcoding for tile id {} and zoomFactor {} succeeded&quot;, tileID, zoomFactor);</span>

<span class="nc" id="L95">        } catch (Exception e) {</span>
<span class="nc" id="L96">            log.error(&quot;SVG transcoding for tile id {} failed&quot;, tileID, e);</span>
<span class="nc" id="L97">            return null;</span>
<span class="nc" id="L98">        }</span>

<span class="nc" id="L100">        return image;</span>
    }

    public BufferedImage getTile(String tileID, int zoomStep) {
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (tileImages.contains(tileID, zoomStep)) {</span>
<span class="nc" id="L105">            return tileImages.get(tileID, zoomStep);</span>
        } else {
<span class="nc" id="L107">            BufferedImage image = getSVGTile(tileID, getZoomFactor(zoomStep));</span>
<span class="nc" id="L108">            tileImages.put(tileID, zoomStep, image);</span>
<span class="nc" id="L109">            return image;</span>
        }
    }

    public double getZoomFactor (int zoomStep) {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (zoomStep &lt; 0) zoomStep = 0;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">        else if (zoomStep &gt; 20) zoomStep = 20;</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (zoomFactors[zoomStep] == 0.0) {</span>
<span class="nc" id="L117">            zoomFactors[zoomStep] = zoomAdjustmentFactor * Math.pow(2.0, 0.25*(zoomStep-10));</span>
        }
<span class="nc" id="L119">        return zoomFactors[zoomStep]* GUIGlobals.getMapScale();</span>

    }

    /**
     * @param zoomAdjustmentFactor Additional factor applied to zoom factor. Used
     * for precisely adjusting zoom-step based zoom factors for perfect fit requirements.
     */
    public void setZoomAdjustmentFactor (double zoomAdjustmentFactor) {
<span class="nc" id="L128">        this.zoomAdjustmentFactor = zoomAdjustmentFactor;</span>

        //invalidate buffered zoom step zoom factors
<span class="nc" id="L131">        Arrays.fill(zoomFactors, 0);</span>

        //invalidate buffered tile scalings
<span class="nc" id="L134">        tileImages.clear();</span>
<span class="nc" id="L135">    }</span>

    public void resetAdjustmentFactor() {
<span class="nc" id="L138">        setZoomAdjustmentFactor(1);</span>
<span class="nc" id="L139">    }</span>

    /* cheat, using batik transcoder API. we only want the Image */
    private static class BufferedImageTranscoder extends ImageTranscoder {

        private BufferedImage image;

        @Override
        public BufferedImage createImage(int width, int height) {
<span class="nc" id="L148">            return new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);</span>
        }

        @Override
        public void writeImage(BufferedImage image, TranscoderOutput output)
                throws TranscoderException {
<span class="nc" id="L154">            this.image = image;</span>
<span class="nc" id="L155">        }</span>

        public BufferedImage getImage() {
<span class="nc" id="L158">            return image;</span>
        }
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>