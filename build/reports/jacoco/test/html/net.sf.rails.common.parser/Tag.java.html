<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tag.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.common.parser</a> &gt; <span class="el_source">Tag.java</span></div><h1>Tag.java</h1><pre class="source lang-java linenums">package net.sf.rails.common.parser;

import com.google.common.base.MoreObjects;
import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableList;
import net.sf.rails.common.GameOption;
import net.sf.rails.common.GameOptionsSet;
import net.sf.rails.common.ResourceLoader;
import net.sf.rails.util.Util;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.*;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.util.*;


/**
 * Each object of this class both contains and represents a DOM Element object.
 * Its purpose it to hide the XML parsing details from the application program.
 * The methods of this class intend to replace the corresponding methods in
 * XmlUtils.
 *
 * @author Erik Vos
 */
public class Tag {
<span class="fc" id="L32">    private static final Logger log = LoggerFactory.getLogger(Tag.class);</span>

    // static data
    private final Element element;
    private final GameOptionsSet gameOptions;

    // dynamic data
<span class="fc" id="L39">    private Map&lt;String, String&gt; attributes = null;</span>
<span class="fc" id="L40">    private Map&lt;String, List&lt;Tag&gt;&gt; children = null;</span>
<span class="fc" id="L41">    private String text = null;</span>
<span class="fc" id="L42">    private boolean parsed = false;</span>
<span class="fc" id="L43">    private boolean parsing = false;</span>


<span class="fc" id="L46">    public Tag(Element element, GameOptionsSet gameOptions) {</span>
<span class="fc" id="L47">        this.element = element;</span>
<span class="fc" id="L48">        this.gameOptions = gameOptions;</span>
<span class="fc" id="L49">    }</span>

    public Map&lt;String, List&lt;Tag&gt;&gt; getChildren() throws ConfigurationException {

<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if (!parsed) parse(element);</span>

<span class="fc" id="L55">        return children;</span>
    }

    /**
     * Return all child Elements with a given name of an Element.
     *
     * @param element
     * @param tagName
     * @return
     * @throws ConfigurationException
     */
    public List&lt;Tag&gt; getChildren(String tagName) throws ConfigurationException {

<span class="fc bfc" id="L68" title="All 2 branches covered.">        if (!parsed) parse(element);</span>

<span class="fc" id="L70">        return children.get(tagName);</span>
    }

    /**
     * Return the (first) child Element with a given name from an Element.
     *
     * @param element
     * @param tagName
     * @return
     * @throws ConfigurationException
     */
    public Tag getChild(String tagName) throws ConfigurationException {

<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (!parsed) parse(element);</span>

<span class="fc" id="L85">        List&lt;Tag&gt; list = children.get(tagName);</span>
<span class="pc bpc" id="L86" title="1 of 4 branches missed.">        if (list != null &amp;&amp; list.size() &gt; 0) {</span>
<span class="fc" id="L87">            return list.get(0);</span>
        } else {
<span class="fc" id="L89">            return null;</span>
        }
    }

    public boolean hasChild(String tagName) throws ConfigurationException {

        //br: this was hardcoded  to &quot;AllowsMultipleBasesOfOneCompany&quot; -- looks like a bug.
<span class="fc bfc" id="L96" title="All 2 branches covered.">        return getChildren(tagName) != null;</span>
    }

    public String getText() throws ConfigurationException {

<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (!parsed) parse(element);</span>

<span class="fc" id="L103">        return text;</span>
    }

    public Map&lt;String, String&gt; getAttributes() throws ConfigurationException {

<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (!parsed) parse(element);</span>

<span class="nc" id="L110">        return attributes;</span>

    }

    public String getAttributeAsString(String name, String defaultValue)
            throws ConfigurationException {

<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (!parsed) parse(element);</span>

<span class="fc" id="L119">        String value = attributes.get(name);</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (value == null) return defaultValue;</span>
<span class="fc" id="L121">        return value;</span>
    }

    public String getAttributeAsString(String name)
            throws ConfigurationException {

<span class="fc" id="L127">        return getAttributeAsString(name, null);</span>
    }

    public int getAttributeAsInteger(String name, int defaultValue)
            throws ConfigurationException {

<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (!parsed) parse(element);</span>

<span class="fc" id="L135">        String value = attributes.get(name);</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (value == null) return defaultValue;</span>
        try {
            // Unlike Java, we want to allow '+' signs
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">            if (value.startsWith(&quot;+&quot;)) value = value.substring(1);</span>
<span class="fc" id="L140">            return Integer.parseInt(value);</span>
<span class="nc" id="L141">        } catch (Exception e) {</span>
<span class="nc" id="L142">            throw new ConfigurationException(&quot;Invalid integer value: &quot; + value,</span>
                    e);
        }
    }

    public float getAttributeAsFloat(String name) throws ConfigurationException {

<span class="nc" id="L149">        return getAttributeAsFloat(name, 0.0f);</span>
    }

    public float getAttributeAsFloat(String name, float defaultValue)
            throws ConfigurationException {

<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (!parsed) parse(element);</span>

<span class="fc" id="L157">        String value = attributes.get(name);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (value == null) return defaultValue;</span>
        try {
<span class="fc" id="L160">            return Float.parseFloat(value);</span>
<span class="nc" id="L161">        } catch (Exception e) {</span>
<span class="nc" id="L162">            throw new ConfigurationException(&quot;Invalid floating point value: &quot; + value,</span>
                    e);
        }
    }

    public int getAttributeAsInteger(String name) throws ConfigurationException {

<span class="fc" id="L169">        return getAttributeAsInteger(name, 0);</span>
    }

    public List&lt;Integer&gt; getAttributeAsIntegerList(String name)
            throws ConfigurationException {

<span class="fc" id="L175">        String valueString = getAttributeAsString(name);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (!Util.hasValue(valueString)) return ImmutableList.of();</span>

<span class="fc" id="L178">        ImmutableList.Builder&lt;Integer&gt; result = ImmutableList.builder();</span>
        try {
<span class="fc bfc" id="L180" title="All 2 branches covered.">            for (String value : valueString.split(&quot;,&quot;)) {</span>
<span class="fc" id="L181">                result.add(Integer.parseInt(value));</span>
            }
<span class="nc" id="L183">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L184">            throw new ConfigurationException(&quot;Invalid integer in attribute &quot; + name + &quot;'&quot;);</span>
<span class="fc" id="L185">        }</span>
<span class="fc" id="L186">        return result.build();</span>

    }

    public boolean getAttributeAsBoolean(String name, boolean defaultValue)
            throws ConfigurationException {

<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (!parsed) parse(element);</span>

<span class="fc" id="L195">        String value = attributes.get(name);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (value == null) return defaultValue;</span>

<span class="fc" id="L198">        return value.matches(&quot;^[TtYy].*&quot;);</span>
    }

    public boolean getAttributeAsBoolean(String name)
            throws ConfigurationException {

<span class="fc" id="L204">        return getAttributeAsBoolean(name, false);</span>
    }

    // br: needed to test if a Tradeable tag has a toCompany or toPlayer attribute
    public boolean hasAttribute(String name)
            throws ConfigurationException {

<span class="fc bfc" id="L211" title="All 2 branches covered.">        return getAttributeAsString(name) != null;</span>
    }

    /**
     * Extract all attributes of an Element into a HashMap. This includes
     * conditional values, embedded in (possibly nested) &amp;lt;IfOption&amp;gt;
     * subnodes. &lt;p&gt; The generic XML construct being parsed here must look like:&lt;p&gt;
     * &lt;code&gt;
     * &amp;lt;AnyElement attr1=&quot;value1&quot; attr2=&quot;value2&quot; ...&amp;gt;
     * &amp;lt;IfOption name=&quot;optname1&quot; value=&quot;optvalue1&quot;&amp;gt;
     * &amp;lt;IfOption name=&quot;optname2&quot; value=&quot;optvalue2&quot;&amp;gt;
     * &amp;lt;Attributes attr3=&quot;value3&quot; attr4=&quot;value4&quot;/&amp;gt;
     * &amp;lt;/IfOption&amp;gt;
     * &amp;lt;/IfOption&amp;gt;
     * &amp;lt;/AnyElement&amp;gt;
     * &lt;/code&gt;
     * &lt;p&gt; For variant names, the fixed option name &quot;variant&quot; is used.
     *
     * @param element
     * @return
     */
    private synchronized void parse(Element element)
            throws ConfigurationException {

<span class="pc bpc" id="L235" title="2 of 4 branches missed.">        if (parsed || parsing) return;</span>
<span class="fc" id="L236">        parsing = true;</span>

<span class="fc" id="L238">        attributes = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L239">        children = new HashMap&lt;String, List&lt;Tag&gt;&gt;();</span>

<span class="fc" id="L241">        NamedNodeMap nnp = element.getAttributes();</span>
        Node attribute;
        String name, value;
<span class="fc bfc" id="L244" title="All 2 branches covered.">        for (int i = 0; i &lt; nnp.getLength(); i++) {</span>
<span class="fc" id="L245">            attribute = nnp.item(i);</span>
<span class="fc" id="L246">            name = attribute.getNodeName();</span>
<span class="fc" id="L247">            value = attribute.getNodeValue();</span>
<span class="fc" id="L248">            attributes.put(name, value);</span>
        }

<span class="fc" id="L251">        parseSubTags(element);</span>

<span class="fc" id="L253">    }</span>

    private void parseSubTags(Element element) throws ConfigurationException {

<span class="fc" id="L257">        NodeList childNodes = element.getChildNodes();</span>
        Node childNode;
        Element childElement;
        String childTagName;
        Node attribute;
        String name, value;
        List&lt;String&gt; valueList;
<span class="fc" id="L264">        StringBuilder textBuffer = new StringBuilder();</span>

<span class="fc bfc" id="L266" title="All 2 branches covered.">        for (int i = 0; i &lt; childNodes.getLength(); i++) {</span>
<span class="fc" id="L267">            childNode = childNodes.item(i);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">            if (childNode.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="fc" id="L269">                childElement = (Element) childNode;</span>
<span class="fc" id="L270">                childTagName = childElement.getNodeName();</span>
<span class="fc" id="L271">                NamedNodeMap nnp = childElement.getAttributes();</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                if (childTagName.equalsIgnoreCase(&quot;Attributes&quot;)) {</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">                    for (int j = 0; j &lt; nnp.getLength(); j++) {</span>
<span class="fc" id="L274">                        attribute = nnp.item(j);</span>
<span class="fc" id="L275">                        name = attribute.getNodeName();</span>
<span class="fc" id="L276">                        value = attribute.getNodeValue();</span>
<span class="fc" id="L277">                        attributes.put(name, value);</span>
                    }
<span class="fc bfc" id="L279" title="All 2 branches covered.">                } else if (childTagName.equalsIgnoreCase(&quot;IfOption&quot;)) {</span>
<span class="fc" id="L280">                    Node nameAttr = nnp.getNamedItem(&quot;name&quot;);</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">                    if (nameAttr == null)</span>
<span class="nc" id="L282">                        throw new ConfigurationException(</span>
                                &quot;IfOption has no optionName attribute&quot;);
<span class="fc" id="L284">                    name = nameAttr.getNodeValue();</span>

<span class="fc" id="L286">                    Node parmAttr = nnp.getNamedItem(&quot;parm&quot;);</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">                    if (parmAttr != null) {</span>
<span class="nc" id="L288">                        value = parmAttr.getNodeValue();</span>
<span class="nc" id="L289">                        Iterable&lt;String&gt; parameters = Splitter.on(XMLTags.VALUES_DELIM).split(value);</span>
<span class="nc" id="L290">                        name = GameOption.constructParameterisedName(name, ImmutableList.copyOf(parameters));</span>
                    }

<span class="fc" id="L293">                    Node valueAttr = nnp.getNamedItem(&quot;value&quot;);</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">                    if (valueAttr == null)</span>
<span class="nc" id="L295">                        throw new ConfigurationException(</span>
                                &quot;IfOption has no optionValue attribute&quot;);
<span class="fc" id="L297">                    value = valueAttr.getNodeValue();</span>
<span class="fc" id="L298">                    valueList = Arrays.asList(value.split(&quot;,&quot;));</span>

                    // Check if the option has been chosen; if not, skip the
                    // rest
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">                    if (gameOptions == null) {</span>
<span class="nc" id="L303">                        throw new ConfigurationException(</span>
<span class="nc" id="L304">                                &quot;No GameOptions available in tag &quot; + element.getNodeName());</span>
                    }

<span class="fc" id="L307">                    String optionValue = gameOptions.get(name);</span>

                    // For backwards compatibility: search for an extended name
                    /* This applies to parametrized options, such as &quot;UnlimitedTopTrains&quot;.
                     * It parametrized with a parameter &quot;D&quot; to allow display as &quot;Unlimited D-trains&quot;
                     * and still remaining generic.
                     * Parametrization means that the actual name is UnlimitedTopTrains_D,
                     * for instance in saved files, and so the name must be shortened to find a match.
                     */

                    // FIXME: Rails 2.0 removed that handling, only logging errors now
<span class="fc bfc" id="L318" title="All 2 branches covered.">                    if (optionValue == null) {</span>
<span class="fc" id="L319">                        log.error(&quot;GameOption {}={} has no assigned value&quot;, name, value);</span>
                    }

//                    if (optionValue == null) {
//                    	for (String optName : gameOptions.getOptions().keySet()) {
//                    	    // startsWith is a shortcut, perhaps it should be matches(name+&quot;_.*&quot;).
//                    		if (optName != null &amp;&amp; optName.startsWith(name)) {
//                    			optionValue = gameOptions.get(optName);
//                    			log.warn(&quot;Option name &quot;+name+&quot; replaced by &quot;+optName);
//                    			break;
//                    		}
//                    	}
//                    }
//
//                    // If not assigned in the previous step, take the default value
//                    if (optionValue == null) {
//                        GameOption go = GameOption.getByName(name);
//                        optionValue = go != null ? go.getDefaultValue() : &quot;&quot;;
//                        log.warn(&quot;GameOption &quot; + name + &quot;=&quot; + value
//                                 + &quot; but no assigned value found, assumed &quot;+optionValue);
//
//                    }

<span class="fc bfc" id="L342" title="All 2 branches covered.">                    if (valueList.contains(optionValue)) {</span>
<span class="fc" id="L343">                        parseSubTags(childElement);</span>
                    }
<span class="fc" id="L345">                } else {</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                    if (!children.containsKey(childTagName)) {</span>
<span class="fc" id="L347">                        children.put(childTagName, new ArrayList&lt;Tag&gt;());</span>
                    }
<span class="fc" id="L349">                    children.get(childTagName).add(new Tag(childElement, gameOptions));</span>
                }
<span class="fc bfc" id="L351" title="All 2 branches covered.">            } else if (childNode.getNodeType() == Node.TEXT_NODE) {</span>
<span class="fc" id="L352">                textBuffer.append(childNode.getNodeValue());</span>
            }
        }

<span class="fc" id="L356">        text = textBuffer.toString();</span>
<span class="fc" id="L357">        parsed = true;</span>
<span class="fc" id="L358">        parsing = false;</span>
<span class="fc" id="L359">    }</span>

    /**
     * Opens and parses an xml file. Searches the root level of the file for an
     * element with the supplied name.
     *
     * @param fileName the name of the file to open
     * @param tagName  the name of the top-level tag to find
     * @return the named element in the named file
     * @throws ConfigurationException if there is any problem opening and
     *                                parsing the file, or if the file does not contain a top level element
     *                                with the given name.
     */
    public static Tag findTopTagInFile(String filename, String directory,
                                       String tagName, GameOptionsSet gameOptions) throws ConfigurationException {
<span class="fc" id="L374">        Document doc = null;</span>
        try {
            // Step 1: create a DocumentBuilderFactory and setNamespaceAware
<span class="fc" id="L377">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="fc" id="L378">            dbf.setNamespaceAware(true);</span>
<span class="fc" id="L379">            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span>
            // Step 2: create a DocumentBuilder
<span class="fc" id="L381">            DocumentBuilder db = dbf.newDocumentBuilder();</span>

            // Step 3: parse the input file to get a Document object
<span class="fc" id="L384">            doc = db.parse(ResourceLoader.getInputStream(filename, directory));</span>
<span class="nc" id="L385">        } catch (ParserConfigurationException | SAXException | IOException e) {</span>
<span class="nc" id="L386">            throw new ConfigurationException(&quot;Could not read/parse &quot; + filename</span>
                    + &quot; to find element &quot; + tagName, e);
<span class="fc" id="L388">        }</span>

<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (doc == null) {</span>
<span class="nc" id="L391">            throw new ConfigurationException(&quot;Cannot find file &quot; + filename);</span>
        }

        // Now find the named Element
<span class="fc" id="L395">        NodeList nodeList = doc.getChildNodes();</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        for (int iNode = 0; (iNode &lt; nodeList.getLength()); iNode++) {</span>
<span class="fc" id="L397">            Node childNode = nodeList.item(iNode);</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">            if ((childNode != null)</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">                    &amp;&amp; (childNode.getNodeName().equals(tagName))</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">                    &amp;&amp; (childNode.getNodeType() == Node.ELEMENT_NODE)) {</span>
<span class="fc" id="L401">                return new Tag((Element) childNode, gameOptions);</span>
            }
        }
<span class="nc" id="L404">        throw new ConfigurationException(&quot;Could not find &quot; + tagName + &quot; in &quot; + filename);</span>
    }

    public Element getElement() {
<span class="nc" id="L408">        return element;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L413">        return MoreObjects.toStringHelper(this)</span>
<span class="fc" id="L414">                .add(&quot;attributes&quot;, attributes)</span>
<span class="fc" id="L415">                .add(&quot;children&quot;, children)</span>
<span class="fc" id="L416">                .toString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>