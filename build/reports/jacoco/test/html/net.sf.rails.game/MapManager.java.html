<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.game</a> &gt; <span class="el_source">MapManager.java</span></div><h1>MapManager.java</h1><pre class="source lang-java linenums">package net.sf.rails.game;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.SortedSet;

import net.sf.rails.common.Config;
import net.sf.rails.common.parser.Configurable;
import net.sf.rails.common.parser.ConfigurationException;
import net.sf.rails.common.parser.Tag;

import com.google.common.collect.HashBasedTable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.ImmutableTable;
import com.google.common.collect.Table;


/**
 * MapManager configures the map layout from XML
 */
public class MapManager extends RailsManager implements Configurable {

    private MapOrientation mapOrientation;

    private ImmutableMap&lt;MapHex.Coordinates, MapHex&gt; hexes;
    private ImmutableTable&lt;MapHex, HexSide, MapHex&gt; hexTable;

    private MapHex.Coordinates minimum;
    private MapHex.Coordinates maximum;

    // upgrade costs on the map for noMapMode
    private ImmutableSortedSet&lt;Integer&gt; possibleTileCosts;

    // Stop property defaults per stop type
    private ImmutableMap&lt;String, StopType&gt; defaultStopTypes;
    
    // if required: distance table
    private Table&lt;MapHex, MapHex, Integer&gt; hexDistances;

    // Optional map image (SVG file)
    // FIXME: Move to UI class
<span class="fc" id="L46">    private String mapImageFilename = null;</span>
<span class="fc" id="L47">    private String mapImageFilepath = null;</span>
<span class="fc" id="L48">    private int mapXOffset = 0;</span>
<span class="fc" id="L49">    private int mapYOffset = 0;</span>
<span class="fc" id="L50">    private float mapScale = (float)1.0;</span>
<span class="fc" id="L51">    private boolean mapImageUsed = false;</span>

    /**
     * Used by Configure (via reflection) only
     */
    public MapManager(RailsRoot parent, String id) {
<span class="fc" id="L57">        super(parent, id);</span>
<span class="fc" id="L58">    }</span>
    
    /**
     * @see net.sf.rails.common.parser.Configurable#configureFromXML(org.w3c.dom.Element)
     */
    public void configureFromXML(Tag tag) throws ConfigurationException {
        
<span class="fc" id="L65">        mapOrientation = MapOrientation.create(tag);</span>
        
<span class="fc" id="L67">        List&lt;Tag&gt; hexTags = tag.getChildren(&quot;Hex&quot;);</span>
<span class="fc" id="L68">        ImmutableMap.Builder&lt;MapHex.Coordinates, MapHex&gt; hexBuilder = ImmutableMap.builder();</span>
<span class="fc" id="L69">        ImmutableSortedSet.Builder&lt;Integer&gt; tileCostsBuilder= ImmutableSortedSet.naturalOrder();</span>

<span class="fc bfc" id="L71" title="All 2 branches covered.">        for (Tag hexTag : hexTags) {</span>
<span class="fc" id="L72">            MapHex hex = MapHex.create(this, hexTag);</span>
<span class="fc" id="L73">            hexBuilder.put(hex.getCoordinates(), hex);</span>
<span class="fc" id="L74">            tileCostsBuilder.addAll(hex.getTileCostsList());</span>
<span class="fc" id="L75">        }</span>
<span class="fc" id="L76">        hexes = hexBuilder.build();</span>
<span class="fc" id="L77">        possibleTileCosts = tileCostsBuilder.build();</span>
        
<span class="fc" id="L79">        minimum = MapHex.Coordinates.minimum(hexes.values());</span>
<span class="fc" id="L80">        maximum = MapHex.Coordinates.maximum(hexes.values());</span>
        
        // Default Stop Types
<span class="fc" id="L83">        Tag defaultsTag = tag.getChild(&quot;Defaults&quot;);</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (defaultsTag != null) {</span>
<span class="fc" id="L85">            List&lt;Tag&gt; accessTags = defaultsTag.getChildren(&quot;Access&quot;);</span>
<span class="fc" id="L86">            defaultStopTypes = StopType.parseDefaults(this, accessTags);</span>
<span class="fc" id="L87">        } else {</span>
<span class="fc" id="L88">            defaultStopTypes = ImmutableMap.of();</span>
        }

        // Map image attributes
        // FIXME: Move to an UI class
<span class="fc" id="L93">        Tag mapImageTag = tag.getChild(&quot;Image&quot;);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        if (mapImageTag != null) {</span>
<span class="fc" id="L95">            mapImageFilename = mapImageTag.getAttributeAsString(&quot;file&quot;);</span>
<span class="fc" id="L96">            mapXOffset = mapImageTag.getAttributeAsInteger(&quot;x&quot;, mapXOffset);</span>
<span class="fc" id="L97">            mapYOffset = mapImageTag.getAttributeAsInteger(&quot;y&quot;, mapYOffset);</span>
<span class="fc" id="L98">            mapScale = mapImageTag.getAttributeAsFloat(&quot;scale&quot;, mapScale);</span>
        }
<span class="fc" id="L100">    }</span>

    public void finishConfiguration (RailsRoot root) throws ConfigurationException {

<span class="fc bfc" id="L104" title="All 2 branches covered.">        for (MapHex hex:hexes.values()) {</span>
<span class="fc" id="L105">            hex.finishConfiguration(root);</span>
<span class="fc" id="L106">        }</span>

        // Initialise the neighbours
<span class="fc" id="L109">        ImmutableTable.Builder&lt;MapHex, HexSide, MapHex&gt; hexTableBuilder = ImmutableTable.builder();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        for (MapHex hex:hexes.values()) {</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">            for (HexSide side:HexSide.all()){</span>
<span class="fc" id="L112">                MapHex neighbour = hexes.get(mapOrientation.</span>
<span class="fc" id="L113">                        getAdjacentCoordinates(hex.getCoordinates(), side));</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">                if (neighbour != null) {</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">                    if (hex.isValidNeighbour(neighbour, side)) {</span>
<span class="fc" id="L116">                        hexTableBuilder.put(hex, side, neighbour);</span>
                    } else {
<span class="fc" id="L118">                        hex.addInvalidSide(side);</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">                        if (hex.isImpassableNeighbour(neighbour)) {</span>
<span class="fc" id="L120">                            hex.addImpassableSide(side);</span>
<span class="fc" id="L121">                            neighbour.addImpassableSide(side.opposite());</span>
                        }
                    }
                } else { // neighbour is null
<span class="fc" id="L125">                    hex.addInvalidSide(side);</span>
                }
<span class="fc" id="L127">            }</span>
<span class="fc" id="L128">        }</span>
<span class="fc" id="L129">        hexTable = hexTableBuilder.build();</span>

<span class="fc bfc" id="L131" title="All 2 branches covered.">        for (PublicCompany company : root.getCompanyManager().getAllPublicCompanies()) {</span>
<span class="fc" id="L132">            List&lt;MapHex&gt; homeHexes = company.getHomeHexes();</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">            if (homeHexes != null) {</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">                for (MapHex homeHex : homeHexes) {</span>
<span class="fc" id="L135">                   int homeNumber = company.getHomeCityNumber();</span>
<span class="fc" id="L136">                   Stop home = homeHex.getRelatedStop(homeNumber);</span>
<span class="pc bpc" id="L137" title="1 of 4 branches missed.">                   if (home == null &amp;&amp; homeNumber != 0) {</span>
<span class="nc" id="L138">                       throw new ConfigurationException (&quot;Invalid home number &quot;+homeNumber+&quot; for hex &quot;+homeHex</span>
<span class="nc" id="L139">                               +&quot; which has &quot;+homeHex.getStops().size()+&quot; stop&quot;);</span>
                   } else {
<span class="fc" id="L141">                       homeHex.addHome(company, home);</span>
                   }
<span class="fc" id="L143">                }</span>
            }
<span class="fc" id="L145">            MapHex hex = company.getDestinationHex();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (hex != null) {</span>
<span class="fc" id="L147">                hex.addDestination(company);</span>
            }
<span class="fc" id="L149">        }</span>

        // FIXME: Move this configuration to an UI class
<span class="fc bfc" id="L152" title="All 2 branches covered.">        mapImageUsed = net.sf.rails.util.Util.hasValue(mapImageFilename)</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        &amp;&amp; &quot;yes&quot;.equalsIgnoreCase(Config.get(&quot;map.image.display&quot;));</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (mapImageUsed) {</span>
<span class="fc" id="L155">            String rootDirectory = Config.get(&quot;map.root_directory&quot;);</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">            if (!net.sf.rails.util.Util.hasValue(rootDirectory)) {</span>
<span class="fc" id="L157">                rootDirectory = &quot;data&quot;;</span>
            }
<span class="fc" id="L159">            mapImageFilepath = &quot;/&quot; + rootDirectory + &quot;/&quot; + mapImageFilename;</span>
        }

<span class="fc" id="L162">    }</span>

    /**
     * @return Returns the currentTileOrientation.
     */
    public MapOrientation getMapOrientation() {
<span class="fc" id="L168">        return mapOrientation;</span>
    }

    /**
     * @return Returns the hexes.
     */
    public Collection&lt;MapHex&gt; getHexes() {
<span class="fc" id="L175">        return hexes.values();</span>
    }
    
    
    public MapHex getNeighbour(MapHex hex, HexSide side) {
<span class="fc" id="L180">        return hexTable.get(hex, side);</span>
    }

    public MapHex getHex(String locationCode) {
        // MapManager is a RailsManager so it is possible to locate by id
<span class="fc" id="L185">        return (MapHex) locate(locationCode);</span>
    }

    public MapHex.Coordinates getMinimum() {
<span class="nc" id="L189">        return minimum;</span>
    }
    
    public MapHex.Coordinates getMaximum() {
<span class="nc" id="L193">        return maximum;</span>
    }
    
    public String getMapUIClassName() {
<span class="nc" id="L197">        return mapOrientation.getUIClassName();</span>
    }

    public Map&lt;String, StopType&gt; getDefaultStopTypes() {
<span class="fc" id="L201">        return defaultStopTypes;</span>
    }

    public List&lt;Stop&gt; getCurrentStops() {
<span class="fc" id="L205">        ImmutableList.Builder&lt;Stop&gt; stops = ImmutableList.builder();</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (MapHex hex : hexes.values()) {</span>
<span class="fc" id="L207">            stops.addAll(hex.getStops());</span>
<span class="fc" id="L208">        }</span>
<span class="fc" id="L209">        return stops.build();</span>
    }

    public SortedSet&lt;Integer&gt; getPossibleTileCosts() {
<span class="nc" id="L213">        return possibleTileCosts;</span>
    }

    public List&lt;MapHex&gt; parseLocations (String locationCodes)
            throws IllegalArgumentException {

<span class="fc" id="L219">        ImmutableList.Builder&lt;MapHex&gt; locationBuilder = ImmutableList.builder(); </span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        for (String hexName : locationCodes.split(&quot;,&quot;)) {</span>
<span class="fc" id="L221">            MapHex hex = getHex(hexName);</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            if (hex != null) {</span>
<span class="fc" id="L223">                locationBuilder.add(hex);</span>
            } else {
<span class="nc" id="L225">                throw new IllegalArgumentException(&quot;Invalid hex &quot;+hexName+</span>
                        &quot; specified in location string &quot; + locationCodes);
            }
        }
<span class="fc" id="L229">        return locationBuilder.build();</span>
    }

    /**
     * Calculate the distance between two hexes as in 1835,
     * i.e. as &quot;the crow without a passport flies&quot;.
     */
    public int getHexDistance (MapHex hex1, MapHex hex2) {
<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (hexDistances == null) {</span>
<span class="fc" id="L238">            hexDistances = HashBasedTable.create();</span>
        }

<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (!hexDistances.contains(hex1, hex2)) {</span>
<span class="fc" id="L242">            calculateHexDistances(hex1, hex1, 0);</span>
        }
<span class="fc" id="L244">        return hexDistances.get(hex1, hex2);</span>
    }

    private void calculateHexDistances (MapHex initHex, MapHex currentHex, int depth) {
<span class="fc" id="L248">        hexDistances.put(initHex, currentHex, depth);</span>
        
        // check for next hexes
<span class="fc" id="L251">        depth ++;</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        for (MapHex nextHex:hexTable.row(currentHex).values()) {</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">            if (!hexDistances.contains(initHex, nextHex) ||</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">                    depth &lt; hexDistances.get(initHex, nextHex)) {</span>
<span class="fc" id="L255">                calculateHexDistances(initHex, nextHex, depth);</span>
            }
<span class="fc" id="L257">        }</span>
<span class="fc" id="L258">    }</span>


    /**
     * Calculate the distances between a given tokenable city hex
     * and all other tokenable city hexes.
     * &lt;p&gt; Distances are cached.
     * @param hex Start hex
     * @return Sorted integer list containing all occurring distances only once.
     */
    public SortedSet&lt;Integer&gt; getCityDistances (MapHex initHex) {
        
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (hexDistances == null) {</span>
<span class="nc" id="L271">            hexDistances = HashBasedTable.create();</span>
        }

<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (!hexDistances.containsRow(initHex)) {</span>
<span class="nc" id="L275">            calculateHexDistances(initHex, initHex, 0);</span>
        }
        
        ImmutableSortedSet.Builder&lt;Integer&gt; distances = 
<span class="nc" id="L279">                ImmutableSortedSet.naturalOrder();</span>
        
<span class="nc bnc" id="L281" title="All 2 branches missed.">        for (Entry&lt;MapHex, Integer&gt; otherHex:hexDistances.row(initHex).entrySet()) {</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">            if (otherHex.getKey().getCurrentTile().hasStations()) {</span>
<span class="nc" id="L283">                distances.add(otherHex.getValue());</span>
            }
<span class="nc" id="L285">        }</span>
<span class="nc" id="L286">        return distances.build();</span>
    }

    public String getMapImageFilepath() {
<span class="nc" id="L290">        return mapImageFilepath;</span>
    }

    public int getMapXOffset() {
<span class="nc" id="L294">        return mapXOffset;</span>
    }

    public int getMapYOffset() {
<span class="nc" id="L298">        return mapYOffset;</span>
    }

    public float getMapScale() {
<span class="nc" id="L302">        return mapScale;</span>
    }

    public void setMapXOffset(int mapXOffset) {
<span class="nc" id="L306">        this.mapXOffset = mapXOffset;</span>
<span class="nc" id="L307">    }</span>

    public void setMapYOffset(int mapYOffset) {
<span class="nc" id="L310">        this.mapYOffset = mapYOffset;</span>
<span class="nc" id="L311">    }</span>

    public void setMapScale(float mapScale) {
<span class="nc" id="L314">        this.mapScale = mapScale;</span>
<span class="nc" id="L315">    }</span>

    public boolean isMapImageUsed() {
<span class="nc" id="L318">        return mapImageUsed;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>