<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PublicCompany.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.game</a> &gt; <span class="el_source">PublicCompany.java</span></div><h1>PublicCompany.java</h1><pre class="source lang-java linenums">package net.sf.rails.game;

import java.awt.Color;
import java.util.*;

import net.sf.rails.common.GuiDef;
import net.sf.rails.common.LocalText;
import net.sf.rails.common.ReportBuffer;
import net.sf.rails.common.parser.ConfigurationException;
import net.sf.rails.common.parser.Tag;
import net.sf.rails.game.financial.Bank;
import net.sf.rails.game.financial.BankPortfolio;
import net.sf.rails.game.financial.PublicCertificate;
import net.sf.rails.game.financial.RailsMoneyOwner;
import net.sf.rails.game.financial.StockSpace;
import net.sf.rails.game.model.*;
import net.sf.rails.game.special.*;
import net.sf.rails.game.state.*;
import net.sf.rails.game.state.Currency;
import net.sf.rails.game.state.Observable;
import net.sf.rails.util.Util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import rails.game.action.SetDividend;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;


/**
 * This class provides an implementation of a (perhaps only basic) public
 * company. Public companies encompass all 18xx company-like entities that lay
 * tracks and run trains. &lt;p&gt; Ownership of companies will always be performed by
 * holding certificates. Some minor company types may have only one certificate,
 * but this will still be the form in which ownership is expressed. &lt;p&gt; Company
 * shares may or may not have a price on the stock market.
 *
 */
public class PublicCompany extends RailsAbstractItem implements Company, RailsMoneyOwner, PortfolioOwner, Comparable&lt;PublicCompany&gt; {

<span class="fc" id="L43">    private static final Logger log = LoggerFactory.getLogger(PublicCompany.class);</span>

    public static final int CAPITALISE_FULL = 0;

    public static final int CAPITALISE_INCREMENTAL = 1;

    public static final int CAPITALISE_WHEN_BOUGHT = 2;

    protected static final int DEFAULT_SHARE_UNIT = 10;

<span class="fc" id="L53">    protected static int numberOfPublicCompanies = 0;</span>

    // Home base &amp; price token lay times
    protected static final int WHEN_STARTED = 0;
    protected static final int WHEN_FLOATED = 1;
    protected static final int START_OF_FIRST_OR = 2; // Only applies to home base tokens

    // Base token lay cost calculation methods
    public static final String BASE_COST_SEQUENCE = &quot;sequence&quot;;
    public static final String BASE_COST_DISTANCE = &quot;distance&quot;;

<span class="fc" id="L64">    protected static final String[] tokenLayTimeNames =</span>
        new String[] { &quot;whenStarted&quot;, &quot;whenFloated&quot;, &quot;firstOR&quot; };

<span class="fc" id="L67">    protected int homeBaseTokensLayTime = START_OF_FIRST_OR;</span>


    /**
     * Foreground (i.e. text) colour of the company tokens (if pictures are not
     * used)
     */
    protected Color fgColour;

    /** Hexadecimal representation (RRGGBB) of the foreground colour. */
<span class="fc" id="L77">    protected String fgHexColour = &quot;FFFFFF&quot;;</span>

    /** Background colour of the company tokens */
    protected Color bgColour;

    /** Hexadecimal representation (RRGGBB) of the background colour. */
<span class="fc" id="L83">    protected String bgHexColour = &quot;000000&quot;;</span>

    /** Home hex &amp; city *
     * Two home hexes is supported, but only if:&lt;br&gt;
     * 1. The locations are fixed (i.e. configured by XML), and&lt;br&gt;
     * 2. Any station (city) numbers are equal for the two home stations.
     * There is no provision yet for two home hexes having different tile station numbers. */
<span class="fc" id="L90">    protected String homeHexNames = null;</span>
<span class="fc" id="L91">    protected List&lt;MapHex&gt; homeHexes = null;</span>
<span class="fc" id="L92">    protected int homeCityNumber = 1;</span>

    /** Destination hex * */
<span class="fc" id="L95">    protected String destinationHexName = null;</span>
<span class="fc" id="L96">    protected MapHex destinationHex = null;</span>
<span class="fc" id="L97">    protected final BooleanState hasReachedDestination = BooleanState.create(this, &quot;hasReachedDestinations&quot;);</span>

    /** Sequence number in the array of public companies - may not be useful */
<span class="fc" id="L100">    protected int publicNumber = -1; // For internal use</span>

<span class="fc" id="L102">    protected int numberOfBaseTokens = 0;</span>

<span class="fc" id="L104">    protected int baseTokensBuyCost = 0;</span>
    /** An array of base token laying costs, per successive token */
    protected List&lt;Integer&gt; baseTokenLayCost;
<span class="fc" id="L107">    protected String baseTokenLayCostMethod = &quot;sequential&quot;;</span>

<span class="fc" id="L109">    protected final BaseTokensModel baseTokens = BaseTokensModel.create(this, &quot;baseTokens&quot;); // Create after cloning ?</span>
<span class="fc" id="L110">    protected final PortfolioModel portfolio = PortfolioModel.create(this);</span>


    /**
     * Initial (par) share price, represented by a stock market location object
     */
    protected PriceModel parPrice;

    /** Current share price, represented by a stock market location object */
    protected PriceModel currentPrice;

    /** Company treasury, holding cash */
<span class="fc" id="L122">    protected final PurseMoneyModel treasury =</span>
<span class="fc" id="L123">            PurseMoneyModel.create(this, &quot;treasury&quot;, false);</span>

    /** PresidentModel */
<span class="fc" id="L126">    protected final PresidentModel presidentModel = PresidentModel.create(this);</span>

    /** Has the company started? */
<span class="fc" id="L129">    protected final BooleanState hasStarted = BooleanState.create(this, &quot;hasStarted&quot;);</span>

    /** Total bonus tokens amount */
<span class="fc" id="L132">    protected final BonusModel bonusValue = BonusModel.create(this, &quot;bonusValue&quot;);</span>

    /** Acquires Bonus objects */
<span class="fc" id="L135">    protected final ArrayListState&lt;Bonus&gt; bonuses = ArrayListState.create(this, &quot;bonuses&quot;);</span>

    /** Most recent revenue earned. */
<span class="fc" id="L138">    protected final CountingMoneyModel lastRevenue = CountingMoneyModel.create(this, &quot;lastRevenue&quot;, false);</span>

<span class="fc" id="L140">    public final CountingMoneyModel  directIncomeRevenue = CountingMoneyModel.create(this, &quot;directIncome&quot;, false);</span>

    /** Most recent Direct Company Treasury income earned. */
<span class="fc" id="L143">    protected final CountingMoneyModel lastDirectIncome = CountingMoneyModel.create(this, &quot;lastDirectIncome&quot;, false);</span>

    /** Most recent payout decision. */
<span class="fc" id="L146">    protected final StringState lastRevenueAllocation = StringState.create(this, &quot;lastRevenueAllocation&quot;);</span>

    /** Is the company operational (&quot;has it floated&quot;)? */
<span class="fc" id="L149">    protected final BooleanState hasFloated = BooleanState.create(this, &quot;hasFloated&quot;);</span>

    /** Has the company already operated? */
<span class="fc" id="L152">    protected final BooleanState hasOperated = BooleanState.create(this, &quot;hasOperated&quot;);</span>

    /** Are company shares buyable (i.e. before started)? */
<span class="fc" id="L155">    protected final BooleanState buyable = BooleanState.create(this, &quot;buyable&quot;);</span>

    /** In-game state.
     * &lt;p&gt; Will only be set false if the company is closed and cannot ever be reopened.
     * By default it will be set false if a company is closed. */
    // TODO: Check if there was some assumption to be null at some place
<span class="fc" id="L161">    protected final BooleanState inGameState = BooleanState.create(this, &quot;inGameState&quot;, true);</span>

    // TODO: the extra turn model has to be rewritten (it is not fully undo proof)

    /** Stores the number of turns with extraLays */
<span class="fc" id="L166">    protected Map&lt;String, IntegerState&gt; turnsWithExtraTileLays = null;</span>

    /** This receives the current value of turnsWithExtraTileLays  */
<span class="fc" id="L169">    protected GenericState&lt;IntegerState&gt; extraTiles = GenericState.create(this, &quot;extraTiles&quot;);</span>

    /* Spendings in the current operating turn */
<span class="fc" id="L172">    protected final CountingMoneyModel privatesCostThisTurn = CountingMoneyModel.create(this, &quot;privatesCostThisTurn&quot;, false);</span>

<span class="fc" id="L174">    protected final StringState tilesLaidThisTurn = StringState.create(this, &quot;tilesLaidThisTurn&quot;);</span>

<span class="fc" id="L176">    protected final CountingMoneyModel tilesCostThisTurn = CountingMoneyModel.create(this, &quot;tilesCostThisTurn&quot;, false);</span>

<span class="fc" id="L178">    protected final StringState tokensLaidThisTurn = StringState.create(this, &quot;tokenLaidThisTurn&quot;);</span>

<span class="fc" id="L180">    protected final CountingMoneyModel tokensCostThisTurn = CountingMoneyModel.create(this, &quot;tokensCostThisTurn&quot;, false);</span>

<span class="fc" id="L182">    protected final CountingMoneyModel trainsCostThisTurn = CountingMoneyModel.create(this, &quot;trainsCostThisTurn&quot;, false);</span>

<span class="fc" id="L184">    protected boolean canBuyStock = false;</span>

<span class="fc" id="L186">    protected boolean canBuyPrivates = false;</span>

<span class="fc" id="L188">    protected boolean canUseSpecialProperties = false;</span>

    /** Can a company be restarted once it is closed? */
<span class="fc" id="L191">    protected boolean canBeRestarted = false;</span>

    /**
     * Minimum price for buying privates, to be multiplied by the original price
     */
    protected float lowerPrivatePriceFactor;

    /**
     * Maximum price for buying privates, to be multiplied by the original price
     */
    protected float upperPrivatePriceFactor;

<span class="fc" id="L203">    protected boolean ipoPaysOut = false;</span>

<span class="fc" id="L205">    protected boolean poolPaysOut = false;</span>

<span class="fc" id="L207">    protected boolean treasuryPaysOut = false;</span>

<span class="fc" id="L209">    protected boolean canHoldOwnShares = false;</span>

<span class="fc" id="L211">    protected int maxPercOfOwnShares = 0;</span>

<span class="fc" id="L213">    protected boolean mayTradeShares = false;</span>

<span class="fc" id="L215">    protected boolean mustHaveOperatedToTradeShares = false;</span>

<span class="fc" id="L217">    protected List&lt;Tag&gt; certificateTags = null;</span>

    /** The certificates of this company (minimum 1) */
<span class="fc" id="L220">    protected final ArrayListState&lt;PublicCertificate&gt; certificates = ArrayListState.create(this, &quot;ownCertificates&quot;);</span>
    /** Are the certificates available from the first SR? */
<span class="fc" id="L222">    protected boolean certsAreInitiallyAvailable = true;</span>

    /** What percentage of ownership constitutes &quot;one share&quot; */
<span class="fc" id="L225">    protected IntegerState shareUnit = IntegerState.create(this, &quot;shareUnit&quot;, DEFAULT_SHARE_UNIT);</span>

    /** What number of share units relates to the share price
     * (normally 1, but 2 for 1835 Prussian)
     */
<span class="fc" id="L230">    protected int shareUnitsForSharePrice = 1;</span>

    /** At what percentage sold does the company float */
<span class="fc" id="L233">    protected int floatPerc = 0;</span>

    /** Share price movement on floating (1851: up) */
<span class="fc" id="L236">    protected boolean sharePriceUpOnFloating = false;</span>

    /** Does the company have a stock price (minors often don't) */
<span class="fc" id="L239">    protected boolean hasStockPrice = true;</span>

    /** Does the company have a par price? */
<span class="fc" id="L242">    protected boolean hasParPrice = true;</span>

<span class="fc" id="L244">    protected boolean splitAllowed = false;</span>

    /** Is the revenue always split (typical for non-share minors) */
<span class="fc" id="L247">    protected boolean splitAlways = false;</span>

    /** Must payout exceed stock price to move token right? */
<span class="fc" id="L250">    protected boolean payoutMustExceedPriceToMove = false;</span>

    /** Multiple certificates those that represent more than one nominal share unit (except president share) */
<span class="fc" id="L253">    protected boolean hasMultipleCertificates = false;</span>

    /*---- variables needed during initialisation -----*/
<span class="fc" id="L256">    protected String startSpace = null;</span>

<span class="fc" id="L258">    protected int dropPriceToken = WHEN_STARTED;</span>

<span class="fc" id="L260">    protected int capitalisation = CAPITALISE_FULL;</span>

    /** Fixed price (for a 1835-style minor) */
<span class="fc" id="L263">    protected int fixedPrice = 0;</span>

    /** Train limit per phase (index) */
    protected List&lt;Integer&gt; trainLimit;

    /** Private to close if first train is bought */
<span class="fc" id="L269">    protected String privateToCloseOnFirstTrainName = null;</span>

<span class="fc" id="L271">    protected PrivateCompany privateToCloseOnFirstTrain = null;</span>

    /** Must the company own a train */
<span class="fc" id="L274">    protected boolean mustOwnATrain = true;</span>

<span class="fc" id="L276">    protected boolean mustTradeTrainsAtFixedPrice = false;</span>

    /** Can the company price token go down to a &quot;Close&quot; square?
     * 1856 CGR cannot.
     */
<span class="fc" id="L281">    protected boolean canClose = true;</span>

    /** Initial train at floating time */
<span class="fc" id="L284">    protected String initialTrainType = null;</span>
<span class="fc" id="L285">    protected int initialTrainCost = 0;</span>
<span class="fc" id="L286">    protected boolean initialTrainTradeable = true;</span>

    /* Loans */
<span class="fc" id="L289">    protected int maxNumberOfLoans = 0;</span>
<span class="fc" id="L290">    protected int valuePerLoan = 0;</span>
<span class="fc" id="L291">    protected IntegerState currentNumberOfLoans = null; // init during finishConfig</span>
<span class="fc" id="L292">    protected int loanInterestPct = 0;</span>
<span class="fc" id="L293">    protected int maxLoansPerRound = 0;</span>
<span class="fc" id="L294">    protected CountingMoneyModel currentLoanValue = null; // init during finishConfig</span>

    protected BooleanState canSharePriceVary;

<span class="fc" id="L298">    protected RightsModel rightsModel = null; // init if required</span>
    // created in finishConfiguration

    // used for Company interface
    private String longName;
    private String alias;
    private CompanyType type;
<span class="fc" id="L305">    private String infoText =&quot;&quot;;</span>
<span class="fc" id="L306">    private String parentInfoText =&quot;&quot;;</span>
<span class="fc" id="L307">    private final BooleanState closed = BooleanState.create(this, &quot;closed&quot;, false);</span>

    /**
     *  Relation to a later to be founded National/Regional Major Company
     *  */
<span class="fc" id="L312">    private String relatedPublicCompany = null;</span>

<span class="fc" id="L314">    private String foundingStartCompany = null;</span>

    /**
     * Used by Configure (via reflection) only
     */
    public PublicCompany(RailsItem parent, String id) {
<span class="fc" id="L320">        this(parent, id, true);</span>
<span class="fc" id="L321">    }</span>

    public PublicCompany(RailsItem parent, String id, boolean hasStockPrice) {
<span class="fc" id="L324">        super(parent, id);</span>
<span class="fc" id="L325">        lastRevenue.setSuppressInitialZero(true);</span>

        /* Spendings in the current operating turn */
<span class="fc" id="L328">        privatesCostThisTurn.setSuppressZero(true);</span>
<span class="fc" id="L329">        tilesCostThisTurn.setSuppressZero(true);</span>
<span class="fc" id="L330">        tokensCostThisTurn.setSuppressZero(true);</span>
<span class="fc" id="L331">        trainsCostThisTurn.setSuppressZero(true);</span>
<span class="fc" id="L332">        trainsCostThisTurn.setDisplayNegative(true);</span>

        // Bonuses
<span class="fc" id="L335">        bonusValue.setBonuses(bonuses);</span>

<span class="fc" id="L337">        this.hasStockPrice = hasStockPrice;</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (hasStockPrice) {</span>
<span class="fc" id="L339">            parPrice = PriceModel.create(this, &quot;ParPrice&quot;, false);</span>
<span class="fc" id="L340">            currentPrice = PriceModel.create(this, &quot;currentPrice&quot;, true);</span>
<span class="fc" id="L341">            canSharePriceVary = BooleanState.create(this, &quot;canSharePriceVary&quot;, true);</span>
        }
<span class="fc" id="L343">    }</span>


    /**
     * To configure all public companies from the &amp;lt;PublicCompany&amp;gt; XML
     * element
     */
    public void configureFromXML(Tag tag) throws ConfigurationException {

<span class="fc" id="L352">        longName = tag.getAttributeAsString(&quot;longname&quot;, getId());</span>
<span class="fc" id="L353">        infoText = &quot;&lt;html&gt;&quot;+longName;</span>

<span class="fc" id="L355">        alias = tag.getAttributeAsString(&quot;alias&quot;, alias);</span>

        /* Configure public company features */
<span class="fc" id="L358">        fgHexColour = tag.getAttributeAsString(&quot;fgColour&quot;, fgHexColour);</span>
<span class="fc" id="L359">        fgColour = Util.parseColour(fgHexColour);</span>

<span class="fc" id="L361">        bgHexColour = tag.getAttributeAsString(&quot;bgColour&quot;, bgHexColour);</span>
<span class="fc" id="L362">        bgColour = Util.parseColour(bgHexColour);</span>

<span class="fc" id="L364">        floatPerc = tag.getAttributeAsInteger(&quot;floatPerc&quot;, floatPerc);</span>

<span class="fc" id="L366">        relatedPublicCompany = tag.getAttributeAsString (&quot;relatedCompany&quot;, relatedPublicCompany);</span>

<span class="fc" id="L368">        foundingStartCompany =  tag.getAttributeAsString(&quot;foundingCompany&quot;, foundingStartCompany);</span>

<span class="fc" id="L370">        startSpace = tag.getAttributeAsString(&quot;startspace&quot;);</span>
        // Set the default price token drop time.
        // Currently, no exceptions exist, so this value isn't changed anywhere yet.
        // Any (future) games with exceptions to these defaults will require a separate XML attribute.
        // Known games to have exceptions: 1837.
<span class="fc bfc" id="L375" title="All 2 branches covered.">        dropPriceToken = startSpace != null ? WHEN_FLOATED : WHEN_STARTED;</span>

<span class="fc" id="L377">        fixedPrice = tag.getAttributeAsInteger(&quot;price&quot;, 0);</span>

<span class="fc" id="L379">        numberOfBaseTokens = tag.getAttributeAsInteger(&quot;tokens&quot;, 1);</span>

<span class="fc" id="L381">        certsAreInitiallyAvailable</span>
<span class="fc" id="L382">        = tag.getAttributeAsBoolean(&quot;available&quot;, certsAreInitiallyAvailable);</span>

<span class="fc" id="L384">        canBeRestarted = tag.getAttributeAsBoolean(&quot;restartable&quot;, canBeRestarted);</span>

<span class="fc" id="L386">        Tag shareUnitTag = tag.getChild(&quot;ShareUnit&quot;);</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (shareUnitTag != null) {</span>
<span class="fc" id="L388">            shareUnit.set(shareUnitTag.getAttributeAsInteger(&quot;percentage&quot;, DEFAULT_SHARE_UNIT));</span>
<span class="fc" id="L389">            shareUnitsForSharePrice</span>
<span class="fc" id="L390">            = shareUnitTag.getAttributeAsInteger(&quot;sharePriceUnits&quot;, shareUnitsForSharePrice);</span>
        }

<span class="fc" id="L393">        Tag homeBaseTag = tag.getChild(&quot;Home&quot;);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (homeBaseTag != null) {</span>
<span class="fc" id="L395">            homeHexNames = homeBaseTag.getAttributeAsString(&quot;hex&quot;);</span>
<span class="fc" id="L396">            homeCityNumber = homeBaseTag.getAttributeAsInteger(&quot;city&quot;, 1);</span>
        }

<span class="fc" id="L399">        Tag destinationTag = tag.getChild(&quot;Destination&quot;);</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (destinationTag != null) {</span>
<span class="fc" id="L401">            destinationHexName = destinationTag.getAttributeAsString(&quot;hex&quot;);</span>
        }

<span class="fc" id="L404">        Tag privateBuyTag = tag.getChild(&quot;CanBuyPrivates&quot;);</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (privateBuyTag != null) {</span>
<span class="fc" id="L406">            canBuyPrivates = true;</span>
        }

<span class="fc" id="L409">        Tag canUseSpecTag = tag.getChild(&quot;CanUseSpecialProperties&quot;);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        if (canUseSpecTag != null) canUseSpecialProperties = true;</span>

        // Extra info text(usually related to extra-share special properties)
<span class="fc" id="L413">        Tag infoTag = tag.getChild(&quot;Info&quot;);</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if (infoTag != null) {</span>
<span class="nc" id="L415">            String infoKey = infoTag.getAttributeAsString(&quot;key&quot;);</span>
<span class="nc" id="L416">            String[] infoParms = infoTag.getAttributeAsString(&quot;parm&quot;, &quot;&quot;).split(&quot;,&quot;);</span>
<span class="nc" id="L417">            infoText += &quot;&lt;br&gt;&quot;+LocalText.getText(infoKey, (Object[])infoParms);</span>
        }

        // Special properties (as in the 1835 black minors)
<span class="fc" id="L421">        parentInfoText += SpecialProperty.configure(this, tag);</span>

<span class="fc bfc" id="L423" title="All 4 branches covered.">        poolPaysOut = poolPaysOut || tag.getChild(&quot;PoolPaysOut&quot;) != null;</span>

<span class="pc bpc" id="L425" title="2 of 4 branches missed.">        ipoPaysOut = ipoPaysOut || tag.getChild(&quot;IPOPaysOut&quot;) != null;</span>

<span class="fc" id="L427">        Tag floatTag = tag.getChild(&quot;Float&quot;);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (floatTag != null) {</span>
<span class="fc" id="L429">            floatPerc = floatTag.getAttributeAsInteger(&quot;percentage&quot;, floatPerc);</span>
<span class="fc" id="L430">            String sharePriceAttr = floatTag.getAttributeAsString(&quot;price&quot;);</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">            if (Util.hasValue(sharePriceAttr)) {</span>
<span class="fc" id="L432">                sharePriceUpOnFloating = sharePriceAttr.equalsIgnoreCase(&quot;up&quot;);</span>
            }
        }

<span class="fc" id="L436">        Tag priceTag = tag.getChild(&quot;StockPrice&quot;);</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">        if (priceTag != null) {</span>
<span class="fc" id="L438">            hasStockPrice = priceTag.getAttributeAsBoolean(&quot;market&quot;, true);</span>
<span class="fc" id="L439">            hasParPrice = priceTag.getAttributeAsBoolean(&quot;par&quot;, hasStockPrice);</span>
        }

<span class="fc" id="L442">        Tag payoutTag = tag.getChild(&quot;Payout&quot;);</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">        if (payoutTag != null) {</span>
<span class="fc" id="L444">            String split = payoutTag.getAttributeAsString(&quot;split&quot;, &quot;no&quot;);</span>
<span class="fc" id="L445">            splitAlways = split.equalsIgnoreCase(&quot;always&quot;);</span>
<span class="fc" id="L446">            splitAllowed = split.equalsIgnoreCase(&quot;allowed&quot;);</span>

<span class="fc" id="L448">            payoutMustExceedPriceToMove =</span>
<span class="fc" id="L449">                payoutTag.getAttributeAsBoolean(&quot;mustExceedPriceToMove&quot;,</span>
                        false);
        }

<span class="fc" id="L453">        Tag ownSharesTag = tag.getChild(&quot;TreasuryCanHoldOwnShares&quot;);</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        if (ownSharesTag != null) {</span>
<span class="fc" id="L455">            canHoldOwnShares = true;</span>
<span class="fc" id="L456">            treasuryPaysOut = true;</span>

<span class="fc" id="L458">            maxPercOfOwnShares =</span>
<span class="fc" id="L459">                ownSharesTag.getAttributeAsInteger(&quot;maxPerc&quot;,</span>
                        maxPercOfOwnShares);
        }

<span class="fc" id="L463">        Tag trainsTag = tag.getChild(&quot;Trains&quot;);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">        if (trainsTag != null) {</span>
<span class="fc" id="L465">            trainLimit = trainsTag.getAttributeAsIntegerList(&quot;limit&quot;);</span>
<span class="fc" id="L466">            mustOwnATrain =</span>
<span class="fc" id="L467">                trainsTag.getAttributeAsBoolean(&quot;mandatory&quot;, mustOwnATrain);</span>
        }

<span class="fc" id="L470">        Tag initialTrainTag = tag.getChild(&quot;InitialTrain&quot;);</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">        if (initialTrainTag != null) {</span>
<span class="fc" id="L472">            initialTrainType = initialTrainTag.getAttributeAsString(&quot;type&quot;);</span>
<span class="fc" id="L473">            initialTrainCost = initialTrainTag.getAttributeAsInteger(&quot;cost&quot;,</span>
                    initialTrainCost);
<span class="fc" id="L475">            initialTrainTradeable = initialTrainTag.getAttributeAsBoolean(&quot;tradeable&quot;,</span>
                    initialTrainTradeable);
        }

<span class="fc" id="L479">        Tag firstTrainTag = tag.getChild(&quot;FirstTrainCloses&quot;);</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">        if (firstTrainTag != null) {</span>
<span class="fc" id="L481">            String typeName =</span>
<span class="fc" id="L482">                firstTrainTag.getAttributeAsString(&quot;type&quot;, &quot;Private&quot;);</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">            if (typeName.equalsIgnoreCase(&quot;Private&quot;)) {</span>
<span class="fc" id="L484">                privateToCloseOnFirstTrainName =</span>
<span class="fc" id="L485">                    firstTrainTag.getAttributeAsString(&quot;name&quot;);</span>
            } else {
<span class="nc" id="L487">                throw new ConfigurationException(</span>
                &quot;Only Privates can be closed on first train buy&quot;);
            }
        }

<span class="fc" id="L492">        Tag capitalisationTag = tag.getChild(&quot;Capitalisation&quot;);</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (capitalisationTag != null) {</span>
<span class="fc" id="L494">            String capType =</span>
<span class="fc" id="L495">                capitalisationTag.getAttributeAsString(&quot;type&quot;, &quot;full&quot;);</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">            if (capType.equalsIgnoreCase(&quot;full&quot;)) {</span>
<span class="nc" id="L497">                setCapitalisation(CAPITALISE_FULL);</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">            } else if (capType.equalsIgnoreCase(&quot;incremental&quot;)) {</span>
<span class="fc" id="L499">                setCapitalisation(CAPITALISE_INCREMENTAL);</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">            } else if (capType.equalsIgnoreCase(&quot;whenBought&quot;)) {</span>
<span class="fc" id="L501">                setCapitalisation(CAPITALISE_WHEN_BOUGHT);</span>
            } else {
<span class="nc" id="L503">                throw new ConfigurationException(</span>
                        &quot;Invalid capitalisation type: &quot; + capType);
            }
        }


        // TODO: Check if this still works correctly
        // The certificate init was moved to the finishConfig phase
        // as PublicCompany is configured twice
<span class="fc" id="L512">        List&lt;Tag&gt; certTags = tag.getChildren(&quot;Certificate&quot;);</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">        if (certTags != null) certificateTags = certTags;</span>

        // BaseToken
<span class="fc" id="L516">        Tag baseTokenTag = tag.getChild(&quot;BaseTokens&quot;);</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">        if (baseTokenTag != null) {</span>

            // Cost of laying a token
<span class="fc" id="L520">            Tag layCostTag = baseTokenTag.getChild(&quot;LayCost&quot;);</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">            if (layCostTag != null) {</span>
<span class="fc" id="L522">                baseTokenLayCostMethod =</span>
<span class="fc" id="L523">                    layCostTag.getAttributeAsString(&quot;method&quot;,</span>
                            baseTokenLayCostMethod);
<span class="fc bfc" id="L525" title="All 2 branches covered.">                if (baseTokenLayCostMethod.equalsIgnoreCase(BASE_COST_SEQUENCE)) {</span>
<span class="fc" id="L526">                    baseTokenLayCostMethod = BASE_COST_SEQUENCE;</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">                } else if (baseTokenLayCostMethod.equalsIgnoreCase(BASE_COST_DISTANCE)) {</span>
<span class="fc" id="L528">                    baseTokenLayCostMethod = BASE_COST_DISTANCE;</span>
                } else {
<span class="nc" id="L530">                    throw new ConfigurationException(</span>
                            &quot;Invalid base token lay cost calculation method: &quot;
                            + baseTokenLayCostMethod);
                }

<span class="fc" id="L535">                baseTokenLayCost =</span>
<span class="fc" id="L536">                    layCostTag.getAttributeAsIntegerList(&quot;cost&quot;);</span>
            }

            /* Cost of buying a token (mutually exclusive with laying cost) */
<span class="fc" id="L540">            Tag buyCostTag = baseTokenTag.getChild(&quot;BuyCost&quot;);</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">            if (buyCostTag != null) {</span>
<span class="fc" id="L542">                baseTokensBuyCost =</span>
<span class="fc" id="L543">                    buyCostTag.getAttributeAsInteger(&quot;initialTokenCost&quot;, 0);</span>
            }

<span class="fc" id="L546">            Tag tokenLayTimeTag = baseTokenTag.getChild(&quot;HomeBase&quot;);</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">            if (tokenLayTimeTag != null) {</span>
                // When is the home base laid?
                // Note: if not before, home tokens are in any case laid
                // at the start of the first OR
<span class="fc" id="L551">                String layTimeString =</span>
<span class="fc" id="L552">                    tokenLayTimeTag.getAttributeAsString(&quot;lay&quot;);</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                if (Util.hasValue(layTimeString)) {</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">                    for (int i = 0; i &lt; tokenLayTimeNames.length; i++) {</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">                        if (tokenLayTimeNames[i].equalsIgnoreCase(layTimeString)) {</span>
<span class="fc" id="L556">                            homeBaseTokensLayTime = i;</span>
<span class="fc" id="L557">                            break;</span>
                        }
                    }
                }
            }
        }

<span class="fc" id="L564">        Tag sellSharesTag = tag.getChild(&quot;TradeShares&quot;);</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">        if (sellSharesTag != null) {</span>
<span class="fc" id="L566">            mayTradeShares = true;</span>
<span class="fc" id="L567">            mustHaveOperatedToTradeShares =</span>
<span class="fc" id="L568">                sellSharesTag.getAttributeAsBoolean(&quot;mustHaveOperated&quot;,</span>
                        mustHaveOperatedToTradeShares);
        }

<span class="fc" id="L572">        Tag loansTag = tag.getChild(&quot;Loans&quot;);</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">        if (loansTag != null) {</span>
<span class="fc" id="L574">            maxNumberOfLoans = loansTag.getAttributeAsInteger(&quot;number&quot;, -1);</span>
            // Note: -1 means undefined, to be handled in the code
            // (for instance: 1856).
<span class="fc" id="L577">            valuePerLoan = loansTag.getAttributeAsInteger(&quot;value&quot;, 0);</span>
<span class="fc" id="L578">            loanInterestPct = loansTag.getAttributeAsInteger(&quot;interest&quot;, 0);</span>
<span class="fc" id="L579">            maxLoansPerRound = loansTag.getAttributeAsInteger(&quot;perRound&quot;, -1);</span>
        }

<span class="fc" id="L582">        Tag optionsTag = tag.getChild(&quot;Options&quot;);</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">        if (optionsTag != null) {</span>
<span class="fc" id="L584">            mustTradeTrainsAtFixedPrice = optionsTag.getAttributeAsBoolean</span>
<span class="fc" id="L585">            (&quot;mustTradeTrainsAtFixedPrice&quot;, mustTradeTrainsAtFixedPrice);</span>
<span class="fc" id="L586">            canClose = optionsTag.getAttributeAsBoolean(&quot;canClose&quot;, canClose);</span>
        }

<span class="fc" id="L589">    }</span>


    public void setIndex (int index) {
<span class="fc" id="L593">        publicNumber = index;</span>
<span class="fc" id="L594">    }</span>

    /**
     * Final initialisation, after all XML has been processed.
     */
    public void finishConfiguration(RailsRoot root)
    throws ConfigurationException {

<span class="fc bfc" id="L602" title="All 2 branches covered.">        if (maxNumberOfLoans != 0) {</span>
<span class="fc" id="L603">            currentNumberOfLoans = IntegerState.create(this, &quot;currentNumberOfLoans&quot;);</span>
<span class="fc" id="L604">            currentLoanValue = CountingMoneyModel.create(this, &quot;currentLoanValue&quot;, false);</span>
<span class="fc" id="L605">            currentLoanValue.setSuppressZero(true);</span>
        }

<span class="fc bfc" id="L608" title="All 4 branches covered.">        if (hasStockPrice &amp;&amp; Util.hasValue(startSpace)) {</span>
<span class="fc" id="L609">            parPrice.setPrice(getRoot().getStockMarket().getStockSpace(</span>
                    startSpace));
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">            if (parPrice.getPrice() == null)</span>
<span class="nc" id="L612">                throw new ConfigurationException(&quot;Invalid start space &quot;</span>
                        + startSpace + &quot; for company &quot;
<span class="nc" id="L614">                        + getId());</span>
<span class="fc" id="L615">            currentPrice.setPrice(parPrice.getPrice());</span>

        }

<span class="fc" id="L619">        int certIndex = 0;</span>
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">        if (certificateTags != null) {</span>
<span class="fc" id="L621">            int shareTotal = 0;</span>
<span class="fc" id="L622">            boolean gotPresident = false;</span>
            PublicCertificate certificate;
            // Throw away
            // the per-type
            // specification

            // TODO: Move this to PublicCertificate class, as it belongs there
<span class="fc bfc" id="L629" title="All 2 branches covered.">            for (Tag certificateTag : certificateTags) {</span>
<span class="fc" id="L630">                int shares = certificateTag.getAttributeAsInteger(&quot;shares&quot;, 1);</span>

<span class="fc" id="L632">                boolean president =</span>
<span class="fc" id="L633">                    &quot;President&quot;.equals(certificateTag.getAttributeAsString(</span>
                            &quot;type&quot;, &quot;&quot;));
<span class="fc" id="L635">                int number = certificateTag.getAttributeAsInteger(&quot;number&quot;, 1);</span>

<span class="fc" id="L637">                boolean certIsInitiallyAvailable</span>
<span class="fc" id="L638">                = certificateTag.getAttributeAsBoolean(&quot;available&quot;,</span>
                        certsAreInitiallyAvailable);

<span class="fc" id="L641">                float certificateCount = certificateTag.getAttributeAsFloat(&quot;certificateCount&quot;, 1.0f);</span>

<span class="fc bfc" id="L643" title="All 2 branches covered.">                if (president) {</span>
<span class="pc bpc" id="L644" title="2 of 4 branches missed.">                    if (number &gt; 1 || gotPresident)</span>
<span class="nc" id="L645">                        throw new ConfigurationException(</span>
                                &quot;Company type &quot;
<span class="nc" id="L647">                                + getId()</span>
                                + &quot; cannot have multiple President shares&quot;);
<span class="fc" id="L649">                    gotPresident = true;</span>
                }

<span class="fc bfc" id="L652" title="All 2 branches covered.">                for (int k = 0; k &lt; number; k++) {</span>
<span class="fc" id="L653">                    certificate = new PublicCertificate(this, &quot;cert_&quot; + certIndex, shares, president,</span>
                            certIsInitiallyAvailable, certificateCount, certIndex++);
<span class="fc" id="L655">                    certificates.add(certificate);</span>
<span class="fc" id="L656">                    shareTotal += shares * shareUnit.value();</span>
                }
<span class="fc" id="L658">            }</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">            if (shareTotal != 100)</span>
<span class="nc" id="L660">                throw new ConfigurationException(&quot;Company type &quot; + getId()</span>
                        + &quot; total shares is not 100%&quot;);
        }

<span class="fc" id="L664">        nameCertificates();</span>

        // Give each certificate an unique Id
        PublicCertificate cert;
<span class="fc bfc" id="L668" title="All 2 branches covered.">        for (int i = 0; i &lt; certificates.size(); i++) {</span>
<span class="fc" id="L669">            cert = certificates.get(i);</span>
<span class="fc" id="L670">            cert.setUniqueId(getId(), i);</span>
<span class="pc bpc" id="L671" title="1 of 4 branches missed.">            cert.setInitiallyAvailable(cert.isInitiallyAvailable()</span>
                    &amp;&amp; this.certsAreInitiallyAvailable);
        }

<span class="fc" id="L675">        Set&lt;BaseToken&gt; newTokens = Sets.newHashSet();</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">        for (int i = 0; i &lt; numberOfBaseTokens; i++) {</span>
<span class="fc" id="L677">            BaseToken token =  BaseToken.create(this);</span>
<span class="fc" id="L678">            newTokens.add(token);</span>
        }
<span class="fc" id="L680">        baseTokens.initTokens(newTokens);</span>

<span class="fc bfc" id="L682" title="All 2 branches covered.">        if (homeHexNames != null) {</span>
<span class="fc" id="L683">            homeHexes = new ArrayList&lt;MapHex&gt;(2);</span>
            MapHex homeHex;
<span class="fc bfc" id="L685" title="All 2 branches covered.">            for (String homeHexName : homeHexNames.split(&quot;,&quot;)) {</span>
<span class="fc" id="L686">                homeHex = getRoot().getMapManager().getHex(homeHexName);</span>
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">                if (homeHex == null) {</span>
<span class="nc" id="L688">                    throw new ConfigurationException(&quot;Invalid home hex &quot;</span>
                            + homeHexName
<span class="nc" id="L690">                            + &quot; for company &quot; + getId());</span>
                }
<span class="fc" id="L692">                homeHexes.add (homeHex);</span>
<span class="fc" id="L693">                infoText += &quot;&lt;br&gt;Home: &quot; + homeHex.toText();</span>
            }
        }

<span class="fc bfc" id="L697" title="All 2 branches covered.">        if (destinationHexName != null) {</span>
<span class="fc" id="L698">            destinationHex = getRoot().getMapManager().getHex(destinationHexName);</span>
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">            if (destinationHex == null) {</span>
<span class="nc" id="L700">                throw new ConfigurationException(&quot;Invalid destination hex &quot;</span>
                        + destinationHexName
<span class="nc" id="L702">                        + &quot; for company &quot; + getId());</span>
            }
<span class="fc" id="L704">            infoText += &quot;&lt;br&gt;Destination: &quot;+destinationHex.toText();</span>
        }

<span class="fc bfc" id="L707" title="All 2 branches covered.">        if (Util.hasValue(privateToCloseOnFirstTrainName)) {</span>
<span class="fc" id="L708">            privateToCloseOnFirstTrain =</span>
<span class="fc" id="L709">                getRoot().getCompanyManager().getPrivateCompany(</span>
                        privateToCloseOnFirstTrainName);
        }

<span class="fc bfc" id="L713" title="All 2 branches covered.">        if (trainLimit != null) {</span>
<span class="fc" id="L714">            infoText += &quot;&lt;br&gt;&quot; + LocalText.getText(&quot;CompInfoMaxTrains&quot;,</span>
<span class="fc" id="L715">                    Util.joinWithDelimiter(trainLimit, &quot;, &quot;));</span>

        }

<span class="fc" id="L719">        infoText += parentInfoText;</span>
<span class="fc" id="L720">        parentInfoText = &quot;&quot;;</span>

        // Can companies acquire special rightsModel (such as in 1830 Coalfields)?
        // TODO: Can this be simplified?
<span class="fc bfc" id="L724" title="All 2 branches covered.">        if (portfolio.hasSpecialProperties()) {</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">            for (SpecialProperty sp : portfolio.getPersistentSpecialProperties()) {</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">                if (sp instanceof SpecialRight) {</span>
<span class="fc" id="L727">                    getRoot().getGameManager().setGuiParameter (GuiDef.Parm.HAS_ANY_RIGHTS, true);</span>
                    // Initialize rightsModel here to prevent overhead if not used,
                    // but if rightsModel are used, the GUI needs it from the start.
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">                    if (rightsModel == null) {</span>
<span class="fc" id="L731">                        rightsModel = RightsModel.create(this, &quot;rightsModel&quot;);</span>
                    }
                    // TODO: This is only a workaround for the missing finishConfiguration of special properties (SFY)
<span class="fc" id="L734">                    sp.finishConfiguration(root);</span>
                }
<span class="fc" id="L736">            }</span>
        }

        // finish Configuration of portfolio
<span class="fc" id="L740">        portfolio.finishConfiguration();</span>

        // set multipleCertificates
<span class="fc bfc" id="L743" title="All 2 branches covered.">        for (PublicCertificate c:certificates) {</span>
<span class="fc bfc" id="L744" title="All 4 branches covered.">            if (!c.isPresidentShare() &amp;&amp; c.getShares() != 1) {</span>
<span class="fc" id="L745">                hasMultipleCertificates = true;</span>
            }
<span class="fc" id="L747">        }</span>
<span class="fc" id="L748">    }</span>

    /** Used in finalizing configuration */
    public void addExtraTileLayTurnsInfo(String colour, int turns) {
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">        if (turnsWithExtraTileLays == null) {</span>
<span class="fc" id="L753">            turnsWithExtraTileLays = new HashMap&lt;String, IntegerState&gt;();</span>
        }
<span class="fc" id="L755">        IntegerState tileLays = IntegerState.create</span>
<span class="fc" id="L756">                (this, &quot;&quot; + colour + &quot;_ExtraTileTurns&quot;, turns);</span>
<span class="fc" id="L757">        turnsWithExtraTileLays.put(colour, tileLays);</span>
<span class="fc" id="L758">    }</span>

    /** Reset turn objects */
    public void initTurn() {

<span class="fc bfc" id="L763" title="All 2 branches covered.">        if (!hasLaidHomeBaseTokens()) layHomeBaseTokens();</span>

<span class="fc" id="L765">        privatesCostThisTurn.set(0);</span>
<span class="fc" id="L766">        tilesLaidThisTurn.set(&quot;&quot;);</span>
<span class="fc" id="L767">        tilesCostThisTurn.set(0);</span>
<span class="fc" id="L768">        tokensLaidThisTurn.set(&quot;&quot;);</span>
<span class="fc" id="L769">        tokensCostThisTurn.set(0);</span>
<span class="fc" id="L770">        trainsCostThisTurn.set(0);</span>
<span class="fc" id="L771">    }</span>

    /**
     * Return the company token background colour.
     *
     * @return Color object
     */
    public Color getBgColour() {
<span class="nc" id="L779">        return bgColour;</span>
    }

    /**
     * Return the company token background colour.
     *
     * @return Hexadecimal string RRGGBB.
     */
    public String getHexBgColour() {
<span class="nc" id="L788">        return bgHexColour;</span>
    }

    /**
     * Return the company token foreground colour.
     *
     * @return Color object.
     */
    public Color getFgColour() {
<span class="nc" id="L797">        return fgColour;</span>
    }

    /**
     * Return the company token foreground colour.
     *
     * @return Hexadecimal string RRGGBB.
     */
    public String getHexFgColour() {
<span class="nc" id="L806">        return fgHexColour;</span>
    }

    /**
     * Return the company's Home hexes (usually one).
     * @return Returns the homeHex.
     */
    public List&lt;MapHex&gt; getHomeHexes() {
<span class="fc" id="L814">        return homeHexes;</span>
    }

    /**
     * Set a non-fixed company home hex.
     * Only covers setting &lt;i&gt;one&lt;/i&gt; home hex.
     * Having &lt;i&gt;two&lt;/i&gt; home hexes is currently only supported if the locations are preconfigured.
     * @param homeHex The homeHex to set.
     */
    public void setHomeHex(MapHex homeHex) {
<span class="fc" id="L824">        homeHexes = new ArrayList&lt;MapHex&gt;(1);</span>
<span class="fc" id="L825">        homeHexes.add(homeHex);</span>
<span class="fc" id="L826">    }</span>

    /**
     * @return Returns the homeStation.
     */
    public int getHomeCityNumber() {
<span class="fc" id="L832">        return homeCityNumber;</span>
    }

    /**
     * @param homeStation The homeStation to set.
     */
    public void setHomeCityNumber(int number) {
<span class="fc" id="L839">        this.homeCityNumber = number;</span>
<span class="fc" id="L840">    }</span>

    /**
     * @return Returns the destinationHex.
     */
    public MapHex getDestinationHex() {
<span class="fc" id="L846">        return destinationHex;</span>
    }

    public boolean hasDestination () {
<span class="fc bfc" id="L850" title="All 2 branches covered.">        return destinationHex != null;</span>
    }

    public boolean hasReachedDestination() {
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">        return hasReachedDestination != null &amp;&amp;</span>
<span class="fc bfc" id="L855" title="All 2 branches covered.">        hasReachedDestination.value();</span>
    }

    public void setReachedDestination (boolean value) {
<span class="fc" id="L859">        hasReachedDestination.set(value);</span>
<span class="fc" id="L860">    }</span>

    /**
     * @return
     */
    public boolean canBuyStock() {
<span class="nc" id="L866">        return canBuyStock;</span>
    }

    public boolean mayTradeShares() {
<span class="fc" id="L870">        return mayTradeShares;</span>
    }

    /** Stub that allows exclusions such as that 1856 CGR may not buy a 4 */
    public boolean mayBuyTrainType (Train train) {
<span class="fc" id="L875">        return true;</span>
    }

    public boolean mustHaveOperatedToTradeShares() {
<span class="fc" id="L879">        return mustHaveOperatedToTradeShares;</span>
    }

    public void start(StockSpace startSpace) {

<span class="fc" id="L884">        hasStarted.set(true);</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">        if (hasStockPrice) buyable.set(true);</span>

        // In case of a restart: undo closing
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">        if (closed.value()) closed.set(false);</span>

<span class="fc bfc" id="L890" title="All 2 branches covered.">        if (startSpace != null) {</span>
<span class="fc" id="L891">            setParSpace(startSpace);</span>
<span class="fc" id="L892">            setCurrentSpace(startSpace);</span>

            // Drop the current price token, if allowed at this point
<span class="fc bfc" id="L895" title="All 2 branches covered.">            if (dropPriceToken == WHEN_STARTED) {</span>
<span class="fc" id="L896">                getRoot().getStockMarket().start(this, startSpace);</span>
            }
        }


<span class="fc bfc" id="L901" title="All 2 branches covered.">        if (homeBaseTokensLayTime == WHEN_STARTED) {</span>
<span class="fc" id="L902">            layHomeBaseTokens();</span>
        }
<span class="fc" id="L904">    }</span>

    public void start(int price) {
<span class="fc" id="L907">        StockSpace startSpace = getRoot().getStockMarket().getStartSpace(price);</span>
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">        if (startSpace == null) {</span>
<span class="nc" id="L909">            log.error(&quot;Invalid start price &quot; + Bank.format(this, price)); // TODO: Do this nicer</span>
        } else {
<span class="fc" id="L911">            start(startSpace);</span>
        }
<span class="fc" id="L913">    }</span>

    /**
     * Start a company.
     */
    public void start() {
<span class="fc" id="L919">        start (getStartSpace());</span>
<span class="fc" id="L920">    }</span>

    public void transferAssetsFrom(PublicCompany otherCompany) {

<span class="fc bfc" id="L924" title="All 2 branches covered.">        if (otherCompany.getCash() &gt; 0) {</span>
<span class="fc" id="L925">            Currency.wireAll(otherCompany, this);</span>
        }
<span class="fc" id="L927">        portfolio.transferAssetsFrom(otherCompany.getPortfolioModel());</span>
<span class="fc" id="L928">    }</span>

    /**
     * @return Returns true is the company has started.
     */
    public boolean hasStarted() {
<span class="fc" id="L934">        return hasStarted.value();</span>
    }

    /** Make company shares buyable. Only useful where shares become
     * buyable before the company has started (e.g. 1835 Prussian).
     * */
    public void setBuyable(boolean buyable) {
<span class="fc" id="L941">        this.buyable.set(buyable);</span>
<span class="fc" id="L942">    }</span>

    public boolean isBuyable() {
<span class="fc" id="L945">        return buyable.value();</span>
    }

    /**
     * Float the company, put its initial cash in the treasury.
     */
    public void setFloated() {

<span class="fc" id="L953">        hasFloated.set(true);</span>
        // In case of a restart
<span class="fc bfc" id="L955" title="All 2 branches covered.">        if (hasOperated.value()) hasOperated.set(false);</span>

        // Remove the &quot;unfloated&quot; indicator in GameStatus
        // FIXME: Is this still required?
        // getPresident().getPortfolioModel().getShareModel(this).update();

<span class="fc bfc" id="L961" title="All 2 branches covered.">        if (sharePriceUpOnFloating) {</span>
<span class="fc" id="L962">            getRoot().getStockMarket().moveUp(this);</span>
        }

        // Drop the current price token, if allowed at this point
<span class="fc bfc" id="L966" title="All 2 branches covered.">        if (dropPriceToken == WHEN_FLOATED) {</span>
<span class="fc" id="L967">            getRoot().getStockMarket().start(this, getCurrentSpace());</span>
        }

<span class="fc bfc" id="L970" title="All 2 branches covered.">        if (homeBaseTokensLayTime == WHEN_FLOATED) {</span>
<span class="fc" id="L971">            layHomeBaseTokens();</span>
        }

<span class="fc bfc" id="L974" title="All 2 branches covered.">        if (initialTrainType != null) {</span>
<span class="fc" id="L975">            TrainManager trainManager = getRoot().getTrainManager();</span>
<span class="fc" id="L976">            TrainCertificateType type = trainManager.getCertTypeByName(initialTrainType);</span>
<span class="fc" id="L977">            Train train = getRoot().getBank().getIpo().getPortfolioModel().getTrainOfType(type);</span>
<span class="fc" id="L978">            buyTrain(train, initialTrainCost);</span>
<span class="fc" id="L979">            train.setTradeable(initialTrainTradeable);</span>
<span class="fc" id="L980">            trainManager.checkTrainAvailability(train, getRoot().getBank().getIpo());</span>
        }
<span class="fc" id="L982">    }</span>

    /**
     * Has the company already floated?
     *
     * @return true if the company has floated.
     */
    public boolean hasFloated() {
<span class="fc" id="L990">        return hasFloated.value();</span>
    }

    public BooleanState getFloatedModel() {
<span class="fc" id="L994">        return hasFloated;</span>
    }

    /**
     * Has the company already operated?
     *
     * @return true if the company has operated.
     */
    public boolean hasOperated() {
<span class="fc" id="L1003">        return hasOperated.value();</span>
    }

    public void setOperated() {
<span class="fc" id="L1007">        hasOperated.set(true);</span>
<span class="fc" id="L1008">    }</span>

    /** Reinitialize a company, i.e. close it and make the shares available for a new company start.
     * IMplemented rules are now as in 18EU.
     * TODO Will see later if this is generic enough.
     *
     */
    protected void reinitialise () {
<span class="nc" id="L1016">        hasStarted.set(false);</span>
<span class="nc" id="L1017">        hasFloated.set(false);</span>
<span class="nc" id="L1018">        hasOperated.set(false);</span>
<span class="nc bnc" id="L1019" title="All 4 branches missed.">        if (parPrice != null &amp;&amp; fixedPrice &lt;= 0) parPrice.setPrice(null);</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">        if (currentPrice != null) currentPrice.setPrice(null);</span>
<span class="nc" id="L1021">    }</span>

    public BooleanState getInGameModel () {
<span class="nc" id="L1024">        return inGameState;</span>
    }

    public BooleanState getIsClosedModel () {
<span class="nc" id="L1028">        return closed;</span>
    }

    /**
     * Set the company par price. &lt;p&gt; &lt;i&gt;Note: this method should &lt;b&gt;not&lt;/b&gt; be
     * used to start a company!&lt;/i&gt; Use &lt;code&gt;&lt;b&gt;start()&lt;/b&gt;&lt;/code&gt; in
     * stead.
     *
     * @param spaceI
     */
    public void setParSpace(StockSpace space) {
<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">        if (hasStockPrice) {</span>
<span class="pc bpc" id="L1040" title="1 of 2 branches missed.">            if (space != null) {</span>
<span class="fc" id="L1041">                parPrice.setPrice(space);</span>
            }
        }
<span class="fc" id="L1044">    }</span>

    /**
     * Get the company par (initial) price.
     *
     * @return StockSpace object, which defines the company start position on
     * the stock chart.
     */
    public StockSpace getStartSpace() {
<span class="fc bfc" id="L1053" title="All 2 branches covered.">        if (hasParPrice) {</span>
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">            return parPrice != null ? parPrice.getPrice() : null;</span>
        } else {
<span class="fc bfc" id="L1056" title="All 2 branches covered.">            return currentPrice != null ? currentPrice.getPrice() : null;</span>
        }
    }

    public int getIPOPrice () {
<span class="fc bfc" id="L1061" title="All 2 branches covered.">        if (hasParPrice) {</span>
<span class="fc bfc" id="L1062" title="All 2 branches covered.">            if (getStartSpace() != null) {</span>
<span class="fc" id="L1063">                return getStartSpace().getPrice();</span>
            } else {
<span class="fc" id="L1065">                return 0;</span>
            }
        } else {
<span class="fc" id="L1068">            return getMarketPrice();</span>
        }
    }

    public int getMarketPrice () {
<span class="fc bfc" id="L1073" title="All 2 branches covered.">        if (getCurrentSpace() != null) {</span>
<span class="fc" id="L1074">            return getCurrentSpace().getPrice();</span>
        } else {
<span class="fc" id="L1076">            return 0;</span>
        }
    }

    /** Return the price per share at game end.
     * Normally, it is equal to the market price,
     * but in some games (e.g. 1856) deductions may apply.
     * @return
     */
    public int getGameEndPrice() {
<span class="fc" id="L1086">        return getMarketPrice()/getShareUnitsForSharePrice();</span>
    }

    /**
     * Set a new company price.
     *
     * @param price The StockSpace object that defines the new location on the
     * stock market.
     */
    public void setCurrentSpace(StockSpace price) {
<span class="fc bfc" id="L1096" title="All 4 branches covered.">        if (price != null &amp;&amp; price != getCurrentSpace()) {</span>
<span class="fc" id="L1097">            currentPrice.setPrice(price);</span>
        }
<span class="fc" id="L1099">    }</span>

    public PriceModel getCurrentPriceModel() {
<span class="fc" id="L1102">        return currentPrice;</span>
    }

    public PriceModel getParPriceModel() {
        // Temporary fix to satisfy GameStatus window. Should be removed there.
<span class="nc bnc" id="L1107" title="All 2 branches missed.">        if (parPrice == null) return currentPrice;</span>

<span class="nc" id="L1109">        return parPrice;</span>
    }

    /**
     * Get the current company share price.
     *
     * @return The StockSpace object that defines the current location on the
     * stock market.
     */
    public StockSpace getCurrentSpace() {
<span class="fc bfc" id="L1119" title="All 2 branches covered.">        return currentPrice != null ? currentPrice.getPrice() : null;</span>
    }

    // TODO: Compare StockMarket processMove methods and check what can replace the code below
//    public void updatePlayersWorth() {
//
//        Map&lt;Player, Boolean&gt; done = new HashMap&lt;Player, Boolean&gt;(8);
//        Player owner;
//        for (PublicCertificate cert : certificates.view()) {
//            if (cert.getPortfolio() instanceof PortfolioModel // FIXME: What kind of condition is this, was cert.getHolder()
//                    &amp;&amp; cert.getHolder().getOwner() instanceof Player) {
//                owner = (Player)cert.getHolder().getOwner();
//                if (!done.containsKey(owner)) {
//                    owner.updateWorth();
//                    done.put(owner, true);
//                }
//            }
//        }
//    }

    public PurseMoneyModel getPurseMoneyModel() {
<span class="nc" id="L1140">        return treasury;</span>
    }

    public String getFormattedCash() {
<span class="nc" id="L1144">        return treasury.toText();</span>
    }

    public Model getText() {
<span class="nc" id="L1148">        return treasury;</span>
    }

    /**
     * @return
     */
    public int getPublicNumber() {
<span class="nc" id="L1155">        return publicNumber;</span>
    }

    /**
     * Get a list of this company's certificates.
     *
     * @return ArrayList containing the certificates (item 0 is the President's
     * share).
     */
    public List&lt;PublicCertificate&gt; getCertificates() {
<span class="fc" id="L1165">        return certificates.view();</span>
    }

    /**
     * Backlink the certificates to this company,
     * and give each one a type getId().
     *
     */
    public void nameCertificates () {
<span class="fc bfc" id="L1174" title="All 2 branches covered.">        for (PublicCertificate cert : certificates.view()) {</span>
<span class="fc" id="L1175">            cert.setCompany(this);</span>
<span class="fc" id="L1176">        }</span>
<span class="fc" id="L1177">    }</span>

    /**
     * Get the percentage of shares that must be sold to float the company.
     *
     * @return The float percentage.
     */
    public int getFloatPercentage() {
<span class="fc" id="L1185">        return floatPerc;</span>
    }

    /** Determine sold percentage for floating purposes */
    public int getSoldPercentage() {
<span class="fc" id="L1190">        int soldPercentage = 0;</span>
<span class="fc bfc" id="L1191" title="All 2 branches covered.">        for (PublicCertificate cert : certificates.view()) {</span>
<span class="fc bfc" id="L1192" title="All 2 branches covered.">            if (certCountsAsSold(cert)) {</span>
<span class="fc" id="L1193">                soldPercentage += cert.getShare();</span>
            }
<span class="fc" id="L1195">        }</span>
<span class="fc" id="L1196">        return soldPercentage;</span>
    }

    /** Can be subclassed for games with special rules */
    protected boolean certCountsAsSold (PublicCertificate cert) {
<span class="fc" id="L1201">        Owner owner = cert.getOwner();</span>
<span class="fc bfc" id="L1202" title="All 4 branches covered.">        return owner instanceof Player || owner == getRoot().getBank().getPool();</span>
    }

    /**
     * Get the company President.
     *
     */
    // FIXME: This has to be redesigned
    // Relying on the ordering is not a good thing
    public Player getPresident() {
<span class="fc bfc" id="L1212" title="All 2 branches covered.">        if (hasStarted()) {</span>
<span class="fc" id="L1213">            Owner owner = certificates.get(0).getOwner();</span>
<span class="fc bfc" id="L1214" title="All 2 branches covered.">            if (owner instanceof Player) return (Player) owner;</span>
        }
<span class="fc" id="L1216">        return null;</span>
    }

    public PresidentModel getPresidentModel() {
<span class="nc" id="L1220">        return presidentModel;</span>
    }

    public PublicCertificate getPresidentsShare () {
<span class="fc" id="L1224">        return certificates.get(0);</span>
    }

    /**
     * Store the last revenue earned by this company.
     *
     * @param i The last revenue amount.
     */
    public void setLastRevenue(int i) {
<span class="fc" id="L1233">        lastRevenue.set(i);</span>
<span class="fc" id="L1234">    }</span>

    /**
     * Get the last revenue earned by this company.
     *
     * @return The last revenue amount.
     */
    public int getLastRevenue() {
<span class="fc" id="L1242">        return lastRevenue.value();</span>
    }

    public Model getLastRevenueModel() {
<span class="nc" id="L1246">        return lastRevenue;</span>
    }

    /** Last revenue allocation (payout, split, withhold) */
    public void setLastRevenueAllocation(int allocation) {
<span class="pc bpc" id="L1251" title="2 of 4 branches missed.">        if (allocation &gt;= 0 &amp;&amp; allocation &lt; SetDividend.NUM_OPTIONS) {</span>
<span class="fc" id="L1252">            lastRevenueAllocation.set(LocalText.getText(SetDividend.getAllocationNameKey(allocation)));</span>
        } else {
<span class="nc" id="L1254">            lastRevenueAllocation.set(&quot;&quot;);</span>
        }
<span class="fc" id="L1256">    }</span>

    public String getlastRevenueAllocationText() {
<span class="nc" id="L1259">        return lastRevenueAllocation.value();</span>
    }

    public StringState getLastRevenueAllocationModel() {
<span class="nc" id="L1263">        return lastRevenueAllocation;</span>
    }

    /**
     * Determine if the price token must be moved after a dividend payout.
     *
     * @param amount
     */
    public void payout(int amount) {

<span class="pc bpc" id="L1273" title="1 of 2 branches missed.">        if (amount == 0) return;</span>

        // Move the token
<span class="fc bfc" id="L1276" title="All 4 branches covered.">        if (hasStockPrice</span>
                &amp;&amp; (!payoutMustExceedPriceToMove
<span class="fc bfc" id="L1278" title="All 2 branches covered.">                        || amount &gt;= currentPrice.getPrice().getPrice())) {</span>
<span class="fc" id="L1279">            getRoot().getStockMarket().payOut(this);</span>
        }

<span class="fc" id="L1282">    }</span>

    public boolean paysOutToTreasury (PublicCertificate cert) {

<span class="fc" id="L1286">        Owner owner = cert.getOwner();</span>
<span class="pc bpc" id="L1287" title="1 of 4 branches missed.">        if (owner == getRoot().getBank().getIpo() &amp;&amp; ipoPaysOut</span>
<span class="fc bfc" id="L1288" title="All 4 branches covered.">                || owner == getRoot().getBank().getPool() &amp;&amp; poolPaysOut) {</span>
<span class="fc" id="L1289">            return true;</span>
        }
<span class="fc" id="L1291">        return false;</span>
    }

    /**
     * Determine if the price token must be moved after a withheld dividend.
     *
     * @param The revenue amount.
     */
    public void withhold(int amount) {
<span class="fc bfc" id="L1300" title="All 2 branches covered.">        if (hasStockPrice) getRoot().getStockMarket().withhold(this);</span>
<span class="fc" id="L1301">    }</span>

    /**
     * Is the company completely sold out? This method should return true only
     * if the share price should move up at the end of a stock round. Since 1851
     * (jan 2008) interpreted as: no share is owned either by the Bank or by the
     * company's own Treasury.
     *
     * @return true if the share price can move up.
     */
    public boolean isSoldOut() {
        Owner owner;

<span class="fc bfc" id="L1314" title="All 2 branches covered.">        for (PublicCertificate cert : certificates.view()) {</span>
<span class="fc" id="L1315">            owner = cert.getOwner();</span>
<span class="fc bfc" id="L1316" title="All 4 branches covered.">            if (owner instanceof BankPortfolio || owner == cert.getCompany()) {</span>
<span class="fc" id="L1317">                return false;</span>
            }
<span class="fc" id="L1319">        }</span>
<span class="fc" id="L1320">        return true;</span>
    }

    /**
     * @return
     */
    public boolean canBuyPrivates() {
<span class="fc" id="L1327">        return canBuyPrivates;</span>
    }

    public boolean canUseSpecialProperties() {
<span class="fc" id="L1331">        return canUseSpecialProperties;</span>
    }

    /**
     * Get the unit of share.
     *
     * @return The percentage of ownership that is called &quot;one share&quot;.
     */
    public int getShareUnit() {
<span class="fc" id="L1340">        return shareUnit.value();</span>
    }

    public int getShareUnitsForSharePrice() {
<span class="fc" id="L1344">        return shareUnitsForSharePrice;</span>
    }

    /** @reeturn true if company has Multiple certificates, representing more than one nominal share unit (except president share)
     */
    public boolean hasMultipleCertificates() {
<span class="fc" id="L1350">        return hasMultipleCertificates;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L1355">        return getId();</span>
    }

    public boolean hasStockPrice() {
<span class="fc" id="L1359">        return hasStockPrice;</span>
    }

    public boolean hasParPrice() {
<span class="fc" id="L1363">        return hasParPrice;</span>
    }

    public boolean canSharePriceVary() {
<span class="fc" id="L1367">        return canSharePriceVary.value();</span>
    }

    public int getFixedPrice() {
<span class="fc" id="L1371">        return fixedPrice;</span>
    }

    public int getBaseTokensBuyCost() {
<span class="fc" id="L1375">        return baseTokensBuyCost;</span>
    }

    public int sharesOwnedByPlayers() {
<span class="fc" id="L1379">        int shares = 0;</span>
<span class="fc bfc" id="L1380" title="All 2 branches covered.">        for (PublicCertificate cert : certificates.view()) {</span>
<span class="fc bfc" id="L1381" title="All 2 branches covered.">            if (cert.getOwner() instanceof Player) {</span>
<span class="fc" id="L1382">                shares += cert.getShares();</span>
            }
<span class="fc" id="L1384">        }</span>
<span class="fc" id="L1385">        return shares;</span>
    }

    public boolean canHoldOwnShares() {
<span class="fc" id="L1389">        return canHoldOwnShares;</span>
    }

    /**
     * @return Returns the splitAllowed.
     */
    public boolean isSplitAllowed() {
<span class="fc" id="L1396">        return splitAllowed;</span>
    }

    /**
     * @return Returns the splitAlways.
     */
    public boolean isSplitAlways() {
<span class="fc" id="L1403">        return splitAlways;</span>
    }

    /**
     * Check if the presidency has changed for a &lt;b&gt;buying&lt;/b&gt; player.
     *
     * @param buyer Player who has just bought a certificate.
     */
    public void checkPresidencyOnBuy(Player buyer) {

<span class="pc bpc" id="L1413" title="1 of 6 branches missed.">        if (!hasStarted() || buyer == getPresident() || certificates.size() &lt; 2)</span>
<span class="fc" id="L1414">            return;</span>
<span class="fc" id="L1415">        Player pres = getPresident();</span>
<span class="fc" id="L1416">        int presShare = pres.getPortfolioModel().getShare(this);</span>
<span class="fc" id="L1417">        int buyerShare = buyer.getPortfolioModel().getShare(this);</span>
<span class="fc bfc" id="L1418" title="All 2 branches covered.">        if (buyerShare &gt; presShare) {</span>
<span class="fc" id="L1419">            pres.getPortfolioModel().swapPresidentCertificate(this,</span>
<span class="fc" id="L1420">                    buyer.getPortfolioModel(), 0);</span>
<span class="fc" id="L1421">            ReportBuffer.add(this, LocalText.getText(&quot;IS_NOW_PRES_OF&quot;,</span>
<span class="fc" id="L1422">                    buyer.getId(),</span>
<span class="fc" id="L1423">                    getId() ));</span>
        }
<span class="fc" id="L1425">    }</span>

    public void checkPresidency () {

        // check if there is a new potential president
<span class="fc" id="L1430">        int presidentShareNumber = getPresident().getPortfolioModel().getShareNumber(this) + 1;</span>
<span class="fc" id="L1431">        Player nextPotentialPresident = findNextPotentialPresident(presidentShareNumber);</span>

        // no change, return
<span class="fc bfc" id="L1434" title="All 2 branches covered.">        if (nextPotentialPresident == null) {</span>
<span class="fc" id="L1435">            return;</span>
        }

        // otherwise Hand presidency to the player with the highest share
<span class="fc" id="L1439">        getPresident().getPortfolioModel().swapPresidentCertificate(this, nextPotentialPresident.getPortfolioModel(), 2);</span>
<span class="fc" id="L1440">        ReportBuffer.add(this, LocalText.getText(&quot;IS_NOW_PRES_OF&quot;,</span>
<span class="fc" id="L1441">                nextPotentialPresident.getId(),</span>
<span class="fc" id="L1442">                getId() ));</span>
<span class="fc" id="L1443">    }</span>

    public Player findPlayerToDump() {
<span class="fc" id="L1446">        return findNextPotentialPresident(getPresidentsShare().getShares());</span>
    }

    public Player findNextPotentialPresident(int minimumShareNumber) {

<span class="fc" id="L1451">        int requiredShareNumber = minimumShareNumber;</span>
<span class="fc" id="L1452">        Player potentialDirector = null;</span>

<span class="fc bfc" id="L1454" title="All 2 branches covered.">        for (Player nextPlayer:getRoot().getPlayerManager().getNextPlayersAfter(getPresident(), false, false)) {</span>
<span class="fc" id="L1455">            int nextPlayerShareNumber =nextPlayer.getPortfolioModel().getShareNumber(this);</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">            if (nextPlayerShareNumber &gt;= requiredShareNumber) {</span>
<span class="fc" id="L1457">                potentialDirector = nextPlayer;</span>
<span class="fc" id="L1458">                requiredShareNumber = nextPlayerShareNumber + 1;</span>
            }
<span class="fc" id="L1460">        }</span>
<span class="fc" id="L1461">        return potentialDirector;</span>
    }

    /**
     * @return Returns the capitalisation.
     */
    public int getCapitalisation() {
<span class="fc" id="L1468">        return capitalisation;</span>
    }

    /**
     * @param capitalisation The capitalisation to set.
     */
    public void setCapitalisation(int capitalisation) {
<span class="fc" id="L1475">        log.debug(&quot;Capitalisation=&quot; + capitalisation);</span>
<span class="fc" id="L1476">        this.capitalisation = capitalisation;</span>
<span class="fc" id="L1477">    }</span>

    public int getNumberOfShares() {
<span class="fc" id="L1480">        return 100 / shareUnit.value();</span>
    }

    /** Get the current maximum number of trains got a given limit index.
     * @parm index The index of the train limit step as defined for the current phase. Values start at 0.
     * &lt;p&gt;N.B. the new style limit steps per phase start at 1,
     * so one must be subtracted before calling this method.
     */
    protected int getTrainLimit(int index) {
<span class="fc" id="L1489">        return trainLimit.get(Math.min(index, trainLimit.size() - 1));</span>
    }

    public int getCurrentTrainLimit() {
<span class="fc" id="L1493">        return getTrainLimit(getRoot().getGameManager().getCurrentPhase().getTrainLimitIndex());</span>
    }

    public int getNumberOfTrains() {
<span class="fc" id="L1497">        return portfolio.getNumberOfTrains();</span>
    }

    public boolean canRunTrains() {
<span class="fc bfc" id="L1501" title="All 2 branches covered.">        return portfolio.getNumberOfTrains() &gt; 0;</span>
    }

    /**
     * Must be called in stead of Portfolio.buyTrain if side-effects can occur.
     */
    public void buyTrain(Train train, int price) {

        // check first if it is bought from another company
<span class="fc bfc" id="L1510" title="All 2 branches covered.">        if (train.getOwner() instanceof PublicCompany) {</span>
<span class="fc" id="L1511">            PublicCompany previousOwner = (PublicCompany)train.getOwner();</span>
            //  adjust the money spent on trains field
<span class="fc" id="L1513">            previousOwner.getTrainsSpentThisTurnModel().change(-price);</span>
            // pay the money to the other company
<span class="fc" id="L1515">            Currency.wire(this, price, previousOwner);</span>
<span class="fc" id="L1516">        } else { // TODO: make this a serious test, no assumption</span>
            // else it is from the bank
<span class="fc" id="L1518">            Currency.toBank(this, price);</span>
        }

        // increase own train costs
<span class="fc" id="L1522">        trainsCostThisTurn.change(price);</span>
        // move the train to here
<span class="fc" id="L1524">        portfolio.getTrainsModel().getPortfolio().add(train);</span>
        // check if a private has to be closed on first train buy
<span class="fc bfc" id="L1526" title="All 2 branches covered.">        if (privateToCloseOnFirstTrain != null</span>
<span class="fc bfc" id="L1527" title="All 2 branches covered.">                &amp;&amp; !privateToCloseOnFirstTrain.isClosed()) {</span>
<span class="fc" id="L1528">            privateToCloseOnFirstTrain.setClosed();</span>
        }
<span class="fc" id="L1530">    }</span>

    public CountingMoneyModel getTrainsSpentThisTurnModel() {
<span class="fc" id="L1533">        return trainsCostThisTurn;</span>
    }

    public void buyPrivate(PrivateCompany privateCompany, Owner from,
            int price) {

<span class="pc bpc" id="L1539" title="1 of 2 branches missed.">        if (from != getRoot().getBank().getIpo()) {</span>
            // The initial buy is reported from StartRound. This message should also
            // move to elsewhere.
<span class="fc" id="L1542">            ReportBuffer.add(this, LocalText.getText(&quot;BuysPrivateFromFor&quot;,</span>
<span class="fc" id="L1543">                    getId(),</span>
<span class="fc" id="L1544">                    privateCompany.getId(),</span>
<span class="fc" id="L1545">                    from.getId(),</span>
<span class="fc" id="L1546">                    Bank.format(this, price) ));</span>
        }

        // Move the private certificate
<span class="fc" id="L1550">        portfolio.getPrivatesOwnedModel().getPortfolio().add(privateCompany);</span>

        // Move the money
<span class="pc bpc" id="L1553" title="1 of 2 branches missed.">        if (price &gt; 0) {</span>
<span class="fc" id="L1554">            Currency.wire(this, price, (MoneyOwner)from); // TODO: Remove the cast</span>
        }
<span class="fc" id="L1556">        privatesCostThisTurn.change(price);</span>

        // Move any special abilities to the portfolio, if configured so
<span class="fc" id="L1559">        Set&lt;SpecialProperty&gt; sps = privateCompany.getSpecialProperties();</span>
<span class="pc bpc" id="L1560" title="1 of 2 branches missed.">        if (sps != null) {</span>
            // Need intermediate List to avoid ConcurrentModificationException
<span class="fc" id="L1562">            List&lt;SpecialProperty&gt; spsToMoveHere =</span>
                new ArrayList&lt;SpecialProperty&gt;(2);
<span class="fc" id="L1564">            List&lt;SpecialProperty&gt; spsToMoveToGM =</span>
                new ArrayList&lt;SpecialProperty&gt;(2);
<span class="fc bfc" id="L1566" title="All 2 branches covered.">            for (SpecialProperty sp : sps) {</span>
<span class="fc bfc" id="L1567" title="All 2 branches covered.">                if (sp.getTransferText().equalsIgnoreCase(&quot;toCompany&quot;)) {</span>
<span class="fc" id="L1568">                    spsToMoveHere.add(sp);</span>
<span class="fc bfc" id="L1569" title="All 2 branches covered.">                } else if (sp.getTransferText().equalsIgnoreCase(&quot;toGameManager&quot;)) {</span>
                    // This must be SellBonusToken - remember the owner!
<span class="pc bpc" id="L1571" title="1 of 2 branches missed.">                    if (sp instanceof SellBonusToken) {</span>
                        // TODO: Check if this works correctly
<span class="fc" id="L1573">                        ((SellBonusToken)sp).setSeller(this);</span>
                        // Also note 1 has been used
<span class="fc" id="L1575">                        ((SellBonusToken)sp).setExercised();</span>
                    }
<span class="fc" id="L1577">                    spsToMoveToGM.add(sp);</span>
                }
<span class="fc" id="L1579">            }</span>
<span class="fc bfc" id="L1580" title="All 2 branches covered.">            for (SpecialProperty sp : spsToMoveHere) {</span>
<span class="fc" id="L1581">                sp.moveTo(portfolio.getParent());</span>
<span class="fc" id="L1582">            }</span>
<span class="fc bfc" id="L1583" title="All 2 branches covered.">            for (SpecialProperty sp : spsToMoveToGM) {</span>
<span class="fc" id="L1584">                getRoot().getGameManager().addSpecialProperty(sp);</span>
<span class="fc" id="L1585">                log.debug(&quot;SP &quot;+sp.getId()+&quot; is now a common property&quot;);</span>
<span class="fc" id="L1586">            }</span>
        }

<span class="fc" id="L1589">    }</span>

    public Model getPrivatesSpentThisTurnModel() {
<span class="nc" id="L1592">        return privatesCostThisTurn;</span>
    }

    public void layTile(MapHex hex, Tile tile, int orientation, int cost) {

<span class="fc" id="L1597">        String tileLaid =</span>
<span class="fc" id="L1598">            &quot;#&quot; + tile.toText() + &quot;/&quot; + hex.getId() + &quot;/&quot;</span>
<span class="fc" id="L1599">            + hex.getOrientationName(orientation);</span>
<span class="fc" id="L1600">        tilesLaidThisTurn.append(tileLaid, &quot;, &quot;);</span>

<span class="fc bfc" id="L1602" title="All 2 branches covered.">        if (cost &gt; 0) tilesCostThisTurn.change(cost);</span>

<span class="fc" id="L1604">    }</span>

    public void layTilenNoMapMode(int cost) {
<span class="nc bnc" id="L1607" title="All 2 branches missed.">        if (cost &gt; 0) tilesCostThisTurn.change(cost);</span>
<span class="nc" id="L1608">        tilesLaidThisTurn.append(Bank.format(this, cost), &quot;,&quot;);</span>
<span class="nc" id="L1609">    }</span>

    public StringState getTilesLaidThisTurnModel() {
<span class="nc" id="L1612">        return tilesLaidThisTurn;</span>
    }

    public Model getTilesCostThisTurnModel() {
<span class="nc" id="L1616">        return tilesCostThisTurn;</span>
    }

    public void layBaseToken(MapHex hex, int cost) {

<span class="fc" id="L1621">        String tokenLaid = hex.getId();</span>
<span class="fc" id="L1622">        tokensLaidThisTurn.append(tokenLaid, &quot;, &quot;);</span>
<span class="fc bfc" id="L1623" title="All 2 branches covered.">        if (cost &gt; 0) tokensCostThisTurn.change(cost);</span>
<span class="fc" id="L1624">    }</span>

    public void layBaseTokennNoMapMode(int cost) {
<span class="nc bnc" id="L1627" title="All 2 branches missed.">        if (cost &gt; 0) tokensCostThisTurn.change(cost);</span>
<span class="nc" id="L1628">        tokensLaidThisTurn.append(Bank.format(this, cost), &quot;,&quot;);</span>
<span class="nc" id="L1629">    }</span>

    /**
     * Calculate the cost of laying a token, given the hex where
     * the token is laid. This only makes a difference for de &quot;distance&quot; method.
     * @param hex The hex where the token is to be laid.
     * @return The cost of laying that token.
     */
    public int getBaseTokenLayCost(MapHex hex) {

<span class="fc bfc" id="L1639" title="All 2 branches covered.">        if (baseTokenLayCost == null) return 0;</span>

<span class="fc bfc" id="L1641" title="All 2 branches covered.">        if (baseTokenLayCostMethod.equals(BASE_COST_SEQUENCE)) {</span>
<span class="fc" id="L1642">            int index = getNumberOfLaidBaseTokens();</span>

<span class="fc bfc" id="L1644" title="All 2 branches covered.">            if (index &gt;= baseTokenLayCost.size()) {</span>
<span class="fc" id="L1645">                index = baseTokenLayCost.size() - 1;</span>
<span class="pc bpc" id="L1646" title="1 of 2 branches missed.">            } else if (index &lt; 0) {</span>
<span class="nc" id="L1647">                index = 0;</span>
            }
<span class="fc" id="L1649">            return baseTokenLayCost.get(index);</span>
<span class="pc bpc" id="L1650" title="1 of 2 branches missed.">        } else if (baseTokenLayCostMethod.equals(BASE_COST_DISTANCE)) {</span>
<span class="pc bpc" id="L1651" title="1 of 2 branches missed.">            if (hex == null) {</span>
<span class="nc" id="L1652">                return baseTokenLayCost.get(0);</span>
            } else {
                // WARNING: no provision yet for multiple home hexes.
<span class="fc" id="L1655">                return getRoot().getMapManager().getHexDistance(homeHexes.get(0), hex) * baseTokenLayCost.get(0);</span>
            }
        } else {
<span class="nc" id="L1658">            return 0;</span>
        }
    }

    /** Return all possible token lay costs to be incurred for the
     * company's next token lay. For the distance method it will be a full list
     */
    public Set&lt;Integer&gt; getBaseTokenLayCosts () {

<span class="nc bnc" id="L1667" title="All 2 branches missed.">        if (baseTokenLayCostMethod.equals(BASE_COST_SEQUENCE)) {</span>
<span class="nc" id="L1668">            return ImmutableSet.of(getBaseTokenLayCost(null));</span>
<span class="nc bnc" id="L1669" title="All 2 branches missed.">        } else if (baseTokenLayCostMethod.equals(BASE_COST_DISTANCE)) {</span>
            // WARNING: no provision yet for multiple home hexes.
<span class="nc" id="L1671">            Collection&lt;Integer&gt; distances = getRoot().getMapManager().getCityDistances(homeHexes.get(0));</span>
<span class="nc" id="L1672">            ImmutableSet.Builder&lt;Integer&gt; costs = ImmutableSet.builder();</span>
<span class="nc bnc" id="L1673" title="All 2 branches missed.">            for (int distance : distances) {</span>
<span class="nc" id="L1674">                costs.add(distance * baseTokenLayCost.get(0));</span>
<span class="nc" id="L1675">            }</span>
<span class="nc" id="L1676">            return costs.build();</span>
        } else {
<span class="nc" id="L1678">            return ImmutableSet.of(0);</span>
        }

    }

    public StringState getTokensLaidThisTurnModel() {
<span class="nc" id="L1684">        return tokensLaidThisTurn;</span>
    }

    public MoneyModel getTokensCostThisTurnModel() {
<span class="nc" id="L1688">        return tokensCostThisTurn;</span>
    }

    public BaseTokensModel getBaseTokensModel() {
<span class="nc" id="L1692">        return baseTokens;</span>
    }

    public boolean addBonus(Bonus bonus) {
<span class="fc" id="L1696">        bonuses.add(bonus);</span>
<span class="fc" id="L1697">        return true;</span>
    }

    public boolean removeBonus(Bonus bonus) {
<span class="fc" id="L1701">        bonus.close(); // close the bonus</span>
        // TODO: add bonusValue as dependence to bonuses
<span class="fc" id="L1703">        bonuses.remove(bonus);</span>
<span class="fc" id="L1704">        return true;</span>
    }

    public boolean removeBonus (String name) {
<span class="pc bpc" id="L1708" title="2 of 4 branches missed.">        if (bonuses != null &amp;&amp; !bonuses.isEmpty()) {</span>
<span class="pc bpc" id="L1709" title="1 of 2 branches missed.">            for(Bonus bonus : bonuses.view()) {</span>
<span class="pc bpc" id="L1710" title="1 of 2 branches missed.">                if (bonus.getName().equals(name)) return removeBonus(bonus);</span>
<span class="nc" id="L1711">            }</span>
        }
<span class="nc" id="L1713">        return false;</span>
    }

    public List&lt;Bonus&gt; getBonuses() {
<span class="fc" id="L1717">        return bonuses.view();</span>
    }

    public BonusModel getBonusTokensModel() {
<span class="nc" id="L1721">        return bonusValue;</span>
    }

    public boolean hasLaidHomeBaseTokens() {
<span class="fc bfc" id="L1725" title="All 2 branches covered.">        return baseTokens.nbLaidTokens() &gt; 0;</span>
    }

    // Return value is not used
    public boolean layHomeBaseTokens() {

<span class="fc bfc" id="L1731" title="All 2 branches covered.">        if (hasLaidHomeBaseTokens()) return true;</span>

<span class="fc bfc" id="L1733" title="All 2 branches covered.">        for (MapHex homeHex : homeHexes) {</span>
<span class="fc bfc" id="L1734" title="All 2 branches covered.">            if (homeCityNumber == 0) {</span>
                // This applies to cases like 1830 Erie and 1856 THB.
                // On a trackless tile it does not matter, but if
                // the tile has track (such as the green OO tile),
                // the player must select a city.
<span class="fc bfc" id="L1739" title="All 2 branches covered.">                if (homeHex.getCurrentTile().hasNoStationTracks()) {</span>
                    // No tracks, then it doesn't matter
<span class="fc" id="L1741">                    homeCityNumber = 1;</span>
                } else {
                    // Cover the case that there already is another token.
                    // Allowing this is optional for 1856 Hamilton (THB home)
<span class="fc" id="L1745">                    Set&lt;Stop&gt; stops = homeHex.getStops();</span>
<span class="fc" id="L1746">                    List&lt;Stop&gt; openStops = new ArrayList&lt;Stop&gt;();</span>
<span class="fc bfc" id="L1747" title="All 2 branches covered.">                    for (Stop stop : stops) {</span>
<span class="pc bpc" id="L1748" title="1 of 2 branches missed.">                        if (stop.hasTokenSlotsLeft()) openStops.add (stop);</span>
<span class="fc" id="L1749">                    }</span>
<span class="pc bpc" id="L1750" title="1 of 2 branches missed.">                    if (openStops.size() == 1) {</span>
                        // Just one spot: lay the home base there.
<span class="nc" id="L1752">                        homeCityNumber = openStops.get(0).getRelatedNumber();</span>
                    } else {
                        // ??
                        // TODO Will player be asked??
<span class="fc" id="L1756">                        return false;</span>
                    }
                }
            }
<span class="fc" id="L1760">            log.debug(getId() + &quot; lays home base on &quot; + homeHex.getId() + &quot; city &quot;</span>
                    + homeCityNumber);
<span class="fc" id="L1762">            homeHex.layBaseToken(this, homeHex.getRelatedStop(homeCityNumber));</span>
<span class="fc" id="L1763">        }</span>
<span class="fc" id="L1764">        return true;</span>
    }

    /**
     * @return the next (free) token to lay, null if none is available
     */
    public BaseToken getNextBaseToken() {
<span class="fc" id="L1771">        return baseTokens.getNextToken();</span>
    }

    public ImmutableSet&lt;BaseToken&gt; getAllBaseTokens() {
<span class="fc" id="L1775">        return baseTokens.getAllTokens();</span>
    }

    public ImmutableSet&lt;BaseToken&gt; getLaidBaseTokens() {
<span class="fc" id="L1779">        return baseTokens.getLaidTokens();</span>
    }

    public int getNumberOfBaseTokens() {
<span class="fc" id="L1783">        return baseTokens.nbAllTokens();</span>
    }

    public int getNumberOfFreeBaseTokens() {
<span class="fc" id="L1787">        return baseTokens.nbFreeTokens();</span>
    }

    public int getNumberOfLaidBaseTokens() {
<span class="fc" id="L1791">        return baseTokens.nbLaidTokens();</span>
    }

    public boolean hasBaseTokens() {
<span class="nc bnc" id="L1795" title="All 2 branches missed.">        return (baseTokens.nbAllTokens() &gt; 0);</span>
    }

    public int getNumberOfTileLays(String tileColour) {

<span class="fc" id="L1800">        Phase phase = getRoot().getPhaseManager().getCurrentPhase();</span>

        // Get the number of tile lays from Phase
<span class="fc" id="L1803">        int tileLays = phase.getTileLaysPerColour(getType().getId(), tileColour);</span>

        // standard cases: 0 and 1, return
<span class="fc bfc" id="L1806" title="All 2 branches covered.">        if (tileLays &lt;= 1) return tileLays;</span>

        // More than one tile lay allowed.
        // Check if there is a limitation on the number of turns that this is valid.
<span class="fc bfc" id="L1810" title="All 2 branches covered.">        if (turnsWithExtraTileLays != null) {</span>
<span class="fc" id="L1811">            extraTiles.set(turnsWithExtraTileLays.get(tileColour));</span>
        }

        // check if extraTiles is defined
<span class="fc bfc" id="L1815" title="All 2 branches covered.">        if (extraTiles.value() != null) {</span>
            // the value is zero already, thus no extra tiles
<span class="fc bfc" id="L1817" title="All 2 branches covered.">            if (extraTiles.value().value() == 0) {</span>
<span class="fc" id="L1818">                return 1;</span>
            } else {
                // reduce the number of turns by one
<span class="fc" id="L1821">                extraTiles.value().add(-1);</span>
            }
        }
<span class="fc" id="L1824">        return tileLays;</span>
    }

    public boolean mustOwnATrain() {
<span class="fc" id="L1828">        return mustOwnATrain;</span>
    }

    public boolean mustTradeTrainsAtFixedPrice() {
<span class="fc" id="L1832">        return mustTradeTrainsAtFixedPrice;</span>
    }

    public int getCurrentNumberOfLoans() {
<span class="fc" id="L1836">        return currentNumberOfLoans.value();</span>
    }

    public int getCurrentLoanValue () {
<span class="nc" id="L1840">        return getCurrentNumberOfLoans() * getValuePerLoan();</span>
    }

    public void addLoans(int number) {
<span class="fc" id="L1844">        currentNumberOfLoans.add(number);</span>
<span class="fc" id="L1845">        currentLoanValue.change(number * getValuePerLoan());</span>
<span class="fc" id="L1846">    }</span>

    public int getLoanInterestPct() {
<span class="fc" id="L1849">        return loanInterestPct;</span>
    }

    public int getMaxNumberOfLoans() {
<span class="fc" id="L1853">        return maxNumberOfLoans;</span>
    }

    public boolean canLoan() {
<span class="fc bfc" id="L1857" title="All 2 branches covered.">        return maxNumberOfLoans != 0;</span>
    }

    public int getMaxLoansPerRound() {
<span class="fc" id="L1861">        return maxLoansPerRound;</span>
    }

    public int getValuePerLoan() {
<span class="fc" id="L1865">        return valuePerLoan;</span>
    }

    public MoneyModel getLoanValueModel () {
<span class="fc" id="L1869">        return currentLoanValue;</span>
    }

    public Observable getRightsModel () {
<span class="nc" id="L1873">        return rightsModel;</span>
    }

    public boolean canClose() {
<span class="nc" id="L1877">        return canClose;</span>
    }

    public void setRight (SpecialRight right) {
<span class="pc bpc" id="L1881" title="1 of 2 branches missed.">        if (rightsModel == null) {</span>
<span class="nc" id="L1882">            rightsModel = RightsModel.create(this, &quot;RightsModel&quot;);</span>
        }
<span class="fc" id="L1884">        rightsModel.add(right);</span>
<span class="fc" id="L1885">    }</span>

    public boolean hasRight(SpecialRight right) {
<span class="nc" id="L1888">        return rightsModel.contains(right);</span>
    }

    @Override
    public Object clone() {

<span class="nc" id="L1894">        Object clone = null;</span>
        try {
<span class="nc" id="L1896">            clone = super.clone();</span>
<span class="nc" id="L1897">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L1898">            log.error(&quot;Cannot clone company &quot; + getId());</span>
<span class="nc" id="L1899">            return null;</span>
<span class="nc" id="L1900">        }</span>

        /*
         * Add the certificates, if defined with the CompanyType and absent in
         * the Company specification
         */

        // FIXME: In the following the cloning has to be moved to the portfolio

/*        if (certificates != null) {
            ((PublicCompany) clone).setCertificates(certificates.view());
        }
        if (specialProperties != null) {
            ((PublicCompany) clone).specialProperties = new HolderModel&lt;SpecialProperty&gt;(this, &quot;specialProperties&quot;);
        }
 */

<span class="nc" id="L1917">        return clone;</span>
    }

    /** Extra codes to be added to the president's indicator in the Game Status window.
     * Normally nothing (see 1856 CGR for an exception). */
    public String getExtraShareMarks () {
<span class="nc" id="L1923">        return &quot;&quot;;</span>
    }

    /** Does the company has a route?
     * Currently this is a stub that always returns true.
     */
    public boolean hasRoute() {
<span class="nc" id="L1930">        return true;</span>
    }

    // Owner method
    public PortfolioModel getPortfolioModel() {
<span class="fc" id="L1935">        return portfolio;</span>
    }

    // Company methods
    public void initType(CompanyType type) {
<span class="fc" id="L1940">        this.type = type;</span>
<span class="fc" id="L1941">    }</span>

    public CompanyType getType() {
<span class="fc" id="L1944">        return type;</span>
    }

    public boolean isClosed() {
<span class="fc" id="L1948">        return closed.value();</span>
    }

    public void setClosed() {
<span class="fc" id="L1952">        closed.set(true);</span>

        PortfolioOwner shareDestination;
        // If applicable, prepare for a restart
<span class="pc bpc" id="L1956" title="1 of 2 branches missed.">        if (canBeRestarted) {</span>
<span class="nc bnc" id="L1957" title="All 2 branches missed.">            if (certsAreInitiallyAvailable) {</span>
<span class="nc" id="L1958">                shareDestination = getRoot().getBank().getIpo();</span>
            } else {
<span class="nc" id="L1960">                shareDestination = getRoot().getBank().getUnavailable();</span>
            }
<span class="nc" id="L1962">            reinitialise();</span>
        } else {
<span class="fc" id="L1964">            shareDestination = getRoot().getBank().getScrapHeap();</span>
<span class="fc" id="L1965">            inGameState.set(false);</span>
        }

        // Dispose of the certificates
<span class="fc bfc" id="L1969" title="All 2 branches covered.">        for (PublicCertificate cert : certificates) {</span>
<span class="fc bfc" id="L1970" title="All 2 branches covered.">            if (cert.getOwner() != shareDestination) {</span>
<span class="fc" id="L1971">                cert.moveTo(shareDestination);</span>
            }
<span class="fc" id="L1973">        }</span>

        // Any trains go to the pool (from the 1856 rules)
<span class="fc" id="L1976">        portfolio.getTrainsModel().getPortfolio().moveAll(getRoot().getBank().getPool());</span>

        // Any cash goes to the bank (from the 1856 rules)
<span class="fc" id="L1979">        int cash = treasury.value();</span>
<span class="pc bpc" id="L1980" title="1 of 2 branches missed.">        if (cash &gt; 0) {</span>
<span class="nc" id="L1981">            treasury.setSuppressZero(true);</span>
<span class="nc" id="L1982">            Currency.toBank(this, cash);</span>
        }

<span class="fc" id="L1985">        lastRevenue.setSuppressZero(true);</span>
<span class="fc" id="L1986">        setLastRevenue(0);</span>

        // move all laid tokens to free tokens again
<span class="fc" id="L1989">        Portfolio.moveAll(baseTokens.getLaidTokens(), this);</span>

        // close company on the stock market
<span class="fc" id="L1992">        getRoot().getStockMarket().close(this);</span>

<span class="fc" id="L1994">    }</span>

    public String getLongName() {
<span class="fc" id="L1997">        return longName;</span>
    }

    public String getAlias() {
<span class="fc" id="L2001">        return alias;</span>
    }

    public String getInfoText() {
<span class="nc" id="L2005">        return infoText;</span>
    }

    public ImmutableSet&lt;SpecialProperty&gt; getSpecialProperties() {
<span class="fc" id="L2009">        return portfolio.getPersistentSpecialProperties();</span>
    }

    // MoneyOwner interface
    public Purse getPurse() {
<span class="fc" id="L2014">        return treasury.getPurse();</span>
    }

    public int getCash() {
<span class="fc" id="L2018">        return getPurse().value();</span>
    }

    // Comparable interface
    public int compareTo(PublicCompany other) {
<span class="fc" id="L2023">        return this.getId().compareTo(other.getId());</span>
    }

    public void setRelatedNationalCompany(String companyName){
<span class="nc" id="L2027">        this.relatedPublicCompany = companyName;</span>
<span class="nc" id="L2028">    }</span>

    public String getRelatedNationalCompany() {
<span class="nc" id="L2031">        return relatedPublicCompany;</span>
    }


    public boolean isRelatedToNational(String nationalInFounding) {
<span class="nc bnc" id="L2036" title="All 2 branches missed.">        if (this.getRelatedNationalCompany().equals(nationalInFounding)){</span>
<span class="nc" id="L2037">            return true;</span>
        }
<span class="nc" id="L2039">        return false;</span>
    }

    /**
     * @return the foundingStartCompany
     */
    public String getFoundingStartCompany() {

<span class="nc" id="L2047">        return foundingStartCompany;</span>
    }

    /**
     * @param foundingStartCompany the foundingStartCompany to set
     */
    public void setStartingMinor(String foundingCompany) {
<span class="nc" id="L2054">        this.foundingStartCompany = foundingCompany;</span>
<span class="nc" id="L2055">    }</span>


    public Model getLastDirectIncomeModel() {
<span class="nc" id="L2059">        return lastDirectIncome;</span>
    }

    /**
     * Store the last direct Income earned by this company.
     *
     * @param i The last revenue amount.
     */
    public void setLastDirectIncome(int i) {
<span class="nc" id="L2068">        lastDirectIncome.set(i);</span>
<span class="nc" id="L2069">    }</span>

    /**
     * Get the last directIncome earned by this company.
     *
     * @return The last revenue amount.
     */
    public int getLastDirectIncome() {
<span class="nc" id="L2077">        return lastDirectIncome.value();</span>
    }

    public void setDirectIncomeRevenue(int directIncome) {
<span class="nc" id="L2081">        this.directIncomeRevenue.set(directIncome);</span>
<span class="nc" id="L2082">    }</span>

    public int getDirectIncomeRevenue() {
<span class="nc" id="L2085">        return directIncomeRevenue.value();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>