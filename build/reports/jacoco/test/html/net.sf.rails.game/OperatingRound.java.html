<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OperatingRound.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.game</a> &gt; <span class="el_source">OperatingRound.java</span></div><h1>OperatingRound.java</h1><pre class="source lang-java linenums">package net.sf.rails.game;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.TreeSet;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.Iterables;

import net.sf.rails.common.DisplayBuffer;
import net.sf.rails.common.GameOption;
import net.sf.rails.common.GuiDef;
import net.sf.rails.common.LocalText;
import net.sf.rails.common.ReportBuffer;
import net.sf.rails.game.financial.Bank;
import net.sf.rails.game.financial.BankPortfolio;
import net.sf.rails.game.financial.Certificate;
import net.sf.rails.game.financial.PublicCertificate;
import net.sf.rails.game.financial.StockSpace;
import net.sf.rails.game.round.RoundFacade;
import net.sf.rails.game.special.ExchangeForShare;
import net.sf.rails.game.special.SellBonusToken;
import net.sf.rails.game.special.SpecialBaseTokenLay;
import net.sf.rails.game.special.SpecialBonusTokenLay;
import net.sf.rails.game.special.SpecialProperty;
import net.sf.rails.game.special.SpecialRight;
import net.sf.rails.game.special.SpecialTileLay;
import net.sf.rails.game.special.SpecialTrainBuy;
import net.sf.rails.game.state.ArrayListState;
import net.sf.rails.game.state.Currency;
import net.sf.rails.game.state.GenericState;
import net.sf.rails.game.state.HashMapState;
import net.sf.rails.game.state.MoneyOwner;
import net.sf.rails.game.state.Observable;
import net.sf.rails.game.state.Observer;
import net.sf.rails.game.state.Owner;
import net.sf.rails.util.SequenceUtil;
import rails.game.action.BuyBonusToken;
import rails.game.action.BuyPrivate;
import rails.game.action.BuyTrain;
import rails.game.action.DiscardTrain;
import rails.game.action.LayBaseToken;
import rails.game.action.LayBonusToken;
import rails.game.action.LayTile;
import rails.game.action.NullAction;
import rails.game.action.PossibleAction;
import rails.game.action.PossibleORAction;
import rails.game.action.ReachDestinations;
import rails.game.action.RepayLoans;
import rails.game.action.SetDividend;
import rails.game.action.TakeLoans;
import rails.game.action.UseSpecialProperty;
import rails.game.correct.ClosePrivate;
import rails.game.correct.OperatingCost;

/**
 * Implements a basic Operating Round. &lt;p&gt; A new instance must be created for
 * each new Operating Round. At the end of a round, the current instance should
 * be discarded.
 */
public class OperatingRound extends Round implements Observer {
<span class="fc" id="L70">    private static final Logger log = LoggerFactory.getLogger(OperatingRound.class);</span>

    /* Transient memory (per round only) */
<span class="fc" id="L73">    protected final GenericState&lt;GameDef.OrStep&gt; stepObject =</span>
<span class="fc" id="L74">            GenericState.create(this, &quot;ORStep&quot;, GameDef.OrStep.INITIAL);</span>

<span class="fc" id="L76">    protected boolean actionPossible = true;</span>

    /* flag for using rails without map support */
    protected final boolean noMapMode;

    // TODO: Check if this should not be turned into a State?
<span class="fc" id="L82">    protected final List&lt;PublicCompany&gt; companiesOperatedThisRound =</span>
            new ArrayList&lt;PublicCompany&gt;();

<span class="fc" id="L85">    protected ArrayListState&lt;PublicCompany&gt; operatingCompanies = null; // will</span>
                                                                       // be
                                                                       // created
                                                                       // below

<span class="fc" id="L90">    protected final GenericState&lt;PublicCompany&gt; operatingCompany =</span>
<span class="fc" id="L91">            GenericState.create(this, &quot;operatingCompany&quot;);</span>
    // do not use a operatingCompany.getObject() as reference
    // TODO: Question is this remark above still relevant?

    // Non-persistent lists (are recreated after each user action)

<span class="fc" id="L97">    protected final HashMapState&lt;String, Integer&gt; tileLaysPerColour =</span>
<span class="fc" id="L98">            HashMapState.create(this, &quot;tileLaysPerColour&quot;);</span>

<span class="fc" id="L100">    protected final List&lt;LayBaseToken&gt; currentNormalTokenLays =</span>
            new ArrayList&lt;LayBaseToken&gt;();

<span class="fc" id="L103">    protected final List&lt;LayBaseToken&gt; currentSpecialTokenLays =</span>
            new ArrayList&lt;LayBaseToken&gt;();

    /** A List per player with owned companies that have excess trains */
<span class="fc" id="L107">    protected Map&lt;Player, List&lt;PublicCompany&gt;&gt; excessTrainCompanies = null;</span>

<span class="fc" id="L109">    protected final ArrayListState&lt;TrainCertificateType&gt; trainsBoughtThisTurn =</span>
<span class="fc" id="L110">            ArrayListState.create(this, &quot;trainsBoughtThisTurn&quot;);</span>

<span class="fc" id="L112">    protected HashMapState&lt;PublicCompany, Integer&gt; loansThisRound = null;</span>

    protected String thisOrNumber;

<span class="fc" id="L116">    protected PossibleAction selectedAction = null;</span>

<span class="fc" id="L118">    protected PossibleAction savedAction = null;</span>

    public static final int SPLIT_ROUND_DOWN = 2; // More to the treasury

    // protected static GameDef.OrStep[] steps =
<span class="fc" id="L123">    protected GameDef.OrStep[] steps = new GameDef.OrStep[] {</span>
            GameDef.OrStep.INITIAL, GameDef.OrStep.LAY_TRACK,
            GameDef.OrStep.LAY_TOKEN, GameDef.OrStep.CALC_REVENUE,
            GameDef.OrStep.PAYOUT, GameDef.OrStep.BUY_TRAIN,
            GameDef.OrStep.TRADE_SHARES, GameDef.OrStep.FINAL };

<span class="fc" id="L129">    protected boolean doneAllowed = false;</span>

<span class="fc" id="L131">    protected TrainManager trainManager = getRoot().getTrainManager();</span>

    /*
     * ======================================= 1. OR START and END
     * =======================================
     */

    /**
     * Constructed via Configure
     */
    public OperatingRound(GameManager parent, String id) {
<span class="fc" id="L142">        super(parent, id);</span>

<span class="fc" id="L144">        operatingCompanies =</span>
<span class="fc" id="L145">                ArrayListState.create(this, &quot;operatingCompanies&quot;,</span>
<span class="fc" id="L146">                        setOperatingCompanies());</span>
<span class="fc" id="L147">        stepObject.addObserver(this);</span>

<span class="fc" id="L149">        noMapMode = GameOption.getAsBoolean(this, &quot;NoMapMode&quot;);</span>

<span class="fc" id="L151">        guiHints.setVisibilityHint(GuiDef.Panel.STOCK_MARKET, false);</span>
<span class="fc" id="L152">        guiHints.setVisibilityHint(GuiDef.Panel.STATUS, true);</span>
<span class="fc" id="L153">        guiHints.setActivePanel(GuiDef.Panel.MAP);</span>
<span class="fc" id="L154">    }</span>

    public void start() {

<span class="fc" id="L158">        thisOrNumber = gameManager.getORId();</span>

<span class="fc" id="L160">        ReportBuffer.add(this, LocalText.getText(&quot;START_OR&quot;, thisOrNumber));</span>

<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (Player player : getRoot().getPlayerManager().getPlayers()) {</span>
<span class="fc" id="L163">            player.setWorthAtORStart();</span>
<span class="fc" id="L164">        }</span>

<span class="fc" id="L166">        privatesPayOut();</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (operatingCompanies.size() &gt; 0) {</span>

<span class="fc" id="L170">            StringBuilder msg = new StringBuilder();</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">            for (PublicCompany company : operatingCompanies.view()) {</span>
<span class="fc" id="L172">                msg.append(&quot;,&quot;).append(company.getId());</span>
<span class="fc" id="L173">            }</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">            if (msg.length() &gt; 0) msg.deleteCharAt(0);</span>
<span class="fc" id="L175">            log.info(&quot;Initial operating sequence is {}&quot;, msg.toString());</span>

<span class="pc bpc" id="L177" title="1 of 2 branches missed.">            if (setNextOperatingCompany(true)) {</span>
<span class="fc" id="L178">                setStep(GameDef.OrStep.INITIAL);</span>
            }
<span class="fc" id="L180">            return;</span>
        }

        // No operating companies yet: close the round.
<span class="fc" id="L184">        String text = LocalText.getText(&quot;ShortORExecuted&quot;);</span>
<span class="fc" id="L185">        ReportBuffer.add(this, text);</span>
<span class="fc" id="L186">        DisplayBuffer.add(this, text);</span>
<span class="fc" id="L187">        finishRound();</span>
<span class="fc" id="L188">    }</span>

    protected void privatesPayOut() {
<span class="fc" id="L191">        int count = 0;</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        for (PrivateCompany priv : companyManager.getAllPrivateCompanies()) {</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">            if (!priv.isClosed()) {</span>
                // Bank Portfolios are not MoneyOwners!
<span class="fc bfc" id="L195" title="All 2 branches covered.">                if (priv.getOwner() instanceof MoneyOwner) {</span>
<span class="fc" id="L196">                    MoneyOwner recipient = (MoneyOwner) priv.getOwner();</span>
<span class="fc" id="L197">                    int revenue = priv.getRevenueByPhase(Phase.getCurrent(this));</span>

<span class="fc bfc" id="L199" title="All 2 branches covered.">                    if (revenue != 0) {</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">                        if (count++ == 0) ReportBuffer.add(this, &quot;&quot;);</span>
<span class="fc" id="L201">                        String revText = Currency.fromBank(revenue, recipient);</span>
<span class="fc" id="L202">                        ReportBuffer.add(this, LocalText.getText(&quot;ReceivesFor&quot;,</span>
<span class="fc" id="L203">                                recipient.getId(), revText, priv.getId()));</span>
                    }
                }
            }
<span class="fc" id="L207">        }</span>
<span class="fc" id="L208">    }</span>

    @Override
    public void resume() {

<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (savedAction instanceof BuyTrain) {</span>
<span class="fc" id="L214">            buyTrain((BuyTrain) savedAction);</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        } else if (savedAction instanceof SetDividend) {</span>
<span class="nc" id="L216">            executeSetRevenueAndDividend((SetDividend) savedAction);</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        } else if (savedAction instanceof RepayLoans) {</span>
<span class="nc" id="L218">            executeRepayLoans((RepayLoans) savedAction);</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        } else if (savedAction == null) {</span>
            // nextStep();
        }
<span class="fc" id="L222">        savedAction = null;</span>
<span class="fc" id="L223">        wasInterrupted.set(true);</span>

<span class="fc" id="L225">        guiHints.setVisibilityHint(GuiDef.Panel.STOCK_MARKET, false);</span>
<span class="fc" id="L226">        guiHints.setVisibilityHint(GuiDef.Panel.STATUS, true);</span>
<span class="fc" id="L227">        guiHints.setActivePanel(GuiDef.Panel.MAP);</span>
<span class="fc" id="L228">    }</span>

    protected void finishOR() {

        // Check if any privates must be closed
        // (now only applies to 1856 W&amp;SR) - no, that is at end of TURN
        // for (PrivateCompany priv : gameManager.getAllPrivateCompanies()) {
        // priv.checkClosingIfExercised(true);
        // }

<span class="fc" id="L238">        ReportBuffer.add(this, &quot; &quot;);</span>
<span class="fc" id="L239">        ReportBuffer.add(this,</span>
<span class="fc" id="L240">                LocalText.getText(&quot;EndOfOperatingRound&quot;, thisOrNumber));</span>

        // Update the worth increase per player
        int orWorthIncrease;
<span class="fc bfc" id="L244" title="All 2 branches covered.">        for (Player player : getRoot().getPlayerManager().getPlayers()) {</span>
<span class="fc" id="L245">            player.setLastORWorthIncrease();</span>
<span class="fc" id="L246">            orWorthIncrease = player.getLastORWorthIncrease().value();</span>
<span class="fc" id="L247">            ReportBuffer.add(this, LocalText.getText(&quot;ORWorthIncrease&quot;,</span>
<span class="fc" id="L248">                    player.getId(), thisOrNumber,</span>
<span class="fc" id="L249">                    Bank.format(this, orWorthIncrease)));</span>
<span class="fc" id="L250">        }</span>

        // OR done. Inform GameManager.
<span class="fc" id="L253">        finishRound();</span>
<span class="fc" id="L254">    }</span>

    /*
     * ======================================= 2. CENTRAL PROCESSING FUNCTIONS
     * 2.1. PROCESS USER ACTION=======================================
     */

    @Override
    public boolean process(PossibleAction action) {

<span class="fc" id="L264">        boolean result = false;</span>
<span class="fc" id="L265">        doneAllowed = false;</span>

        /*--- Common OR checks ---*/
        /* Check operating company */
<span class="fc bfc" id="L269" title="All 4 branches covered.">        if (action instanceof PossibleORAction</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">            &amp;&amp; !(action instanceof DiscardTrain) &amp;&amp; !action.isCorrection()) {</span>
<span class="fc" id="L271">            PublicCompany company = ((PossibleORAction) action).getCompany();</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">            if (company != operatingCompany.value()) {</span>
<span class="nc" id="L273">                DisplayBuffer.add(this, LocalText.getText(&quot;WrongCompany&quot;,</span>
<span class="nc" id="L274">                        company.getId(), operatingCompany.value().getId()));</span>
<span class="nc" id="L275">                return false;</span>
            }
        }

<span class="fc" id="L279">        selectedAction = action;</span>

<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (selectedAction instanceof LayTile) {</span>

<span class="fc" id="L283">            LayTile layTileAction = (LayTile)selectedAction;</span>

<span class="pc bpc" id="L285" title="1 of 2 branches missed.">            switch (layTileAction.getType()) {</span>
            case (LayTile.CORRECTION):
<span class="nc" id="L287">                result = layTileCorrection(layTileAction);</span>
<span class="nc" id="L288">                break;</span>
            default:
<span class="fc" id="L290">                result = layTile(layTileAction);</span>
            }

<span class="fc bfc" id="L293" title="All 2 branches covered.">        } else if (selectedAction instanceof LayBaseToken) {</span>

<span class="fc" id="L295">            result = layBaseToken((LayBaseToken) selectedAction);</span>

<span class="fc bfc" id="L297" title="All 2 branches covered.">        } else if (selectedAction instanceof LayBonusToken) {</span>

<span class="fc" id="L299">            result = layBonusToken((LayBonusToken) selectedAction);</span>

<span class="fc bfc" id="L301" title="All 2 branches covered.">        } else if (selectedAction instanceof BuyBonusToken) {</span>

<span class="fc" id="L303">            result = buyBonusToken((BuyBonusToken) selectedAction);</span>

<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        } else if (selectedAction instanceof OperatingCost) {</span>

<span class="nc" id="L307">            result = executeOperatingCost((OperatingCost) selectedAction);</span>

<span class="fc bfc" id="L309" title="All 2 branches covered.">        } else if (selectedAction instanceof SetDividend) {</span>

<span class="fc" id="L311">            result = setRevenueAndDividend((SetDividend) selectedAction);</span>

<span class="fc bfc" id="L313" title="All 2 branches covered.">        } else if (selectedAction instanceof BuyTrain) {</span>

<span class="fc" id="L315">            result = buyTrain((BuyTrain) selectedAction);</span>

<span class="fc bfc" id="L317" title="All 2 branches covered.">        } else if (selectedAction instanceof DiscardTrain) {</span>

<span class="fc" id="L319">            result = discardTrain((DiscardTrain) selectedAction);</span>

<span class="fc bfc" id="L321" title="All 2 branches covered.">        } else if (selectedAction instanceof BuyPrivate) {</span>

<span class="fc" id="L323">            result = buyPrivate((BuyPrivate) selectedAction);</span>

<span class="fc bfc" id="L325" title="All 2 branches covered.">        } else if (selectedAction instanceof ReachDestinations) {</span>

<span class="fc" id="L327">            result = reachDestinations((ReachDestinations) selectedAction);</span>

<span class="fc bfc" id="L329" title="All 2 branches covered.">        } else if (selectedAction instanceof TakeLoans) {</span>

<span class="fc" id="L331">            result = takeLoans((TakeLoans) selectedAction);</span>

<span class="fc bfc" id="L333" title="All 2 branches covered.">        } else if (selectedAction instanceof RepayLoans) {</span>

<span class="fc" id="L335">            result = repayLoans((RepayLoans) selectedAction);</span>

			/*
			 * } else if (selectedAction instanceof ExchangeTokens) {
			 *
			 * result = exchangeTokens((ExchangeTokens) selectedAction, false); // 2nd //
			 * parameter: // unlinked // moveset
			 */
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        } else if (selectedAction instanceof ClosePrivate) {</span>

<span class="nc" id="L345">            result = executeClosePrivate((ClosePrivate) selectedAction);</span>

<span class="fc bfc" id="L347" title="All 2 branches covered.">        } else if (selectedAction instanceof UseSpecialProperty</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">                   &amp;&amp; ((UseSpecialProperty) selectedAction).getSpecialProperty() instanceof SpecialRight) {</span>

<span class="fc" id="L350">            result = buyRight((UseSpecialProperty) selectedAction);</span>

<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        } else if (selectedAction instanceof UseSpecialProperty</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">                &amp;&amp; ((UseSpecialProperty) selectedAction).getSpecialProperty() instanceof ExchangeForShare) {</span>

<span class="nc" id="L355">            useSpecialProperty((UseSpecialProperty)selectedAction);</span>


<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        } else if (selectedAction instanceof NullAction) {</span>

<span class="fc" id="L360">            NullAction nullAction = (NullAction) action;</span>
<span class="pc bpc" id="L361" title="1 of 3 branches missed.">            switch (nullAction.getMode()) {</span>
            case DONE:
            case PASS:
<span class="fc" id="L364">                result = done(nullAction);</span>
<span class="fc" id="L365">                break;</span>
            case SKIP:
<span class="fc" id="L367">                skip(nullAction);</span>
<span class="fc" id="L368">                result = true;</span>
<span class="fc" id="L369">                break;</span>
            default:
                break;
            }

<span class="pc bnc" id="L374" title="All 2 branches missed.">        } else if (processGameSpecificAction(action)) {</span>

<span class="nc" id="L376">            result = true;</span>

        } else {

<span class="nc" id="L380">            DisplayBuffer.add(</span>
                    this,
<span class="nc" id="L382">                    LocalText.getText(&quot;UnexpectedAction&quot;,</span>
<span class="nc" id="L383">                            selectedAction.toString()));</span>
<span class="nc" id="L384">            return false;</span>
        }

<span class="fc" id="L387">        return result;</span>
    }

    public boolean useSpecialProperty(UseSpecialProperty action) {

<span class="nc" id="L392">        SpecialProperty sp = action.getSpecialProperty();</span>

<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (sp instanceof ExchangeForShare) {</span>

<span class="nc" id="L396">            return executeExchangeForShare(action, (ExchangeForShare) sp);</span>

        } else {
<span class="nc" id="L399">            return false;</span>
        }
    }

    public boolean executeExchangeForShare (UseSpecialProperty action, ExchangeForShare sp) {

<span class="nc" id="L405">        PublicCompany publicCompany =</span>
<span class="nc" id="L406">            companyManager.getPublicCompany(sp.getPublicCompanyName());</span>
<span class="nc" id="L407">        PrivateCompany privateCompany = (PrivateCompany)sp.getOriginalCompany();</span>
<span class="nc" id="L408">        Owner owner= privateCompany.getOwner();</span>
<span class="nc" id="L409">        Player player = null;</span>
<span class="nc" id="L410">        String errMsg = null;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">        boolean ipoHasShare = ipo.getShare(publicCompany) &gt;= sp.getShare();</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">        boolean poolHasShare = pool.getShare(publicCompany) &gt;= sp.getShare();</span>

        while (true) {

            /* Check if the private is owned by a player */
<span class="nc bnc" id="L417" title="All 2 branches missed.">            if (!(owner instanceof Player)) {</span>
<span class="nc" id="L418">                errMsg =</span>
<span class="nc" id="L419">                    LocalText.getText(&quot;PrivateIsNotOwnedByAPlayer&quot;,</span>
<span class="nc" id="L420">                            privateCompany.getId());</span>
<span class="nc" id="L421">                break;</span>
            }

<span class="nc" id="L424">            player = (Player) owner;</span>

            /* Check if a share is available */
<span class="nc bnc" id="L427" title="All 4 branches missed.">            if (!ipoHasShare &amp;&amp; !poolHasShare) {</span>
<span class="nc" id="L428">                errMsg =</span>
<span class="nc" id="L429">                    LocalText.getText(&quot;NoSharesAvailable&quot;,</span>
<span class="nc" id="L430">                            publicCompany.getId());</span>
                break;
            }

            break;
        }
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L437">            DisplayBuffer.add(this, LocalText.getText(</span>
                    &quot;CannotSwapPrivateForCertificate&quot;,
<span class="nc" id="L439">                    player.getId(),</span>
<span class="nc" id="L440">                    privateCompany.getId(),</span>
<span class="nc" id="L441">                    sp.getShare(),</span>
<span class="nc" id="L442">                    publicCompany.getId(),</span>
                    errMsg ));
<span class="nc" id="L444">            return false;</span>
        }



        Certificate cert =
<span class="nc bnc" id="L450" title="All 2 branches missed.">            ipoHasShare ? (PublicCertificate) ipo.findCertificate(publicCompany,</span>
<span class="nc" id="L451">                    false) : (PublicCertificate) pool.findCertificate(publicCompany,</span>
                            false);
<span class="nc" id="L453">            cert.moveTo(player);</span>
<span class="nc" id="L454">            ReportBuffer.add(this, LocalText.getText(&quot;SwapsPrivateForCertificate&quot;,</span>
<span class="nc" id="L455">                    player.getId(),</span>
<span class="nc" id="L456">                    privateCompany.getId(),</span>
<span class="nc" id="L457">                    sp.getShare(),</span>
<span class="nc" id="L458">                    publicCompany.getId()));</span>
<span class="nc" id="L459">            sp.setExercised();</span>
<span class="nc" id="L460">            privateCompany.setClosed();</span>

<span class="nc" id="L462">            return true;</span>
    }


    /** Stub, to be overridden in game-specific subclasses. */
    public boolean processGameSpecificAction(PossibleAction action) {
<span class="nc" id="L468">        return false;</span>
    }

    /*
     * ======================================= 2.2. PREPARE NEXT ACTION
     * =======================================
     */

    /**
     * To be called after each change, to re-establish the currently allowed
     * actions. (new method, intended to absorb code from several other
     * methods).
     *
     */
    @Override
    public boolean setPossibleActions() {

        /* Create a new list of possible actions for the UI */
<span class="fc" id="L486">        possibleActions.clear();</span>
<span class="fc" id="L487">        selectedAction = null;</span>

<span class="fc" id="L489">        boolean forced = false;</span>
<span class="fc" id="L490">        doneAllowed = false; // set default (fix of bug 2954654)</span>

<span class="fc bfc" id="L492" title="All 2 branches covered.">        if (getStep() == GameDef.OrStep.INITIAL) {</span>
<span class="fc" id="L493">            initTurn();</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">            if (noMapMode) {</span>
<span class="nc" id="L495">                nextStep(GameDef.OrStep.LAY_TOKEN);</span>
            } else {
<span class="fc" id="L497">                initNormalTileLays(); // new: only called once per turn ?</span>
<span class="fc" id="L498">                setStep(GameDef.OrStep.LAY_TRACK);</span>
            }
        }

<span class="fc" id="L502">        GameDef.OrStep step = getStep();</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">        if (step == GameDef.OrStep.LAY_TRACK) {</span>

<span class="fc bfc" id="L505" title="All 2 branches covered.">            if (!operatingCompany.value().hasLaidHomeBaseTokens()) {</span>
                // This can occur if the home hex has two cities and track,
                // such as the green OO tile #59

                // BR: as this is a home token, need to call LayBaseToken with a
                // MapHex, not a list
                // to avoid the LayBaseToken action from being a regular token
                // lay
                // I am not sure that this will work with multiple home hexes.
<span class="fc bfc" id="L514" title="All 2 branches covered.">                for (MapHex home : operatingCompany.value().getHomeHexes()) {</span>
<span class="fc" id="L515">                    possibleActions.add(new LayBaseToken(home));</span>
<span class="fc" id="L516">                }</span>
<span class="fc" id="L517">                forced = true;</span>
            } else {
<span class="fc" id="L519">                possibleActions.addAll(getNormalTileLays(true));</span>
<span class="fc" id="L520">                possibleActions.addAll(getSpecialTileLays(true));</span>
<span class="fc" id="L521">                possibleActions.add(new NullAction(NullAction.Mode.SKIP));</span>
            }

<span class="fc bfc" id="L524" title="All 2 branches covered.">        } else if (step == GameDef.OrStep.LAY_TOKEN) {</span>
<span class="fc" id="L525">            setNormalTokenLays();</span>
<span class="fc" id="L526">            setSpecialTokenLays();</span>
<span class="fc" id="L527">            log.debug(&quot;Normal token lays: {}&quot;, currentNormalTokenLays.size());</span>
<span class="fc" id="L528">            log.debug(&quot;Special token lays: {}&quot;, currentSpecialTokenLays.size());</span>

<span class="fc" id="L530">            possibleActions.addAll(currentNormalTokenLays);</span>
<span class="fc" id="L531">            possibleActions.addAll(currentSpecialTokenLays);</span>
<span class="fc" id="L532">            possibleActions.add(new NullAction(NullAction.Mode.SKIP));</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">        } else if (step == GameDef.OrStep.CALC_REVENUE) {</span>
<span class="fc" id="L534">            prepareRevenueAndDividendAction();</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">            if (noMapMode) prepareNoMapActions();</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">        } else if (step == GameDef.OrStep.BUY_TRAIN) {</span>
<span class="fc" id="L537">            setBuyableTrains();</span>
            // TODO Need route checking here.
            // TEMPORARILY allow not buying a train if none owned
            // if (!operatingCompany.getObject().mustOwnATrain()
            // ||
            // operatingCompany.getObject().getPortfolio().getNumberOfTrains() &gt;
            // 0) {
<span class="fc" id="L544">            doneAllowed = true;</span>
            // }
<span class="pc bpc" id="L546" title="3 of 4 branches missed.">            if (noMapMode &amp;&amp; (operatingCompany.value().getLastRevenue() == 0))</span>
<span class="nc" id="L547">                prepareNoMapActions();</span>

<span class="fc bfc" id="L549" title="All 2 branches covered.">        } else if (step == GameDef.OrStep.DISCARD_TRAINS) {</span>

<span class="fc" id="L551">            forced = true;</span>
<span class="fc" id="L552">            setTrainsToDiscard();</span>
        }

        // The following additional &quot;common&quot; actions are only available if the
        // primary action is not forced.
<span class="fc bfc" id="L557" title="All 2 branches covered.">        if (!forced) {</span>

<span class="fc" id="L559">            setBonusTokenLays();</span>

<span class="fc" id="L561">            setDestinationActions();</span>

<span class="fc" id="L563">            setGameSpecificPossibleActions();</span>

            // Private Company manually closure
<span class="fc bfc" id="L566" title="All 2 branches covered.">            for (PrivateCompany priv : companyManager.getAllPrivateCompanies()) {</span>
<span class="fc bfc" id="L567" title="All 4 branches covered.">                if (!priv.isClosed() &amp;&amp; priv.closesManually())</span>
<span class="fc" id="L568">                    possibleActions.add(new ClosePrivate(priv));</span>
<span class="fc" id="L569">            }</span>

            // Can private companies be bought?
<span class="fc bfc" id="L572" title="All 2 branches covered.">            if (isPrivateSellingAllowed()) {</span>

                // Create a list of players with the current one in front
<span class="fc" id="L575">                int currentPlayerIndex =</span>
<span class="fc" id="L576">                        operatingCompany.value().getPresident().getIndex();</span>
                Player player;
                int minPrice, maxPrice;
<span class="fc" id="L579">                List&lt;Player&gt; players = playerManager.getPlayers();</span>
<span class="fc" id="L580">                int numberOfPlayers = playerManager.getNumberOfPlayers();</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">                for (int i = currentPlayerIndex; i &lt; currentPlayerIndex</span>
<span class="fc" id="L582">                                                     + numberOfPlayers; i++) {</span>
<span class="fc" id="L583">                    player = players.get(i % numberOfPlayers);</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">                    if (!maySellPrivate(player)) continue;</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">                    for (PrivateCompany privComp : player.getPortfolioModel().getPrivateCompanies()) {</span>

                        // check to see if the private can be sold to a company
<span class="fc bfc" id="L588" title="All 2 branches covered.">                        if (!privComp.tradeableToCompany()) {</span>
<span class="fc" id="L589">                            continue;</span>
                        }

<span class="fc" id="L592">                        minPrice = getPrivateMinimumPrice(privComp);</span>

<span class="fc" id="L594">                        maxPrice = getPrivateMaximumPrice(privComp);</span>

<span class="fc" id="L596">                        possibleActions.add(new BuyPrivate(privComp, minPrice,</span>
                                maxPrice));
<span class="fc" id="L598">                    }</span>
                }
            }

<span class="fc bfc" id="L602" title="All 2 branches covered.">            if (operatingCompany.value().canUseSpecialProperties()) {</span>

                // Are there any &quot;common&quot; special properties,
                // i.e. properties that are available to everyone?
<span class="fc" id="L606">                List&lt;SpecialProperty&gt; commonSP =</span>
<span class="fc" id="L607">                        gameManager.getCommonSpecialProperties();</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">                if (commonSP != null) {</span>
                    SellBonusToken sbt;
<span class="fc bfc" id="L610" title="All 2 branches covered.">                    loop: for (SpecialProperty sp : commonSP) {</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">                        if (sp instanceof SellBonusToken) {</span>
<span class="fc" id="L612">                            sbt = (SellBonusToken) sp;</span>
                            // Can't buy if already owned
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">                            if (operatingCompany.value().getBonuses() != null) {</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">                                for (Bonus bonus : operatingCompany.value().getBonuses()) {</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">                                    if (bonus.getName().equals(sp.getId()))</span>
<span class="fc" id="L617">                                        continue loop;</span>
<span class="fc" id="L618">                                }</span>
                            }
<span class="fc" id="L620">                            possibleActions.add(new BuyBonusToken(sbt));</span>
                        }
<span class="fc" id="L622">                    }</span>
                }

                // Are there other step-independent special properties owned by
                // the company?
<span class="fc" id="L627">                List&lt;SpecialProperty&gt; orsps =</span>
<span class="fc" id="L628">                        operatingCompany.value().getPortfolioModel().getAllSpecialProperties();</span>

                // TODO: Do we still need this directly from the operating
                // company?
                // List&lt;SpecialProperty&gt; compsps =
                // operatingCompany.get().getSpecialProperties();
                // if (compsps != null) orsps.addAll(compsps);

<span class="pc bpc" id="L636" title="1 of 2 branches missed.">                if (orsps != null) {</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">                    for (SpecialProperty sp : orsps) {</span>
<span class="fc bfc" id="L638" title="All 4 branches covered.">                        if (!sp.isExercised() &amp;&amp; sp.isUsableIfOwnedByCompany()</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">                            &amp;&amp; sp.isUsableDuringOR(step)) {</span>
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">                            if (sp instanceof SpecialBaseTokenLay) {</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">                                if (getStep() != GameDef.OrStep.LAY_TOKEN) {</span>
<span class="nc" id="L642">                                    possibleActions.add(new LayBaseToken(</span>
                                            (SpecialBaseTokenLay) sp));
                                }
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">                            } else if (!(sp instanceof SpecialTileLay)) {</span>
<span class="fc" id="L646">                                possibleActions.add(new UseSpecialProperty(sp));</span>
                            }
                        }
<span class="fc" id="L649">                    }</span>
                }
                // Are there other step-independent special properties owned by
                // the president?
<span class="fc" id="L653">                orsps =</span>
<span class="fc" id="L654">                        playerManager.getCurrentPlayer().getPortfolioModel().getAllSpecialProperties();</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">                if (orsps != null) {</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">                    for (SpecialProperty sp : orsps) {</span>
<span class="fc bfc" id="L657" title="All 4 branches covered.">                        if (!sp.isExercised() &amp;&amp; sp.isUsableIfOwnedByPlayer()</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">                            &amp;&amp; sp.isUsableDuringOR(step)) {</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">                            if (sp instanceof SpecialBaseTokenLay) {</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">                                if (getStep() != GameDef.OrStep.LAY_TOKEN) {</span>
<span class="fc" id="L661">                                    possibleActions.add(new LayBaseToken(</span>
                                            (SpecialBaseTokenLay) sp));
                                }
                            } else {
<span class="fc" id="L665">                                possibleActions.add(new UseSpecialProperty(sp));</span>
                            }
                        }
<span class="fc" id="L668">                    }</span>
                }
            }
        }

<span class="fc bfc" id="L673" title="All 2 branches covered.">        if (doneAllowed) {</span>
<span class="fc" id="L674">            possibleActions.add(new NullAction(NullAction.Mode.DONE));</span>
        }

<span class="fc bfc" id="L677" title="All 2 branches covered.">        for (PossibleAction pa : possibleActions.getList()) {</span>
            try {
<span class="fc" id="L679">                log.debug(&quot;{} may: {}&quot;, operatingCompany.value().getId(), pa.toString());</span>
<span class="nc" id="L680">            } catch (Exception e) {</span>
<span class="nc" id="L681">                log.error(&quot;Error in toString() of {}&quot;, pa.getClass(), e);</span>
<span class="fc" id="L682">            }</span>
<span class="fc" id="L683">        }</span>

<span class="fc" id="L685">        return true;</span>
    }

    /** Stub, can be overridden by subclasses */
    protected void setGameSpecificPossibleActions() {

<span class="fc" id="L691">    }</span>

    /*
     * ======================================= 2.3. TURN CONTROL
     * =======================================
     */

    protected void initTurn() {
<span class="fc" id="L699">        log.debug(&quot;Starting turn of {}&quot;, operatingCompany.value().getId());</span>
<span class="fc" id="L700">        ReportBuffer.add(this, &quot; &quot;);</span>
<span class="fc" id="L701">        ReportBuffer.add(this, LocalText.getText(&quot;CompanyOperates&quot;,</span>
<span class="fc" id="L702">                operatingCompany.value().getId(),</span>
<span class="fc" id="L703">                operatingCompany.value().getPresident().getId()));</span>
<span class="fc" id="L704">        playerManager.setCurrentPlayer(operatingCompany.value().getPresident());</span>

<span class="pc bpc" id="L706" title="3 of 4 branches missed.">        if (noMapMode &amp;&amp; !operatingCompany.value().hasLaidHomeBaseTokens()) {</span>
            // Lay base token in noMapMode
<span class="nc" id="L708">            BaseToken token = operatingCompany.value().getNextBaseToken();</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">            if (token == null) {</span>
<span class="nc" id="L710">                log.error(&quot;Company {} has no free token to lay base token&quot;, operatingCompany.value().getId());</span>
            } else {
<span class="nc" id="L712">                log.debug(&quot;Company {} lays base token in nomap mode&quot;, operatingCompany.value().getId());</span>
                // FIXME: This has to be rewritten
                // Where are the nomap base tokens to be stored?
                // bank.getUnavailable().addBonusToken(token);
            }
        }
<span class="fc" id="L718">        operatingCompany.value().initTurn();</span>
<span class="fc" id="L719">        trainsBoughtThisTurn.clear();</span>
<span class="fc" id="L720">    }</span>

    protected void finishTurn() {

<span class="pc bpc" id="L724" title="1 of 2 branches missed.">        if (!operatingCompany.value().isClosed()) {</span>
<span class="fc" id="L725">            operatingCompany.value().setOperated();</span>
<span class="fc" id="L726">            companiesOperatedThisRound.add(operatingCompany.value());</span>

<span class="fc bfc" id="L728" title="All 2 branches covered.">            for (PrivateCompany priv : operatingCompany.value().getPortfolioModel().getPrivateCompanies()) {</span>
<span class="fc" id="L729">                priv.checkClosingIfExercised(true);</span>
<span class="fc" id="L730">            }</span>
        }

<span class="fc bfc" id="L733" title="All 2 branches covered.">        if (!finishTurnSpecials()) return;</span>

<span class="fc bfc" id="L735" title="All 2 branches covered.">        if (setNextOperatingCompany(false)) {</span>
<span class="fc" id="L736">            setStep(GameDef.OrStep.INITIAL);</span>
        } else {
<span class="fc" id="L738">            finishOR();</span>
        }
<span class="fc" id="L740">    }</span>

    /**
     * Stub, may be overridden in subclasses Return value: TRUE = normal turn
     * end; FALSE = return immediately from finishTurn().
     */
    protected boolean finishTurnSpecials() {
<span class="fc" id="L747">        return true;</span>
    }

    protected boolean setNextOperatingCompany(boolean initial) {

        while (true) {
<span class="pc bpc" id="L753" title="2 of 6 branches missed.">            if (initial || operatingCompany.value() == null</span>
                || operatingCompany == null) {
<span class="fc" id="L755">                setOperatingCompany(operatingCompanies.get(0));</span>
<span class="fc" id="L756">                initial = false;</span>
            } else {
<span class="fc" id="L758">                int index =</span>
<span class="fc" id="L759">                        operatingCompanies.indexOf(operatingCompany.value());</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">                if (++index &gt;= operatingCompanies.size()) {</span>
<span class="fc" id="L761">                    return false;</span>
                }

                // Check if the operating order has changed
<span class="fc" id="L765">                List&lt;PublicCompany&gt; newOperatingCompanies =</span>
<span class="fc" id="L766">                        setOperatingCompanies(operatingCompanies.view(),</span>
<span class="fc" id="L767">                                operatingCompany.value());</span>
                PublicCompany company;
<span class="fc bfc" id="L769" title="All 2 branches covered.">                for (int i = 0; i &lt; newOperatingCompanies.size(); i++) {</span>
<span class="fc" id="L770">                    company = newOperatingCompanies.get(i);</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">                    if (company != operatingCompanies.get(i)) {</span>
<span class="fc" id="L772">                        log.debug(&quot;Company {} replaces {} in operating sequence&quot;, company.getId(), operatingCompanies.get(i).getId());</span>
<span class="fc" id="L773">                        operatingCompanies.move(company, i);</span>
                    }
                }

<span class="fc" id="L777">                setOperatingCompany(operatingCompanies.get(index));</span>
            }

<span class="pc bpc" id="L780" title="1 of 2 branches missed.">            if (operatingCompany.value().isClosed()) continue;</span>

<span class="fc" id="L782">            return true;</span>
        }
    }

    protected void setOperatingCompany(PublicCompany company) {
<span class="fc" id="L787">        operatingCompany.set(company);</span>
<span class="fc" id="L788">    }</span>

    /**
     * Get the public company that has the turn to operate.
     *
     * @return The currently operating company object.
     */
    public PublicCompany getOperatingCompany() {
<span class="fc" id="L796">        return operatingCompany.value();</span>
    }

    public List&lt;PublicCompany&gt; getOperatingCompanies() {
<span class="nc" id="L800">        return operatingCompanies.view();</span>
    }

    public int getOperatingCompanyndex() {
<span class="fc" id="L804">        int index = operatingCompanies.indexOf(getOperatingCompany());</span>
<span class="fc" id="L805">        return index;</span>
    }

    /*
     * ======================================= 2.4. STEP CONTROL
     * =======================================
     */

    /**
     * Get the current operating round step (i.e. the next action).
     *
     * @return The number that defines the next action.
     */
    public GameDef.OrStep getStep() {
<span class="fc" id="L819">        return (GameDef.OrStep) stepObject.value();</span>
    }

    /**
     * Bypass normal order of operations and explicitly set round step. This
     * should only be done for specific rails.game exceptions, such as forced
     * train purchases.
     *
     * @param step
     */
    protected void setStep(GameDef.OrStep step) {

<span class="fc" id="L831">        stepObject.set(step);</span>

<span class="fc" id="L833">    }</span>

    /**
     * Internal method: change the OR state to the next step. If the currently
     * Operating Company is done, notify this.
     *
     * @param company The current company.
     */
    protected void nextStep() {
<span class="fc" id="L842">        nextStep(getStep());</span>
<span class="fc" id="L843">    }</span>

    /** Take the next step after a given one (see nextStep()) */
    protected void nextStep(GameDef.OrStep step) {

<span class="fc" id="L848">        PublicCompany company = operatingCompany.value();</span>

        // Cycle through the steps until we reach one where a user action is
        // expected.
        int stepIndex;
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">        for (stepIndex = 0; stepIndex &lt; steps.length; stepIndex++) {</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">            if (steps[stepIndex] == step) break;</span>
        }
<span class="pc bpc" id="L856" title="1 of 2 branches missed.">        while (++stepIndex &lt; steps.length) {</span>
<span class="fc" id="L857">            step = steps[stepIndex];</span>
<span class="fc" id="L858">            log.debug(&quot;OR considers step {}&quot;, step);</span>

<span class="fc bfc" id="L860" title="All 2 branches covered.">            if (step == GameDef.OrStep.LAY_TOKEN</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">                &amp;&amp; company.getNumberOfFreeBaseTokens() == 0) {</span>
<span class="fc" id="L862">                log.debug(&quot;OR skips {}: No freeBaseTokens&quot;, step);</span>
<span class="fc" id="L863">                continue;</span>
            }

<span class="fc bfc" id="L866" title="All 2 branches covered.">            if (step == GameDef.OrStep.CALC_REVENUE) {</span>

<span class="fc bfc" id="L868" title="All 2 branches covered.">                if (!company.canRunTrains()) {</span>
                    // No trains, then the revenue is zero.
<span class="fc" id="L870">                    log.debug(&quot;OR skips {}: Cannot run trains&quot;, step);</span>
<span class="fc" id="L871">                    executeSetRevenueAndDividend(new SetDividend(0, false,</span>
                            new int[] { SetDividend.NO_TRAIN }));
                    // TODO: This probably does not handle share selling
                    // correctly
<span class="fc" id="L875">                    continue;</span>
                }
            }

<span class="fc bfc" id="L879" title="All 2 branches covered.">            if (step == GameDef.OrStep.PAYOUT) {</span>
                // This step is now obsolete
<span class="fc" id="L881">                log.debug(&quot;OR skips {}: Always skipped&quot;, step);</span>
<span class="fc" id="L882">                continue;</span>
            }

<span class="fc bfc" id="L885" title="All 2 branches covered.">            if (step == GameDef.OrStep.TRADE_SHARES) {</span>

                // Is company allowed to trade trasury shares?
<span class="fc bfc" id="L888" title="All 4 branches covered.">                if (!company.mayTradeShares() || !company.hasOperated()) {</span>
<span class="fc" id="L889">                    continue;</span>
                }

                /*
                 * Check if any trading is possible. If not, skip this step.
                 * (but register a Done action for BACKWARDS COMPATIBILITY only)
                 */
                // Preload some expensive results
<span class="fc" id="L897">                int ownShare = company.getPortfolioModel().getShare(company);</span>
<span class="fc" id="L898">                int poolShare = pool.getShare(company); // Expensive, do it once</span>
                // Can it buy?
<span class="fc" id="L900">                boolean canBuy =</span>
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">                        ownShare &lt; GameDef.getGameParameterAsInt(this, GameDef.Parm.TREASURY_SHARE_LIMIT)</span>
<span class="fc bfc" id="L902" title="All 4 branches covered.">                                &amp;&amp; company.getCash() &gt;= company.getCurrentSpace().getPrice()</span>
                                &amp;&amp; poolShare &gt; 0;
                // Can it sell?
<span class="fc" id="L905">                boolean canSell =</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">                        company.getPortfolioModel().getShare(company) &gt; 0</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">                                &amp;&amp; poolShare &lt; GameDef.getGameParameterAsInt(this, GameDef.Parm.POOL_SHARE_LIMIT);</span>
                // Above we ignore the possible existence of double shares (as
                // in 1835).

<span class="fc bfc" id="L911" title="All 4 branches covered.">                if (!canBuy &amp;&amp; !canSell) {</span>
                    // XXX For BACKWARDS COMPATIBILITY only,
                    // register a Done skip action during reloading.
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">                    if (gameManager.isReloading()) {</span>
<span class="fc" id="L915">                        gameManager.setSkipDone(GameDef.OrStep.TRADE_SHARES);</span>
<span class="fc" id="L916">                        log.debug(&quot;If the next saved action is 'Done', skip it&quot;);</span>
                    }
<span class="fc" id="L918">                    log.info(&quot;Skipping Treasury share trading step&quot;);</span>
<span class="fc" id="L919">                    continue;</span>
                }

<span class="fc" id="L922">                gameManager.startTreasuryShareTradingRound(operatingCompany.value());</span>

            }

<span class="fc bfc" id="L926" title="All 2 branches covered.">            if (!gameSpecificNextStep(step)) {</span>
<span class="fc" id="L927">                log.debug(&quot;OR skips {}: Not game specific&quot;, step);</span>
<span class="fc" id="L928">                continue;</span>
            }

            // No reason found to skip this step
            break;
        }

<span class="fc bfc" id="L935" title="All 2 branches covered.">        if (step == GameDef.OrStep.FINAL) {</span>
<span class="fc" id="L936">            finishTurn();</span>
        } else {
<span class="fc" id="L938">            setStep(step);</span>
        }

<span class="fc" id="L941">    }</span>

    /** Stub, can be overridden in subclasses to check for extra steps */
    protected boolean gameSpecificNextStep(GameDef.OrStep step) {
<span class="fc" id="L945">        return true;</span>
    }

    /**
     * This method is only called at the start of each step (unlike
     * updateStatus(), which is called after each user action)
     */
    protected void prepareStep() {
<span class="fc" id="L953">        GameDef.OrStep step = stepObject.value();</span>

<span class="fc bfc" id="L955" title="All 2 branches covered.">        if (step == GameDef.OrStep.LAY_TRACK) {</span>
            // getNormalTileLays();
<span class="fc bfc" id="L957" title="All 2 branches covered.">        } else if (step == GameDef.OrStep.LAY_TOKEN) {</span>

        }

<span class="fc" id="L961">    }</span>

    /*
     * ======================================= 3. COMMON ACTIONS (not bound to
     * steps) 3.1. NOOPS=======================================
     */

    public void skip(NullAction action) {
<span class="fc" id="L969">        log.debug(&quot;Skip step {}&quot;, stepObject.value());</span>

<span class="fc" id="L971">        nextStep();</span>
<span class="fc" id="L972">    }</span>

    /**
     * The current Company is done operating.
     *
     * @param action TODO
     * @param company Name of the company that finished operating.
     *
     * @return False if an error is found.
     */
    public boolean done(NullAction action) {

<span class="fc bfc" id="L984" title="All 2 branches covered.">        if (operatingCompany.value().getPortfolioModel().getNumberOfTrains() == 0</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">            &amp;&amp; operatingCompany.value().mustOwnATrain()) {</span>
            // FIXME: Need to check for valid route before throwing an
            // error.
            /*
             * Check TEMPORARILY disabled errMsg =
             * LocalText.getText(&quot;CompanyMustOwnATrain&quot;,
             * operatingCompany.getObject().getName()); setStep(STEP_BUY_TRAIN);
             * DisplayBuffer.add(this, errMsg); return false;
             */
        }

<span class="fc" id="L996">        nextStep();</span>

<span class="pc bpc" id="L998" title="1 of 2 branches missed.">        if (getStep() == GameDef.OrStep.FINAL) {</span>
<span class="nc" id="L999">            finishTurn();</span>
        }

<span class="fc" id="L1002">        return true;</span>
    }

    /*
     * ======================================= 3.2. DISCARDING TRAINS
     * =======================================
     */

    public boolean discardTrain(DiscardTrain action) {

<span class="fc" id="L1012">        Train train = action.getDiscardedTrain();</span>
<span class="fc" id="L1013">        PublicCompany company = action.getCompany();</span>
<span class="fc" id="L1014">        String companyName = company.getId();</span>

<span class="fc" id="L1016">        String errMsg = null;</span>

        // Dummy loop to enable a quick jump out.
        while (true) {
            // Checks
            // Must be correct step
<span class="pc bpc" id="L1022" title="1 of 2 branches missed.">            if (getStep() != GameDef.OrStep.BUY_TRAIN</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">                &amp;&amp; getStep() != GameDef.OrStep.DISCARD_TRAINS) {</span>
<span class="nc" id="L1024">                errMsg = LocalText.getText(&quot;WrongActionNoDiscardTrain&quot;);</span>
<span class="nc" id="L1025">                break;</span>
            }

<span class="pc bpc" id="L1028" title="3 of 4 branches missed.">            if (train == null &amp;&amp; action.isForced()) {</span>
<span class="nc" id="L1029">                errMsg = LocalText.getText(&quot;NoTrainSpecified&quot;);</span>
<span class="nc" id="L1030">                break;</span>
            }

            // Does the company own such a train?

<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">            if (!company.getPortfolioModel().getTrainList().contains(train)) {</span>
<span class="nc" id="L1036">                errMsg =</span>
<span class="nc" id="L1037">                        LocalText.getText(&quot;CompanyDoesNotOwnTrain&quot;,</span>
<span class="nc" id="L1038">                                company.getId(), train.toText());</span>
                break;
            }

            break;
        }
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L1045">            DisplayBuffer.add(this,</span>
<span class="nc" id="L1046">                    LocalText.getText(&quot;CannotDiscardTrain&quot;, companyName,</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">                            (train != null ? train.toText() : &quot;?&quot;), errMsg));</span>
<span class="nc" id="L1048">            return false;</span>
        }

        /* End of validation, start of execution */

        // FIXME: if (action.isForced()) changeStack.linkToPreviousMoveSet();

        // Reset type of dual trains
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">        if (train.getCertType().getPotentialTrainTypes().size() &gt; 1) {</span>
<span class="nc" id="L1057">            train.setType(null);</span>
        }

<span class="fc" id="L1060">        train.discard();</span>

        // Check if any more companies must discard trains,
        // otherwise continue train buying
<span class="fc bfc" id="L1064" title="All 2 branches covered.">        if (!checkForExcessTrains()) {</span>
            // Trains may have been discarded by other players
<span class="fc" id="L1066">            playerManager.setCurrentPlayer(operatingCompany.value().getPresident());</span>
<span class="fc" id="L1067">            stepObject.set(GameDef.OrStep.BUY_TRAIN);</span>
        }

        // setPossibleActions();

<span class="fc" id="L1072">        return true;</span>
    }

    protected void setTrainsToDiscard() {

        // Scan the players in SR sequence, starting with the current player
<span class="pc bpc" id="L1078" title="1 of 2 branches missed.">        for (Player player : getRoot().getPlayerManager().getNextPlayers(true)) {</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">            if (excessTrainCompanies.containsKey(player)) {</span>
<span class="fc" id="L1080">                playerManager.setCurrentPlayer(player);</span>
<span class="fc" id="L1081">                List&lt;PublicCompany&gt; list = excessTrainCompanies.get(player);</span>
<span class="pc bpc" id="L1082" title="1 of 2 branches missed.">                for (PublicCompany comp : list) {</span>
<span class="fc" id="L1083">                    possibleActions.add(new DiscardTrain(comp,</span>
<span class="fc" id="L1084">                            comp.getPortfolioModel().getUniqueTrains(), true));</span>
                    // We handle one company at at time.
                    // We come back here until all excess trains have been
                    // discarded.
<span class="fc" id="L1088">                    return;</span>
                }
            }
<span class="fc" id="L1091">        }</span>
<span class="nc" id="L1092">    }</span>

    /*
     * ======================================= 3.3. PRIVATES (BUYING, SELLING,
     * CLOSING)=======================================
     */

    public boolean buyPrivate(BuyPrivate action) {

<span class="fc" id="L1101">        String errMsg = null;</span>
<span class="fc" id="L1102">        PublicCompany publicCompany = action.getCompany();</span>
<span class="fc" id="L1103">        String publicCompanyName = publicCompany.getId();</span>
<span class="fc" id="L1104">        PrivateCompany privateCompany = action.getPrivateCompany();</span>
<span class="fc" id="L1105">        String privateCompanyName = privateCompany.getId();</span>
<span class="fc" id="L1106">        int price = action.getPrice();</span>
<span class="fc" id="L1107">        Owner owner = null;</span>
<span class="fc" id="L1108">        Player player = null;</span>
        int upperPrice;
        int lowerPrice;

        // Dummy loop to enable a quick jump out.
        while (true) {

            // Checks
            // Does private exist?
<span class="fc" id="L1117">            if ((privateCompany =</span>
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">                    companyManager.getPrivateCompany(privateCompanyName)) == null) {</span>
<span class="nc" id="L1119">                errMsg =</span>
<span class="nc" id="L1120">                        LocalText.getText(&quot;PrivateDoesNotExist&quot;,</span>
                                privateCompanyName);
<span class="nc" id="L1122">                break;</span>
            }
            // Is private still open?
<span class="pc bpc" id="L1125" title="1 of 2 branches missed.">            if (privateCompany.isClosed()) {</span>
<span class="nc" id="L1126">                errMsg =</span>
<span class="nc" id="L1127">                        LocalText.getText(&quot;PrivateIsAlreadyClosed&quot;,</span>
                                privateCompanyName);
<span class="nc" id="L1129">                break;</span>
            }
            // Is private owned by a player?
<span class="fc" id="L1132">            owner = privateCompany.getOwner();</span>
<span class="pc bpc" id="L1133" title="1 of 2 branches missed.">            if (!(owner instanceof Player)) {</span>
<span class="nc" id="L1134">                errMsg =</span>
<span class="nc" id="L1135">                        LocalText.getText(&quot;PrivateIsNotOwnedByAPlayer&quot;,</span>
                                privateCompanyName);
<span class="nc" id="L1137">                break;</span>
            }
<span class="fc" id="L1139">            player = (Player) owner;</span>
<span class="fc" id="L1140">            upperPrice = privateCompany.getUpperPrice();</span>
<span class="fc" id="L1141">            lowerPrice = privateCompany.getLowerPrice();</span>

            // Is private buying allowed?
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">            if (!isPrivateSellingAllowed()) {</span>
<span class="nc" id="L1145">                errMsg = LocalText.getText(&quot;PrivateBuyingIsNotAllowed&quot;);</span>
<span class="nc" id="L1146">                break;</span>
            }

            // Price must be in the allowed range
<span class="pc bpc" id="L1150" title="2 of 4 branches missed.">            if (lowerPrice != PrivateCompany.NO_PRICE_LIMIT</span>
                &amp;&amp; price &lt; lowerPrice) {
<span class="nc" id="L1152">                errMsg =</span>
<span class="nc" id="L1153">                        LocalText.getText(&quot;PriceBelowLowerLimit&quot;,</span>
<span class="nc" id="L1154">                                Bank.format(this, price),</span>
<span class="nc" id="L1155">                                Bank.format(this, lowerPrice),</span>
                                privateCompanyName);
<span class="nc" id="L1157">                break;</span>
            }
<span class="pc bpc" id="L1159" title="2 of 4 branches missed.">            if (upperPrice != PrivateCompany.NO_PRICE_LIMIT</span>
                &amp;&amp; price &gt; upperPrice) {
<span class="nc" id="L1161">                errMsg =</span>
<span class="nc" id="L1162">                        LocalText.getText(&quot;PriceAboveUpperLimit&quot;,</span>
<span class="nc" id="L1163">                                Bank.format(this, price),</span>
<span class="nc" id="L1164">                                Bank.format(this, lowerPrice),</span>
                                privateCompanyName);
<span class="nc" id="L1166">                break;</span>
            }
            // Does the company have the money?
<span class="pc bpc" id="L1169" title="1 of 2 branches missed.">            if (price &gt; operatingCompany.value().getCash()) {</span>
<span class="nc" id="L1170">                errMsg =</span>
<span class="nc" id="L1171">                        LocalText.getText(&quot;NotEnoughMoney&quot;, publicCompanyName,</span>
<span class="nc" id="L1172">                                Bank.format(this,</span>
<span class="nc" id="L1173">                                        operatingCompany.value().getCash()),</span>
<span class="nc" id="L1174">                                Bank.format(this, price));</span>
                break;
            }
            break;
        }
<span class="pc bpc" id="L1179" title="1 of 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">            if (owner != null) {</span>
<span class="nc" id="L1181">                DisplayBuffer.add(this, LocalText.getText(</span>
                        &quot;CannotBuyPrivateFromFor&quot;, publicCompanyName,
<span class="nc" id="L1183">                        privateCompanyName, owner.getId(),</span>
<span class="nc" id="L1184">                        Bank.format(this, price), errMsg));</span>
            } else {
<span class="nc" id="L1186">                DisplayBuffer.add(this, LocalText.getText(</span>
                        &quot;CannotBuyPrivateFor&quot;, publicCompanyName,
<span class="nc" id="L1188">                        privateCompanyName, Bank.format(this, price), errMsg));</span>
            }
<span class="nc" id="L1190">            return false;</span>
        }

<span class="fc" id="L1193">        operatingCompany.value().buyPrivate(privateCompany, player, price);</span>

<span class="fc" id="L1195">        return true;</span>

    }

    protected boolean isPrivateSellingAllowed() {
<span class="fc" id="L1200">        return Phase.getCurrent(this).isPrivateSellingAllowed();</span>
    }

    protected int getPrivateMinimumPrice(PrivateCompany privComp) {
<span class="fc" id="L1204">        int minPrice = privComp.getLowerPrice();</span>
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">        if (minPrice == PrivateCompany.NO_PRICE_LIMIT) {</span>
<span class="nc" id="L1206">            minPrice = 0;</span>
        }
<span class="fc" id="L1208">        return minPrice;</span>
    }

    protected int getPrivateMaximumPrice(PrivateCompany privComp) {
<span class="fc" id="L1212">        int maxPrice = privComp.getUpperPrice();</span>
<span class="pc bpc" id="L1213" title="1 of 2 branches missed.">        if (maxPrice == PrivateCompany.NO_PRICE_LIMIT) {</span>
<span class="nc" id="L1214">            maxPrice = operatingCompany.value().getCash();</span>
        }
<span class="fc" id="L1216">        return maxPrice;</span>
    }

    protected boolean maySellPrivate(Player player) {
<span class="fc" id="L1220">        return true;</span>
    }

    protected boolean executeClosePrivate(ClosePrivate action) {

<span class="nc" id="L1225">        PrivateCompany priv = action.getPrivateCompany();</span>

<span class="nc" id="L1227">        log.debug(&quot;Executed close private action for private {}&quot;, priv.getId());</span>

<span class="nc" id="L1229">        String errMsg = null;</span>

<span class="nc bnc" id="L1231" title="All 2 branches missed.">        if (priv.isClosed())</span>
<span class="nc" id="L1232">            errMsg = LocalText.getText(&quot;PrivateAlreadyClosed&quot;, priv.getId());</span>

<span class="nc bnc" id="L1234" title="All 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L1235">            DisplayBuffer.add(this, errMsg);</span>
<span class="nc" id="L1236">            return false;</span>
        }

<span class="nc" id="L1239">        priv.setClosed();</span>

<span class="nc" id="L1241">        return true;</span>
    }

    /*
     * ======================================= 3.4. DESTINATIONS
     * =======================================
     */

    /**
     * Stub for applying any follow-up actions when a company reaches it
     * destinations. Default version: no actions.
     *
     * @param company
     */
    protected void reachDestination(PublicCompany company) {

<span class="nc" id="L1257">    }</span>

    public boolean reachDestinations(ReachDestinations action) {

<span class="fc" id="L1261">        List&lt;PublicCompany&gt; destinedCompanies = action.getReachedCompanies();</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">        if (destinedCompanies != null) {</span>
<span class="fc bfc" id="L1263" title="All 2 branches covered.">            for (PublicCompany company : destinedCompanies) {</span>
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">                if (company.hasDestination()</span>
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">                    &amp;&amp; !company.hasReachedDestination()) {</span>
<span class="fc" id="L1266">                    company.setReachedDestination(true);</span>
<span class="fc" id="L1267">                    ReportBuffer.add(this, LocalText.getText(</span>
<span class="fc" id="L1268">                            &quot;DestinationReached&quot;, company.getId(),</span>
<span class="fc" id="L1269">                            company.getDestinationHex().getId()));</span>
                    // Process any consequences of reaching a destination
                    // (default none)
<span class="fc" id="L1272">                    reachDestination(company);</span>
                }
<span class="fc" id="L1274">            }</span>
        }
<span class="fc" id="L1276">        return true;</span>
    }

    /**
     * This is currently a stub, as it is unclear if there is a common rule for
     * setting destination reaching options. See OperatingRound_1856 for a first
     * implementation of such rules.
     */
    protected void setDestinationActions() {

<span class="fc" id="L1286">    }</span>

    /*
     * ======================================= 3.5. LOANS
     * =======================================
     */

    protected boolean takeLoans(TakeLoans action) {

<span class="fc" id="L1295">        String errMsg = validateTakeLoans(action);</span>

<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L1298">            DisplayBuffer.add(this, LocalText.getText(&quot;CannotTakeLoans&quot;,</span>
<span class="nc" id="L1299">                    action.getCompanyName(), action.getNumberTaken(),</span>
<span class="nc" id="L1300">                    Bank.format(this, action.getPrice()), errMsg));</span>

<span class="nc" id="L1302">            return false;</span>
        }

<span class="fc" id="L1305">        executeTakeLoans(action);</span>

<span class="fc" id="L1307">        return true;</span>

    }

    protected String validateTakeLoans(TakeLoans action) {

<span class="fc" id="L1313">        String errMsg = null;</span>
<span class="fc" id="L1314">        PublicCompany company = action.getCompany();</span>
<span class="fc" id="L1315">        String companyName = company.getId();</span>
<span class="fc" id="L1316">        int number = action.getNumberTaken();</span>

        // Dummy loop to enable a quick jump out.
        while (true) {

            // Checks
            // Is company operating?
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">            if (company != operatingCompany.value()) {</span>
<span class="nc" id="L1324">                errMsg =</span>
<span class="nc" id="L1325">                        LocalText.getText(&quot;WrongCompany&quot;, companyName,</span>
<span class="nc" id="L1326">                                action.getCompanyName());</span>
<span class="nc" id="L1327">                break;</span>
            }
            // Does company allow any loans?
<span class="pc bpc" id="L1330" title="1 of 2 branches missed.">            if (company.getMaxNumberOfLoans() == 0) {</span>
<span class="nc" id="L1331">                errMsg = LocalText.getText(&quot;LoansNotAllowed&quot;, companyName);</span>
<span class="nc" id="L1332">                break;</span>
            }
            // Does the company exceed the maximum number of loans?
<span class="pc bpc" id="L1335" title="1 of 2 branches missed.">            if (company.getMaxNumberOfLoans() &gt; 0</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">                &amp;&amp; company.getCurrentNumberOfLoans() + number &gt; company.getMaxNumberOfLoans()) {</span>
<span class="nc" id="L1337">                errMsg =</span>
<span class="nc" id="L1338">                        LocalText.getText(&quot;MoreLoansNotAllowed&quot;, companyName,</span>
<span class="nc" id="L1339">                                company.getMaxNumberOfLoans());</span>
                break;
            }
            break;
        }

<span class="fc" id="L1345">        return errMsg;</span>
    }

    protected void executeTakeLoans(TakeLoans action) {

<span class="fc" id="L1350">        int number = action.getNumberTaken();</span>
<span class="fc" id="L1351">        int amount = calculateLoanAmount(number);</span>
<span class="fc" id="L1352">        operatingCompany.value().addLoans(number);</span>
<span class="fc" id="L1353">        Currency.fromBank(amount, operatingCompany.value());</span>
<span class="pc bpc" id="L1354" title="1 of 2 branches missed.">        if (number == 1) {</span>
<span class="fc" id="L1355">            ReportBuffer.add(this, LocalText.getText(&quot;CompanyTakesLoan&quot;,</span>
<span class="fc" id="L1356">                    operatingCompany.value().getId(), Bank.format(this,</span>
<span class="fc" id="L1357">                            operatingCompany.value().getValuePerLoan()),</span>
<span class="fc" id="L1358">                    Bank.format(this, amount)));</span>
        } else {
<span class="nc" id="L1360">            ReportBuffer.add(this, LocalText.getText(&quot;CompanyTakesLoans&quot;,</span>
<span class="nc" id="L1361">                    operatingCompany.value().getId(), number, Bank.format(this,</span>
<span class="nc" id="L1362">                            operatingCompany.value().getValuePerLoan()),</span>
<span class="nc" id="L1363">                    Bank.format(this, amount)));</span>
        }

<span class="pc bpc" id="L1366" title="1 of 2 branches missed.">        if (operatingCompany.value().getMaxLoansPerRound() &gt; 0) {</span>
<span class="fc" id="L1367">            int oldLoansThisRound = 0;</span>
<span class="fc bfc" id="L1368" title="All 2 branches covered.">            if (loansThisRound == null) {</span>
<span class="fc" id="L1369">                loansThisRound = HashMapState.create(this, &quot;loansThisRound&quot;);</span>
<span class="pc bpc" id="L1370" title="1 of 2 branches missed.">            } else if (loansThisRound.containsKey(operatingCompany.value())) {</span>
<span class="nc" id="L1371">                oldLoansThisRound =</span>
<span class="nc" id="L1372">                        loansThisRound.get(operatingCompany.value());</span>
            }
<span class="fc" id="L1374">            loansThisRound.put(operatingCompany.value(), oldLoansThisRound + number);</span>
        }
<span class="fc" id="L1376">    }</span>

    protected boolean repayLoans(RepayLoans action) {

<span class="fc" id="L1380">        String errMsg = validateRepayLoans(action);</span>

<span class="pc bpc" id="L1382" title="1 of 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L1383">            DisplayBuffer.add(this, LocalText.getText(&quot;CannotRepayLoans&quot;,</span>
<span class="nc" id="L1384">                    action.getCompanyName(), action.getNumberRepaid(),</span>
<span class="nc" id="L1385">                    Bank.format(this, action.getPrice()), errMsg));</span>

<span class="nc" id="L1387">            return false;</span>
        }

<span class="fc" id="L1390">        int repayment =</span>
<span class="fc" id="L1391">                action.getNumberRepaid()</span>
<span class="fc" id="L1392">                        * operatingCompany.value().getValuePerLoan();</span>
<span class="pc bpc" id="L1393" title="1 of 4 branches missed.">        if (repayment &gt; 0 &amp;&amp; repayment &gt; operatingCompany.value().getCash()) {</span>
            // President must contribute
<span class="fc" id="L1395">            int remainder = repayment - operatingCompany.value().getCash();</span>
<span class="fc" id="L1396">            Player president = operatingCompany.value().getPresident();</span>
<span class="fc" id="L1397">            int presCash = president.getCashValue();</span>
<span class="pc bpc" id="L1398" title="1 of 2 branches missed.">            if (remainder &gt; presCash) {</span>
                // Start a share selling round
<span class="nc" id="L1400">                int cashToBeRaisedByPresident = remainder - presCash;</span>
<span class="nc" id="L1401">                log.info(&quot;A share selling round must be started as the president cannot pay ${} loan repayment&quot;, remainder);</span>
<span class="nc" id="L1402">                log.info(&quot;President has ${}, so ${} must be added&quot;, presCash, cashToBeRaisedByPresident);</span>
<span class="nc" id="L1403">                savedAction = action;</span>

<span class="nc" id="L1405">                gameManager.startShareSellingRound(</span>
<span class="nc" id="L1406">                        operatingCompany.value().getPresident(),</span>
<span class="nc" id="L1407">                        cashToBeRaisedByPresident, operatingCompany.value(),</span>
                        false);
<span class="nc" id="L1409">                return true;</span>
            }
        }

<span class="pc bpc" id="L1413" title="1 of 2 branches missed.">        if (repayment &gt; 0) executeRepayLoans(action);</span>

<span class="fc" id="L1415">        return true;</span>
    }

    protected String validateRepayLoans(RepayLoans action) {

<span class="fc" id="L1420">        String errMsg = null;</span>

<span class="fc" id="L1422">        return errMsg;</span>
    }

    protected void executeRepayLoans(RepayLoans action) {

<span class="fc" id="L1427">        int number = action.getNumberRepaid();</span>
        int payment;
<span class="fc" id="L1429">        int remainder = 0;</span>

<span class="fc" id="L1431">        operatingCompany.value().addLoans(-number);</span>
<span class="fc" id="L1432">        int amount = number * operatingCompany.value().getValuePerLoan();</span>
<span class="fc" id="L1433">        payment = Math.min(amount, operatingCompany.value().getCash());</span>
<span class="fc" id="L1434">        remainder = amount - payment;</span>
<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">        if (payment &gt; 0) {</span>
<span class="fc" id="L1436">            String paymentText =</span>
<span class="fc" id="L1437">                    Currency.toBank(operatingCompany.value(), payment);</span>
<span class="fc" id="L1438">            ReportBuffer.add(this, LocalText.getText(</span>
                    &quot;CompanyRepaysLoans&quot;,
<span class="fc" id="L1440">                    operatingCompany.value().getId(),</span>
                    paymentText,
<span class="fc" id="L1442">                    bank.getCurrency().format(amount), // TODO: Do this nicer</span>
<span class="fc" id="L1443">                    number,</span>
<span class="fc" id="L1444">                    bank.getCurrency().format(</span>
<span class="fc" id="L1445">                            operatingCompany.value().getValuePerLoan()))); // TODO:</span>
                                                                           // Do
                                                                           // this
                                                                           // nicer
        }
<span class="fc bfc" id="L1450" title="All 2 branches covered.">        if (remainder &gt; 0) {</span>
<span class="fc" id="L1451">            Player president = operatingCompany.value().getPresident();</span>
<span class="pc bpc" id="L1452" title="1 of 2 branches missed.">            if (president.getCashValue() &gt;= remainder) {</span>
<span class="fc" id="L1453">                payment = remainder;</span>
<span class="fc" id="L1454">                String paymentText = Currency.toBank(president, payment);</span>
<span class="fc" id="L1455">                ReportBuffer.add(this, LocalText.getText(</span>
                        &quot;CompanyRepaysLoansWithPresCash&quot;,
<span class="fc" id="L1457">                        operatingCompany.value().getId(),</span>
                        paymentText,
<span class="fc" id="L1459">                        bank.getCurrency().format(amount), // TODO: Do this</span>
                                                           // nicer
<span class="fc" id="L1461">                        number,</span>
<span class="fc" id="L1462">                        bank.getCurrency().format(</span>
<span class="fc" id="L1463">                                operatingCompany.value().getValuePerLoan()), // TODO:</span>
                                                                             // Do
                                                                             // this
                                                                             // nicer
<span class="fc" id="L1467">                        president.getId()));</span>
            }
        }
<span class="fc" id="L1470">    }</span>

    protected int calculateLoanAmount(int numberOfLoans) {
<span class="fc" id="L1473">        return numberOfLoans * operatingCompany.value().getValuePerLoan();</span>
    }

    // TODO UNUSED??
    // public void payLoanInterest () {
    // int amount = operatingCompany.value().getCurrentLoanValue()
    // * operatingCompany.value().getLoanInterestPct() / 100;
    //
    // MoneyModel.cashMove (operatingCompany.value(), bank, amount);
    // DisplayBuffer.add(this, LocalText.getText(&quot;CompanyPaysLoanInterest&quot;,
    // operatingCompany.value().getId(),
    // Currency.format(this, amount),
    // operatingCompany.value().getLoanInterestPct(),
    // operatingCompany.value().getCurrentNumberOfLoans(),
    // Currency.format(this, operatingCompany.value().getValuePerLoan())));
    // }

    /*
     * ======================================= 3.6. RIGHTS
     * =======================================
     */

    protected boolean buyRight(UseSpecialProperty action) {

<span class="fc" id="L1497">        String errMsg = null;</span>
<span class="fc" id="L1498">        String rightName = &quot;&quot;;</span>
<span class="fc" id="L1499">        String rightValue = &quot;&quot;;</span>
<span class="fc" id="L1500">        SpecialRight right = null;</span>
<span class="fc" id="L1501">        int cost = 0;</span>

<span class="fc" id="L1503">        SpecialProperty sp = action.getSpecialProperty();</span>

        while (true) {
<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">            if (!(sp instanceof SpecialRight)) {</span>
<span class="nc" id="L1507">                errMsg = &quot;Wrong right property class: &quot; + sp.toString();</span>
<span class="nc" id="L1508">                break;</span>
            }
<span class="fc" id="L1510">            right = (SpecialRight) sp;</span>
<span class="fc" id="L1511">            rightName = right.getName();</span>
<span class="fc" id="L1512">            rightValue = right.getValue();</span>
<span class="fc" id="L1513">            cost = right.getCost();</span>

<span class="pc bpc" id="L1515" title="2 of 4 branches missed.">            if (cost &gt; 0 &amp;&amp; cost &gt; operatingCompany.value().getCash()) {</span>
<span class="nc" id="L1516">                errMsg = LocalText.getText(&quot;NoMoney&quot;);</span>
                break;
            }
            break;
        }

<span class="pc bpc" id="L1522" title="1 of 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L1523">            DisplayBuffer.add(this, LocalText.getText(&quot;CannotBuyRight&quot;,</span>
<span class="nc" id="L1524">                    action.getCompanyName(), rightName,</span>
<span class="nc" id="L1525">                    bank.getCurrency().format(cost), // TODO: Do this nicer</span>
                    errMsg));

<span class="nc" id="L1528">            return false;</span>
        }

<span class="fc" id="L1531">        operatingCompany.value().setRight(right);</span>
        // TODO: Creates a zero cost transfer if cost == 0
<span class="fc" id="L1533">        String costText = Currency.toBank(operatingCompany.value(), cost);</span>

<span class="fc" id="L1535">        ReportBuffer.add(this, LocalText.getText(&quot;BuysRight&quot;,</span>
<span class="fc" id="L1536">                operatingCompany.value().getId(), rightName, costText));</span>

<span class="fc" id="L1538">        sp.setExercised();</span>

<span class="fc" id="L1540">        return true;</span>
    }

    /*
     * ======================================= 4. LAYING TILES
     * =======================================
     */

    public boolean layTile(LayTile action) {

<span class="fc" id="L1550">        String errMsg = null;</span>
<span class="fc" id="L1551">        int cost = 0;</span>
<span class="fc" id="L1552">        SpecialTileLay stl = null;</span>
<span class="fc" id="L1553">        boolean extra = false;</span>

<span class="fc" id="L1555">        PublicCompany company = action.getCompany();</span>
<span class="fc" id="L1556">        String companyName = company.getId();</span>
<span class="fc" id="L1557">        Tile tile = action.getLaidTile();</span>
<span class="fc" id="L1558">        MapHex hex = action.getChosenHex();</span>
<span class="fc" id="L1559">        int orientation = action.getOrientation();</span>

        // Dummy loop to enable a quick jump out.
        while (true) {
            // Checks
            // Must be correct company.
<span class="pc bpc" id="L1565" title="1 of 2 branches missed.">            if (!companyName.equals(operatingCompany.value().getId())) {</span>
<span class="nc" id="L1566">                errMsg =</span>
<span class="nc" id="L1567">                        LocalText.getText(&quot;WrongCompany&quot;, companyName,</span>
<span class="nc" id="L1568">                                operatingCompany.value().getId());</span>
<span class="nc" id="L1569">                break;</span>
            }
            // Must be correct step
<span class="pc bpc" id="L1572" title="1 of 2 branches missed.">            if (getStep() != GameDef.OrStep.LAY_TRACK) {</span>
<span class="nc" id="L1573">                errMsg = LocalText.getText(&quot;WrongActionNoTileLay&quot;);</span>
<span class="nc" id="L1574">                break;</span>
            }

<span class="pc bpc" id="L1577" title="1 of 2 branches missed.">            if (tile == null) break;</span>

<span class="pc bpc" id="L1579" title="1 of 2 branches missed.">            if (!Phase.getCurrent(this).isTileColourAllowed(tile.getColourText())) {</span>
<span class="nc" id="L1580">                errMsg =</span>
<span class="nc" id="L1581">                        LocalText.getText(&quot;TileNotYetAvailable&quot;, tile.toText());</span>
<span class="nc" id="L1582">                break;</span>
            }
<span class="pc bpc" id="L1584" title="1 of 2 branches missed.">            if (tile.getFreeCount() == 0) {</span>
<span class="nc" id="L1585">                errMsg = LocalText.getText(&quot;TileNotAvailable&quot;, tile.toText());</span>
<span class="nc" id="L1586">                break;</span>
            }

            /*
             * Check if the current tile is allowed via the LayTile allowance.
             * (currently the set if tiles is always null, which means that this
             * check is redundant. This may change in the future.
             */
<span class="pc bpc" id="L1594" title="1 of 2 branches missed.">            if (action != null) {</span>
<span class="fc" id="L1595">                List&lt;Tile&gt; tiles = action.getTiles();</span>
<span class="pc bpc" id="L1596" title="5 of 6 branches missed.">                if (tiles != null &amp;&amp; !tiles.isEmpty() &amp;&amp; !tiles.contains(tile)) {</span>
<span class="nc" id="L1597">                    errMsg =</span>
<span class="nc" id="L1598">                            LocalText.getText(&quot;TileMayNotBeLaidInHex&quot;,</span>
<span class="nc" id="L1599">                                    tile.toText(), hex.getId());</span>
<span class="nc" id="L1600">                    break;</span>
                }
<span class="fc" id="L1602">                stl = action.getSpecialProperty();</span>
<span class="fc bfc" id="L1603" title="All 2 branches covered.">                if (stl != null) extra = stl.isExtra();</span>
            }

            /*
             * If this counts as a normal tile lay, check if the allowed number
             * of normal tile lays is not exceeded.
             */
<span class="pc bpc" id="L1610" title="1 of 4 branches missed.">            if (!extra &amp;&amp; !validateNormalTileLay(tile)) {</span>
<span class="nc" id="L1611">                errMsg =</span>
<span class="nc" id="L1612">                        LocalText.getText(&quot;NumberOfNormalTileLaysExceeded&quot;,</span>
<span class="nc" id="L1613">                                tile.getColourText());</span>
<span class="nc" id="L1614">                break;</span>
            }

            // Sort out cost
<span class="fc bfc" id="L1618" title="All 4 branches covered.">            if (stl != null &amp;&amp; stl.isFree()) {</span>
<span class="fc" id="L1619">                cost = 0;</span>
            } else {
<span class="fc" id="L1621">                cost = hex.getTileCost();</span>
<span class="fc bfc" id="L1622" title="All 2 branches covered.">                if (stl != null) {</span>
<span class="fc" id="L1623">                    cost = Math.max(0, cost-stl.getDiscount());</span>
                }
            }

            // Amount must be non-negative multiple of 10
<span class="pc bpc" id="L1628" title="1 of 2 branches missed.">            if (cost &lt; 0) {</span>
<span class="nc" id="L1629">                errMsg =</span>
<span class="nc" id="L1630">                        LocalText.getText(&quot;NegativeAmountNotAllowed&quot;,</span>
<span class="nc" id="L1631">                                Bank.format(this, cost));</span>
<span class="nc" id="L1632">                break;</span>
            }
<span class="pc bpc" id="L1634" title="1 of 2 branches missed.">            if (cost % 10 != 0) {</span>
<span class="nc" id="L1635">                errMsg =</span>
<span class="nc" id="L1636">                        LocalText.getText(&quot;AmountMustBeMultipleOf10&quot;,</span>
<span class="nc" id="L1637">                                Bank.format(this, cost));</span>
<span class="nc" id="L1638">                break;</span>
            }
            // Does the company have the money?
<span class="pc bpc" id="L1641" title="1 of 2 branches missed.">            if (cost &gt; operatingCompany.value().getCash()) {</span>
<span class="nc" id="L1642">                errMsg =</span>
<span class="nc" id="L1643">                        LocalText.getText(&quot;NotEnoughMoney&quot;, companyName,</span>
<span class="nc" id="L1644">                                Bank.format(this,</span>
<span class="nc" id="L1645">                                        operatingCompany.value().getCash()),</span>
<span class="nc" id="L1646">                                Bank.format(this, cost));</span>
                break;
            }
            break;
        }
<span class="pc bpc" id="L1651" title="1 of 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L1652">            DisplayBuffer.add(this, LocalText.getText(&quot;CannotLayTileOn&quot;,</span>
<span class="nc" id="L1653">                    companyName, tile.toText(), hex.getId(),</span>
<span class="nc" id="L1654">                    Bank.format(this, cost), errMsg));</span>
<span class="nc" id="L1655">            return false;</span>
        }

        /* End of validation, start of execution */

<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">        if (tile != null) {</span>
<span class="fc" id="L1661">            String costText = null;</span>
<span class="fc bfc" id="L1662" title="All 2 branches covered.">            if (cost &gt; 0) {</span>
<span class="fc" id="L1663">                costText = Currency.toBank(operatingCompany.value(), cost);</span>
            }
<span class="fc" id="L1665">            operatingCompany.value().layTile(hex, tile, orientation, cost);</span>

<span class="fc bfc" id="L1667" title="All 2 branches covered.">            if (costText == null) {</span>
<span class="fc" id="L1668">                ReportBuffer.add(</span>
                        this,
<span class="fc" id="L1670">                        LocalText.getText(</span>
                                &quot;LaysTileAt&quot;,
                                companyName,
<span class="fc" id="L1673">                                tile.toText(),</span>
<span class="fc" id="L1674">                                hex.getId(),</span>
<span class="fc" id="L1675">                                hex.getOrientationName(HexSide.get(orientation))));</span>
            } else {
<span class="fc" id="L1677">                ReportBuffer.add(this, LocalText.getText(&quot;LaysTileAtFor&quot;,</span>
<span class="fc" id="L1678">                        companyName, tile.toText(), hex.getId(),</span>
<span class="fc" id="L1679">                        hex.getOrientationName(HexSide.get(orientation)),</span>
                        costText));
            }
<span class="fc" id="L1682">            hex.upgrade(action);</span>

            // Was a special property used?
<span class="fc bfc" id="L1685" title="All 2 branches covered.">            if (stl != null) {</span>
<span class="fc" id="L1686">                stl.setExercised();</span>
                // currentSpecialTileLays.remove(action);
<span class="fc bfc" id="L1688" title="All 2 branches covered.">                log.debug(&quot;This was a special tile lay, {} extra&quot;, extra ? &quot;&quot; : &quot; not&quot;);</span>

            }
<span class="fc bfc" id="L1691" title="All 2 branches covered.">            if (!extra) {</span>
<span class="fc" id="L1692">                log.debug(&quot;This was a normal tile lay&quot;);</span>
<span class="fc" id="L1693">                registerNormalTileLay(tile);</span>
            }
        }

<span class="pc bpc" id="L1697" title="1 of 4 branches missed.">        if (tile == null || !areTileLaysPossible()) {</span>
<span class="fc" id="L1698">            nextStep();</span>
        }

<span class="fc" id="L1701">        return true;</span>
    }

    public boolean layTileCorrection(LayTile action) {

<span class="nc" id="L1706">        Tile tile = action.getLaidTile();</span>
<span class="nc" id="L1707">        MapHex hex = action.getChosenHex();</span>
<span class="nc" id="L1708">        int orientation = action.getOrientation();</span>

<span class="nc" id="L1710">        String errMsg = null;</span>
        // tiles have external id defined
<span class="nc bnc" id="L1712" title="All 2 branches missed.">        if (tile != null</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">                &amp;&amp; tile != hex.getCurrentTile()</span>
<span class="nc bnc" id="L1714" title="All 2 branches missed.">                &amp;&amp; tile.getFreeCount() == 0) {</span>
<span class="nc" id="L1715">            errMsg =</span>
<span class="nc" id="L1716">                    LocalText.getText(&quot;TileNotAvailable&quot;,</span>
<span class="nc" id="L1717">                            tile.toText());</span>
        }

<span class="nc bnc" id="L1720" title="All 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L1721">            DisplayBuffer.add(this, LocalText.getText(&quot;CorrectMapCannotLayTile&quot;,</span>
<span class="nc" id="L1722">                    tile.toText(),</span>
<span class="nc" id="L1723">                    hex.getId(),</span>
                    errMsg ));
            ;
<span class="nc" id="L1726">            return false;</span>
        }

        // lays tile
<span class="nc" id="L1730">        hex.upgrade(action);</span>

<span class="nc" id="L1732">        String msg = LocalText.getText(&quot;CorrectMapLaysTileAt&quot;,</span>
<span class="nc" id="L1733">                tile.toText(), hex.getId(), hex.getOrientationName(orientation));</span>
<span class="nc" id="L1734">        ReportBuffer.add(this, msg);</span>
<span class="nc" id="L1735">        return true;</span>
    }

    protected boolean validateNormalTileLay(Tile tile) {
<span class="fc" id="L1739">        return checkNormalTileLay(tile, false);</span>
    }

    protected void registerNormalTileLay(Tile tile) {
<span class="fc" id="L1743">        checkNormalTileLay(tile, true);</span>
<span class="fc" id="L1744">    }</span>

    protected boolean checkNormalTileLay(Tile tile, boolean update) {

        // Unspecified tile (e.g. 1889 D private, which is free on mountains)
<span class="fc bfc" id="L1749" title="All 2 branches covered.">        if (tile == null) {</span>
<span class="fc bfc" id="L1750" title="All 2 branches covered.">            return !tileLaysPerColour.isEmpty();</span>
        }

<span class="fc" id="L1753">        String colour = tile.getColourText();</span>
<span class="fc" id="L1754">        Integer oldAllowedNumberObject = tileLaysPerColour.get(colour);</span>

<span class="fc bfc" id="L1756" title="All 2 branches covered.">        if (oldAllowedNumberObject == null) return false;</span>

<span class="fc" id="L1758">        int oldAllowedNumber = oldAllowedNumberObject;</span>
<span class="pc bpc" id="L1759" title="1 of 2 branches missed.">        if (oldAllowedNumber &lt;= 0) return false;</span>

<span class="fc bfc" id="L1761" title="All 2 branches covered.">        if (update) updateAllowedTileColours(colour, oldAllowedNumber);</span>
<span class="fc" id="L1762">        return true;</span>
    }

    /*
     * We will assume that in all cases the following assertions hold: 1. If the
     * allowed number for the colour of the just laid tile reaches zero, all
     * normal tile lays have been consumed. 2. If any colour is laid, no
     * different colours may be laid. THIS MAY NOT BE TRUE FOR ALL GAMES!
     */

    protected void updateAllowedTileColours(String colour, int oldAllowedNumber) {

<span class="fc bfc" id="L1774" title="All 2 branches covered.">        if (oldAllowedNumber &lt;= 1) {</span>
<span class="fc" id="L1775">            tileLaysPerColour.clear();</span>
<span class="fc" id="L1776">            log.debug(&quot;No more normal tile lays allowed&quot;);</span>
            // currentNormalTileLays.clear();// Shouldn't be needed anymore ??
        } else {
<span class="fc" id="L1779">            List&lt;String&gt; coloursToRemove = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L1780" title="All 2 branches covered.">            for (String key : tileLaysPerColour.viewKeySet()) {</span>
<span class="fc bfc" id="L1781" title="All 2 branches covered.">                if (colour.equals(key)) {</span>
<span class="fc" id="L1782">                    tileLaysPerColour.put(key, oldAllowedNumber - 1);</span>
                } else {
<span class="fc" id="L1784">                    coloursToRemove.add(key);</span>
                }
<span class="fc" id="L1786">            }</span>
            // Two-step removal to prevent ConcurrentModificatioonException.
<span class="fc bfc" id="L1788" title="All 2 branches covered.">            for (String key : coloursToRemove) {</span>
<span class="fc" id="L1789">                tileLaysPerColour.remove(key);</span>
<span class="fc" id="L1790">            }</span>
<span class="fc" id="L1791">            log.debug(&quot;{} additional {} tile lays allowed; no other colours&quot;, oldAllowedNumber - 1, colour);</span>
        }
<span class="fc" id="L1793">    }</span>

    /**
     * Create a List of allowed normal tile lays (see LayTile class). This
     * method should be called only once per company turn in an OR: at the start
     * of the tile laying step.
     */
    protected void initNormalTileLays() {

        // duplicate the phase colours
<span class="fc" id="L1803">        Map&lt;String, Integer&gt; newTileColours = new HashMap&lt;String, Integer&gt;();</span>
<span class="fc bfc" id="L1804" title="All 2 branches covered.">        for (String colour : Phase.getCurrent(this).getTileColours()) {</span>
<span class="fc" id="L1805">            int allowedNumber =</span>
<span class="fc" id="L1806">                    operatingCompany.value().getNumberOfTileLays(colour);</span>
            // Replace the null map value with the allowed number of lays
<span class="fc" id="L1808">            newTileColours.put(colour, allowedNumber);</span>
<span class="fc" id="L1809">        }</span>
        // store to state
<span class="fc" id="L1811">        tileLaysPerColour.initFromMap(newTileColours);</span>
<span class="fc" id="L1812">    }</span>

    protected List&lt;LayTile&gt; getNormalTileLays(boolean display) {

        /* Normal tile lays */
<span class="fc" id="L1817">        List&lt;LayTile&gt; currentNormalTileLays = new ArrayList&lt;LayTile&gt;();</span>

        // Check which colours can still be laid
<span class="fc" id="L1820">        Map&lt;String, Integer&gt; remainingTileLaysPerColour =</span>
                new HashMap&lt;String, Integer&gt;();

<span class="fc" id="L1823">        int lays = 0;</span>
<span class="fc bfc" id="L1824" title="All 2 branches covered.">        for (String colourName : tileLaysPerColour.viewKeySet()) {</span>
<span class="fc" id="L1825">            lays = tileLaysPerColour.get(colourName);</span>
<span class="fc bfc" id="L1826" title="All 2 branches covered.">            if (lays != 0) {</span>
<span class="fc" id="L1827">                remainingTileLaysPerColour.put(colourName, lays);</span>
            }
<span class="fc" id="L1829">        }</span>
<span class="fc bfc" id="L1830" title="All 2 branches covered.">        if (!remainingTileLaysPerColour.isEmpty()) {</span>
<span class="fc" id="L1831">            currentNormalTileLays.add(new LayTile(remainingTileLaysPerColour));</span>
        }

        // NOTE: in a later stage tile lays will be specified per hex or set of
        // hexes.

<span class="pc bpc" id="L1837" title="1 of 2 branches missed.">        if (display) {</span>
<span class="fc" id="L1838">            int size = currentNormalTileLays.size();</span>
<span class="fc bfc" id="L1839" title="All 2 branches covered.">            if (size == 0) {</span>
<span class="fc" id="L1840">                log.debug(&quot;No normal tile lays&quot;);</span>
            } else {
<span class="fc bfc" id="L1842" title="All 2 branches covered.">                for (LayTile tileLay : currentNormalTileLays) {</span>
<span class="fc" id="L1843">                    log.debug(&quot;Normal tile lay: {}&quot;, tileLay.toString());</span>
<span class="fc" id="L1844">                }</span>
            }
        }
<span class="fc" id="L1847">        return currentNormalTileLays;</span>
    }

    /**
     * Create a List of allowed special tile lays (see LayTile class). This
     * method should be called before each user action in the tile laying step.
     */
    protected List&lt;LayTile&gt; getSpecialTileLays(boolean display) {

        /* Special-property tile lays */
<span class="fc" id="L1857">        List&lt;LayTile&gt; currentSpecialTileLays = new ArrayList&lt;LayTile&gt;();</span>

<span class="fc bfc" id="L1859" title="All 2 branches covered.">        if (operatingCompany.value().canUseSpecialProperties()) {</span>

<span class="fc bfc" id="L1861" title="All 2 branches covered.">            for (SpecialTileLay stl : getSpecialProperties(SpecialTileLay.class)) {</span>

<span class="fc" id="L1863">                LayTile layTile = new LayTile(stl);</span>
<span class="fc bfc" id="L1864" title="All 2 branches covered.">                if (validateSpecialTileLay(layTile))</span>
<span class="fc" id="L1865">                    currentSpecialTileLays.add(layTile);</span>
<span class="fc" id="L1866">            }</span>
        }

<span class="fc bfc" id="L1869" title="All 2 branches covered.">        if (display) {</span>
<span class="fc" id="L1870">            int size = currentSpecialTileLays.size();</span>
<span class="fc bfc" id="L1871" title="All 2 branches covered.">            if (size == 0) {</span>
<span class="fc" id="L1872">                log.debug(&quot;No special tile lays&quot;);</span>
            } else {
<span class="fc bfc" id="L1874" title="All 2 branches covered.">                for (LayTile tileLay : currentSpecialTileLays) {</span>
<span class="fc" id="L1875">                    log.debug(&quot;Special tile lay: {}&quot;, tileLay.toString());</span>
<span class="fc" id="L1876">                }</span>
            }
        }

<span class="fc" id="L1880">        return currentSpecialTileLays;</span>
    }

    /**
     * Prevalidate a special tile lay. &lt;p&gt;During prevalidation, the action may
     * be updated (i.e. restricted). TODO &lt;p&gt;Note: The name of this method may
     * suggest that it can also be used for postvalidation (i.e. to validate the
     * action after the player has selected it). This is not yet the case, but
     * it is conceivable that this method can be extended to cover
     * postvalidation as well. Postvalidation is really a different process,
     * which in this context has not yet been considered in detail.
     *
     * @param layTile A LayTile object embedding a SpecialTileLay property. Any
     * other LayTile objects are rejected. The object may be changed by this
     * method.
     * @return TRUE if allowed.
     */
    protected boolean validateSpecialTileLay(LayTile layTile) {

<span class="pc bpc" id="L1899" title="1 of 2 branches missed.">        if (layTile == null) return false;</span>

<span class="fc" id="L1901">        SpecialProperty sp = layTile.getSpecialProperty();</span>
<span class="pc bpc" id="L1902" title="2 of 4 branches missed.">        if (sp == null || !(sp instanceof SpecialTileLay)) return false;</span>

<span class="fc" id="L1904">        SpecialTileLay stl = (SpecialTileLay) sp;</span>

<span class="fc bfc" id="L1906" title="All 2 branches covered.">        if (!stl.isExtra()</span>
        // If the special tile lay is not extra, it is only allowed if
        // normal tile lays are also (still) allowed
<span class="fc bfc" id="L1909" title="All 2 branches covered.">            &amp;&amp; !checkNormalTileLay(stl.getTile(), false)) return false;</span>

<span class="fc" id="L1911">        Tile tile = stl.getTile();</span>

        // What colours can be laid in the current phase?
<span class="fc" id="L1914">        List&lt;String&gt; phaseColours = Phase.getCurrent(this).getTileColours();</span>

        // Which tile colour(s) are specified explicitly...
<span class="fc" id="L1917">        String[] stlc = stl.getTileColours();</span>
<span class="pc bpc" id="L1918" title="1 of 6 branches missed.">        if ((stlc == null || stlc.length == 0) &amp;&amp; tile != null) {</span>
            // ... or implicitly
<span class="fc" id="L1920">            stlc = new String[] { tile.getColourText() };</span>
        }

        // Which of the specified tile colours can really be laid now?
        List&lt;String&gt; layableColours;
<span class="fc bfc" id="L1925" title="All 2 branches covered.">        if (stlc == null) {</span>
<span class="fc" id="L1926">            layableColours = phaseColours;</span>
        } else {
<span class="fc" id="L1928">            layableColours = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L1929" title="All 2 branches covered.">            for (String colour : stlc) {</span>
<span class="fc bfc" id="L1930" title="All 2 branches covered.">                if (phaseColours.contains(colour)) layableColours.add(colour);</span>
            }
<span class="fc bfc" id="L1932" title="All 2 branches covered.">            if (layableColours.isEmpty()) return false;</span>
        }

        // If any locations are specified, check if tile or colour(s) can be
        // laid there.
<span class="fc" id="L1937">        Map&lt;String, Integer&gt; tc = new HashMap&lt;String, Integer&gt;();</span>
<span class="fc" id="L1938">        List&lt;MapHex&gt; hexes = stl.getLocations();</span>
<span class="fc" id="L1939">        List&lt;MapHex&gt; remainingHexes = null;</span>
<span class="fc" id="L1940">        List&lt;String&gt; remainingColours = null;</span>
<span class="fc" id="L1941">        int cash = operatingCompany.value().getCash();</span>

<span class="pc bpc" id="L1943" title="1 of 2 branches missed.">        if (hexes != null) {</span>
<span class="fc" id="L1944">            remainingHexes = new ArrayList&lt;MapHex&gt;();</span>
<span class="fc" id="L1945">            remainingColours = new ArrayList&lt;String&gt;();</span>
        }
<span class="fc bfc" id="L1947" title="All 2 branches covered.">        for (String colour : layableColours) {</span>
<span class="pc bpc" id="L1948" title="1 of 2 branches missed.">            if (hexes != null) {</span>
<span class="fc bfc" id="L1949" title="All 2 branches covered.">                for (MapHex hex : hexes) {</span>
<span class="fc" id="L1950">                    int cost = Math.max(0, hex.getTileCost() - stl.getDiscount());</span>
                    // Check if the company can pay any costs (if not free)
<span class="pc bpc" id="L1952" title="1 of 4 branches missed.">                    if (!stl.isFree() &amp;&amp; cash &lt; cost) continue;</span>

                    // At least one hex does not have that colour yet
                    // TODO: Check if this can be rewritten in a simpler fashion
                    // using TileColours directly
<span class="fc" id="L1957">                    if (hex.getCurrentTile().getColourNumber() + 1 == TileColour.valueOfIgnoreCase(</span>
<span class="fc bfc" id="L1958" title="All 2 branches covered.">                            colour).getNumber()) {</span>
<span class="fc" id="L1959">                        tc.put(colour, 1);</span>
<span class="fc" id="L1960">                        remainingColours.add(colour);</span>
<span class="fc" id="L1961">                        remainingHexes.add(hex);</span>
<span class="fc" id="L1962">                        continue;</span>
                    }
<span class="fc" id="L1964">                }</span>
            } else {
<span class="nc" id="L1966">                tc.put(colour, 1);</span>
            }
<span class="fc" id="L1968">        }</span>
<span class="fc bfc" id="L1969" title="All 2 branches covered.">        if (!tc.isEmpty()) layTile.setTileColours(tc);</span>

<span class="pc bpc" id="L1971" title="1 of 2 branches missed.">        if (hexes != null) {</span>
<span class="fc bfc" id="L1972" title="All 2 branches covered.">            if (remainingHexes.isEmpty()) return false;</span>
<span class="fc" id="L1973">            layTile.setLocations(remainingHexes);</span>
        }

<span class="fc" id="L1976">        return true;</span>
    }

    protected boolean areTileLaysPossible() {
<span class="fc bfc" id="L1980" title="All 2 branches covered.">        return !tileLaysPerColour.isEmpty()</span>
<span class="fc bfc" id="L1981" title="All 2 branches covered.">               || !getSpecialTileLays(false).isEmpty();</span>
    }

    /**
     * Reports if a tile lay is allowed by a certain company on a certain hex
     * &lt;p&gt; This method can be used both in restricting possible actions and in
     * validating submitted actions. &lt;p&gt; Currently, only a few standard checks
     * are included. This method can be extended to perform other generic
     * checks, such as if a route exists, and possibly in subclasses for
     * game-specific checks.
     *
     * @param company The company laying a tile.
     * @param hex The hex on which a tile is laid.
     * @param orientation The orientation in which the tile is laid (-1 is any).
     */
    protected boolean isTileLayAllowed(PublicCompany company, MapHex hex,
            int orientation) {
<span class="nc" id="L1998">        boolean result = true;</span>

<span class="nc" id="L2000">        result = gameSpecificTileLayAllowed(company, hex, orientation);</span>
<span class="nc" id="L2001">        return result;</span>
    }

    protected boolean gameSpecificTileLayAllowed(PublicCompany company,
            MapHex hex, int orientation) {
<span class="nc" id="L2006">        return hex.isBlockedByPrivateCompany();</span>
    }

    /*
     * ======================================= 5. TOKEN LAYING 5.1. BASE TOKENS
     * =======================================
     */

    public boolean layBaseToken(LayBaseToken action) {

<span class="fc" id="L2016">        String errMsg = null;</span>
<span class="fc" id="L2017">        int cost = 0;</span>
<span class="fc" id="L2018">        SpecialBaseTokenLay stl = null;</span>
<span class="fc" id="L2019">        boolean extra = false;</span>

<span class="fc" id="L2021">        MapHex hex = action.getChosenHex();</span>
<span class="fc" id="L2022">        Stop stop = action.getChosenStop();</span>

<span class="fc" id="L2024">        PublicCompany company = action.getCompany();</span>
<span class="fc" id="L2025">        String companyName = company.getId();</span>

        // Dummy loop to enable a quick jump out.
        while (true) {

            // Checks
            // Must be correct step (exception: home base lay &amp; some special
            // token lay)
<span class="fc bfc" id="L2033" title="All 2 branches covered.">            if (getStep() != GameDef.OrStep.LAY_TOKEN</span>
<span class="fc bfc" id="L2034" title="All 2 branches covered.">                &amp;&amp; action.getType() != LayBaseToken.HOME_CITY</span>
<span class="pc bpc" id="L2035" title="1 of 2 branches missed.">                &amp;&amp; action.getType() != LayBaseToken.SPECIAL_PROPERTY</span>
<span class="nc bnc" id="L2036" title="All 2 branches missed.">                &amp;&amp; action.getType() != LayBaseToken.CORRECTION) {</span>
<span class="nc" id="L2037">                errMsg = LocalText.getText(&quot;WrongActionNoTokenLay&quot;);</span>
<span class="nc" id="L2038">                break;</span>
            }

<span class="pc bpc" id="L2041" title="1 of 2 branches missed.">            if (company.getNumberOfFreeBaseTokens() == 0) {</span>
<span class="nc" id="L2042">                errMsg = LocalText.getText(&quot;HasNoTokensLeft&quot;, companyName);</span>
<span class="nc" id="L2043">                break;</span>
            }

<span class="pc bpc" id="L2046" title="1 of 2 branches missed.">            if (!isTokenLayAllowed(company, hex, stop)) {</span>
<span class="nc" id="L2047">                errMsg = LocalText.getText(&quot;BaseTokenSlotIsReserved&quot;);</span>
<span class="nc" id="L2048">                break;</span>
            }

<span class="pc bpc" id="L2051" title="1 of 2 branches missed.">            if (!stop.hasTokenSlotsLeft()) {</span>
<span class="nc" id="L2052">                errMsg = LocalText.getText(&quot;CityHasNoEmptySlots&quot;);</span>
<span class="nc" id="L2053">                break;</span>
            }

            /*
             * TODO: the below condition holds for 1830. in some games, separate
             * cities on one tile may hold tokens of the same company; this case
             * is not yet covered.
             */
<span class="pc bpc" id="L2061" title="1 of 2 branches missed.">            if (hex.hasTokenOfCompany(company)) {</span>
<span class="nc" id="L2062">                errMsg =</span>
<span class="nc" id="L2063">                        LocalText.getText(&quot;TileAlreadyHasToken&quot;, hex.getId(),</span>
                                companyName);
<span class="nc" id="L2065">                break;</span>
            }

<span class="pc bpc" id="L2068" title="1 of 2 branches missed.">            if (action != null) {</span>
<span class="fc" id="L2069">                List&lt;MapHex&gt; locations = action.getLocations();</span>
<span class="pc bpc" id="L2070" title="1 of 4 branches missed.">                if (locations != null &amp;&amp; locations.size() &gt; 0</span>
<span class="pc bpc" id="L2071" title="3 of 4 branches missed.">                    &amp;&amp; !locations.contains(hex) &amp;&amp; !locations.contains(null)) {</span>
<span class="nc" id="L2072">                    errMsg =</span>
<span class="nc" id="L2073">                            LocalText.getText(&quot;TokenLayingHexMismatch&quot;,</span>
<span class="nc" id="L2074">                                    hex.getId(), action.getLocationNameString());</span>
<span class="nc" id="L2075">                    break;</span>
                }
<span class="fc" id="L2077">                stl = action.getSpecialProperty();</span>
<span class="fc bfc" id="L2078" title="All 2 branches covered.">                if (stl != null) extra = stl.isExtra();</span>
            }

<span class="fc" id="L2081">            cost = company.getBaseTokenLayCost(hex);</span>
<span class="pc bpc" id="L2082" title="1 of 4 branches missed.">            if (stl != null &amp;&amp; stl.isFree()) cost = 0;</span>

            // Does the company have the money?
<span class="pc bpc" id="L2085" title="1 of 2 branches missed.">            if (cost &gt; company.getCash()) {</span>
<span class="nc" id="L2086">                errMsg =</span>
<span class="nc" id="L2087">                        LocalText.getText(&quot;NotEnoughMoney&quot;, companyName,</span>
<span class="nc" id="L2088">                                Bank.format(this,</span>
<span class="nc" id="L2089">                                        company.getCash()),</span>
<span class="nc" id="L2090">                                Bank.format(this, cost));</span>
                break;
            }
            break;
        }
<span class="pc bpc" id="L2095" title="1 of 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L2096">            DisplayBuffer.add(</span>
                    this,
<span class="nc" id="L2098">                    LocalText.getText(&quot;CannotLayBaseTokenOn&quot;, companyName,</span>
<span class="nc" id="L2099">                            hex.getId(), Bank.format(this, cost), errMsg));</span>
<span class="nc" id="L2100">            return false;</span>
        }

        /* End of validation, start of execution */

<span class="pc bpc" id="L2105" title="1 of 2 branches missed.">        if (hex.layBaseToken(company, stop)) {</span>
            /* TODO: the false return value must be impossible. */

<span class="fc" id="L2108">            company.layBaseToken(hex, cost);</span>

            // If this is a home base token lay, stop here
<span class="fc bfc" id="L2111" title="All 2 branches covered.">            if (action.getType() == LayBaseToken.HOME_CITY) {</span>
<span class="fc" id="L2112">                return true;</span>
            }

<span class="fc" id="L2115">            StringBuilder text = new StringBuilder();</span>
<span class="pc bpc" id="L2116" title="1 of 2 branches missed.">            if (action.isCorrection()) {</span>
<span class="nc" id="L2117">                text.append(LocalText.getText(&quot;CorrectionPrefix&quot;));</span>
            }
<span class="fc bfc" id="L2119" title="All 2 branches covered.">            if (cost &gt; 0) {</span>
<span class="fc" id="L2120">                String costText =</span>
<span class="fc" id="L2121">                        Currency.toBank(company, cost);</span>
<span class="fc" id="L2122">                text.append(LocalText.getText(&quot;LAYS_TOKEN_ON&quot;, companyName,</span>
<span class="fc" id="L2123">                                hex.getId(), costText));</span>
<span class="fc" id="L2124">                text.append(&quot; &quot;).append(stop.toText());</span>
<span class="fc" id="L2125">            } else {</span>
<span class="fc" id="L2126">                text.append(LocalText.getText(&quot;LAYS_FREE_TOKEN_ON&quot;,</span>
<span class="fc" id="L2127">                        companyName, hex.getId()));</span>
            }
<span class="fc" id="L2129">            ReportBuffer.add(this, text.toString());</span>

            // Was a special property used?
<span class="fc bfc" id="L2132" title="All 2 branches covered.">            if (stl != null) {</span>
<span class="fc" id="L2133">                stl.setExercised();</span>
<span class="fc" id="L2134">                currentSpecialTokenLays.remove(action);</span>
<span class="fc bfc" id="L2135" title="All 2 branches covered.">                log.debug(&quot;This was a special token lay, {} extra&quot;, extra ? &quot;&quot; : &quot; not&quot;);</span>

            }

            // Jump out if we aren't in the token laying step or it is a correction lay
<span class="pc bpc" id="L2140" title="1 of 4 branches missed.">            if (getStep() != GameDef.OrStep.LAY_TOKEN || action.isCorrection()) {</span>
<span class="fc" id="L2141">                return true;</span>
            }

<span class="fc bfc" id="L2144" title="All 2 branches covered.">            if (!extra) {</span>
<span class="fc" id="L2145">                currentNormalTokenLays.clear();</span>
<span class="fc" id="L2146">                log.debug(&quot;This was a normal token lay&quot;);</span>
            }

<span class="fc bfc" id="L2149" title="All 2 branches covered.">            if (currentNormalTokenLays.isEmpty()) {</span>
<span class="fc" id="L2150">                log.debug(&quot;No more normal token lays are allowed&quot;);</span>
<span class="pc bpc" id="L2151" title="1 of 2 branches missed.">            } else if (operatingCompany.value().getNumberOfFreeBaseTokens() == 0) {</span>
<span class="nc" id="L2152">                log.debug(&quot;Normal token lay allowed by no more tokens&quot;);</span>
<span class="nc" id="L2153">                currentNormalTokenLays.clear();</span>
            } else {
<span class="fc" id="L2155">                log.debug(&quot;A normal token lay is still allowed&quot;);</span>
            }
<span class="fc" id="L2157">            setSpecialTokenLays();</span>
<span class="fc" id="L2158">            log.debug(&quot;There are now {} special token lay objects&quot;, currentSpecialTokenLays.size());</span>
<span class="fc bfc" id="L2159" title="All 2 branches covered.">            if (currentNormalTokenLays.isEmpty()</span>
<span class="pc bpc" id="L2160" title="1 of 2 branches missed.">                &amp;&amp; currentSpecialTokenLays.isEmpty()) {</span>
<span class="fc" id="L2161">                nextStep();</span>
            }

        }

<span class="fc" id="L2166">        return true;</span>
    }

    /**
     * Reports if a token lay is allowed by a certain company on a certain hex
     * and city &lt;p&gt; This method can be used both in restricting possible actions
     * and in validating submitted actions. &lt;p&gt; Currently, only a few standard
     * checks are included. This method can be extended to perform other generic
     * checks, such as if a route exists, and possibly in subclasses for
     * game-specific checks.
     *
     * @param company The company laying a tile.
     * @param hex The hex on which a tile is laid.
     * @param station The number of the station/city on which the token is to be
     * laid (0 if any or immaterial).
     */
    protected boolean isTokenLayAllowed(PublicCompany company, MapHex hex,
            Stop stop) {
<span class="pc bpc" id="L2184" title="1 of 2 branches missed.">        return !hex.isBlockedForTokenLays(company, stop);</span>
    }

    protected void setNormalTokenLays() {

        /* Normal token lays */
<span class="fc" id="L2190">        currentNormalTokenLays.clear();</span>

        /* For now, we allow one token of the currently operating company */
<span class="pc bpc" id="L2193" title="1 of 2 branches missed.">        if (operatingCompany.value().getNumberOfFreeBaseTokens() &gt; 0) {</span>
<span class="fc" id="L2194">            currentNormalTokenLays.add(new LayBaseToken((List&lt;MapHex&gt;) null));</span>
        }

<span class="fc" id="L2197">    }</span>

    /**
     * Create a List of allowed special token lays (see LayToken class). This
     * method should be called before each user action in the base token laying
     * step. TODO: Token preparation is practically identical to Tile
     * preparation, perhaps the two can be merged to one generic procedure.
     */
    protected void setSpecialTokenLays() {

        /* Special-property tile lays */
<span class="fc" id="L2208">        currentSpecialTokenLays.clear();</span>

<span class="fc" id="L2210">        PublicCompany company = operatingCompany.value();</span>
<span class="fc bfc" id="L2211" title="All 2 branches covered.">        if (!company.canUseSpecialProperties()) return;</span>
        // Check if the company still has tokens
<span class="fc bfc" id="L2213" title="All 2 branches covered.">        if (company.getNumberOfFreeBaseTokens() == 0) return;</span>

        /*
         * In 1835, this only applies to major companies. TODO: For now,
         * hardcode this, but it must become configurable later.
         */
        // Removed EV 24-11-2011 - entirely redundant; why did I ever do this??
        // if (operatingCompany.get().getType().getName().equals(&quot;Minor&quot;))
        // return;

<span class="fc bfc" id="L2223" title="All 2 branches covered.">        for (SpecialBaseTokenLay stl : getSpecialProperties(SpecialBaseTokenLay.class)) {</span>
            // If the special tile lay is not extra, it is only allowed if
            // normal tile lays are also (still) allowed
<span class="pc bpc" id="L2226" title="1 of 4 branches missed.">            if (stl.isExtra() || !currentNormalTokenLays.isEmpty()) {</span>

                // If this STL is location specific, check if there
                // isn't already a token of this company or if it is blocked
<span class="fc" id="L2230">                List&lt;MapHex&gt; locations = stl.getLocations();</span>
<span class="pc bpc" id="L2231" title="2 of 4 branches missed.">                if (locations != null &amp;&amp; !locations.isEmpty()) {</span>
<span class="fc" id="L2232">                    boolean canLay = false;</span>
<span class="fc bfc" id="L2233" title="All 2 branches covered.">                    for (MapHex location : locations) {</span>
<span class="fc bfc" id="L2234" title="All 2 branches covered.">                        if (location.hasTokenOfCompany(company)) {</span>
<span class="fc" id="L2235">                            continue;</span>
                        }
<span class="fc bfc" id="L2237" title="All 2 branches covered.">                        for (Stop stop:location.getStops()) {</span>
<span class="fc bfc" id="L2238" title="All 2 branches covered.">                            canLay = !location.isBlockedForTokenLays(company, stop);</span>
<span class="fc" id="L2239">                        }</span>
<span class="fc" id="L2240">                    }</span>
<span class="fc bfc" id="L2241" title="All 2 branches covered.">                    if (!canLay) continue;</span>
                }
<span class="fc" id="L2243">                currentSpecialTokenLays.add(new LayBaseToken(stl));</span>
            }
<span class="fc" id="L2245">        }</span>
<span class="fc" id="L2246">    }</span>

    /*
     * ======================================= 5.2. BONUS TOKENS
     * =======================================
     */

    public boolean layBonusToken(LayBonusToken action) {

<span class="fc" id="L2255">        String errMsg = null;</span>
<span class="fc" id="L2256">        int cost = 0; // currently costs are always zero</span>
<span class="fc" id="L2257">        SpecialBonusTokenLay stl = null;</span>

<span class="fc" id="L2259">        MapHex hex = action.getChosenHex();</span>
<span class="fc" id="L2260">        BonusToken token = action.getToken();</span>

        // Dummy loop to enable a quick jump out.
        while (true) {

            // Checks
<span class="fc" id="L2266">            MapHex location = action.getChosenHex();</span>
<span class="pc bpc" id="L2267" title="1 of 2 branches missed.">            if (location != hex) {</span>
<span class="nc" id="L2268">                errMsg =</span>
<span class="nc" id="L2269">                        LocalText.getText(&quot;TokenLayingHexMismatch&quot;,</span>
<span class="nc" id="L2270">                                hex.getId(), location.getId());</span>
<span class="nc" id="L2271">                break;</span>
            }
<span class="fc" id="L2273">            stl = action.getSpecialProperty();</span>
<span class="fc" id="L2274">            break;</span>
        }
<span class="pc bpc" id="L2276" title="1 of 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L2277">            DisplayBuffer.add(this,</span>
<span class="nc" id="L2278">                    LocalText.getText(&quot;CannotLayBonusTokenOn&quot;, token.getId(),</span>
<span class="nc" id="L2279">                            hex.getId(), Bank.format(this, cost), errMsg));</span>
<span class="nc" id="L2280">            return false;</span>
        }

        /* End of validation, start of execution */

<span class="pc bpc" id="L2285" title="1 of 2 branches missed.">        if (hex.layBonusToken(token, getRoot().getPhaseManager())) {</span>
            /* TODO: the false return value must be impossible. */

<span class="fc" id="L2288">            operatingCompany.value().addBonus(</span>
<span class="fc" id="L2289">                    new Bonus(operatingCompany.value(), token.getId(),</span>
<span class="fc" id="L2290">                            token.getValue(), Collections.singletonList(hex)));</span>
<span class="fc" id="L2291">            token.setUser(operatingCompany.value());</span>

<span class="fc" id="L2293">            ReportBuffer.add(this, LocalText.getText(&quot;LaysBonusTokenOn&quot;,</span>
<span class="fc" id="L2294">                    operatingCompany.value().getId(), token.getId(),</span>
<span class="fc" id="L2295">                    Bank.format(this, token.getValue()), hex.getId()));</span>

            // Was a special property used?
<span class="pc bpc" id="L2298" title="1 of 2 branches missed.">            if (stl != null) {</span>
<span class="fc" id="L2299">                stl.setExercised();</span>
<span class="fc" id="L2300">                currentSpecialTokenLays.remove(action);</span>
            }

        }

<span class="fc" id="L2305">        return true;</span>
    }

    public boolean buyBonusToken(BuyBonusToken action) {

<span class="fc" id="L2310">        String errMsg = null;</span>
        int cost;
<span class="fc" id="L2312">        SellBonusToken sbt = null;</span>
<span class="fc" id="L2313">        MoneyOwner seller = null;</span>

        // Dummy loop to enable a quick jump out.
        while (true) {

            // Checks
<span class="fc" id="L2319">            sbt = action.getSpecialProperty();</span>
<span class="fc" id="L2320">            cost = sbt.getPrice();</span>
<span class="fc" id="L2321">            Owner from = sbt.getSeller();</span>
            // TODO: Remove redundancy use a generalized check
<span class="fc bfc" id="L2323" title="All 2 branches covered.">            if (from instanceof BankPortfolio) {</span>
<span class="fc" id="L2324">                seller = bank;</span>
            } else {
<span class="fc" id="L2326">                seller = (MoneyOwner) from;</span>
            }

            // Does the company have the money?
<span class="pc bpc" id="L2330" title="1 of 2 branches missed.">            if (cost &gt; operatingCompany.value().getCash()) {</span>
<span class="nc" id="L2331">                errMsg =</span>
<span class="nc" id="L2332">                        LocalText.getText(&quot;NotEnoughMoney&quot;,</span>
<span class="nc" id="L2333">                                operatingCompany.value().getId(), Bank.format(</span>
                                        this,
<span class="nc" id="L2335">                                        operatingCompany.value().getCash()),</span>
<span class="nc" id="L2336">                                Bank.format(this, cost));</span>
<span class="nc" id="L2337">                break;</span>
            }
            break;
        }
<span class="pc bpc" id="L2341" title="1 of 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L2342">            DisplayBuffer.add(this, LocalText.getText(&quot;CannotBuyBonusToken&quot;,</span>
<span class="nc" id="L2343">                    operatingCompany.value().getId(), sbt.getId(),</span>
<span class="nc" id="L2344">                    seller.getId(), bank.getCurrency().format(cost), // TODO: Do</span>
                                                                     // this
                                                                     // nicer
                    errMsg));
<span class="nc" id="L2348">            return false;</span>
        }

        /* End of validation, start of execution */

        // TODO: Is text of cost used below?
<span class="fc" id="L2354">        Currency.wire(operatingCompany.value(), cost, seller);</span>

<span class="fc" id="L2356">        operatingCompany.value().addBonus(</span>
<span class="fc" id="L2357">                new Bonus(operatingCompany.value(), sbt.getId(),</span>
<span class="fc" id="L2358">                        sbt.getValue(), sbt.getLocations()));</span>

<span class="fc" id="L2360">        ReportBuffer.add(this, LocalText.getText(&quot;BuysBonusTokenFrom&quot;,</span>
<span class="fc" id="L2361">                operatingCompany.value().getId(), sbt.getName(),</span>
<span class="fc" id="L2362">                bank.getCurrency().format(sbt.getValue()), // TODO: Do this</span>
                                                           // nicer
<span class="fc" id="L2364">                seller.getId(), bank.getCurrency().format(sbt.getPrice()))); // TODO:</span>
                                                                             // Do
                                                                             // this
                                                                             // nicer

<span class="fc" id="L2369">        sbt.setExercised();</span>

<span class="fc" id="L2371">        return true;</span>
    }

    /**
     * TODO Should be merged with setSpecialTokenLays() in the future.
     * Assumptions: 1. Bonus tokens can be laid anytime during the OR. 2. Bonus
     * token laying is always extra. TODO This assumptions will be made
     * configurable conditions.
     */
    protected void setBonusTokenLays() {

<span class="fc bfc" id="L2382" title="All 2 branches covered.">        for (SpecialBonusTokenLay stl : getSpecialProperties(SpecialBonusTokenLay.class)) {</span>
<span class="fc" id="L2383">                possibleActions.add(new LayBonusToken(stl, stl.getToken()));</span>
<span class="fc" id="L2384">        }</span>
<span class="fc" id="L2385">    }</span>

    /*
     * ======================================= 6. REVENUE AND DIVIDEND
     * =======================================
     */

    public boolean setRevenueAndDividend(SetDividend action) {

<span class="fc" id="L2394">        String errMsg = validateSetRevenueAndDividend(action);</span>

<span class="pc bpc" id="L2396" title="1 of 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L2397">            DisplayBuffer.add(this, LocalText.getText(&quot;CannotProcessRevenue&quot;,</span>
<span class="nc" id="L2398">                    Bank.format(this, action.getActualRevenue()),</span>
<span class="nc" id="L2399">                    action.getCompanyName(), errMsg));</span>
<span class="nc" id="L2400">            return false;</span>
        }

<span class="fc" id="L2403">        ReportBuffer.add(this, LocalText.getText(&quot;CompanyRevenue&quot;,</span>
<span class="fc" id="L2404">                action.getCompanyName(),</span>
<span class="fc" id="L2405">                Bank.format(this, action.getActualRevenue())));</span>

<span class="fc" id="L2407">        int remainingAmount = checkForDeductions(action);</span>
<span class="pc bpc" id="L2408" title="1 of 2 branches missed.">        if (remainingAmount &lt; 0) {</span>
            // A share selling round will be run to raise cash to pay debts
<span class="nc" id="L2410">            return true;</span>
        }

<span class="fc" id="L2413">        executeSetRevenueAndDividend(action);</span>

<span class="fc" id="L2415">        return true;</span>

    }

    protected String validateSetRevenueAndDividend(SetDividend action) {

<span class="fc" id="L2421">        String errMsg = null;</span>
        PublicCompany company;
        String companyName;
<span class="fc" id="L2424">        int amount = 0;</span>
<span class="fc" id="L2425">        int revenueAllocation = -1;</span>

        // Dummy loop to enable a quick jump out.
        while (true) {

            // Checks
            // Must be correct company.
<span class="fc" id="L2432">            company = action.getCompany();</span>
<span class="fc" id="L2433">            companyName = company.getId();</span>
<span class="pc bpc" id="L2434" title="1 of 2 branches missed.">            if (company != operatingCompany.value()) {</span>
<span class="nc" id="L2435">                errMsg =</span>
<span class="nc" id="L2436">                        LocalText.getText(&quot;WrongCompany&quot;, companyName,</span>
<span class="nc" id="L2437">                                operatingCompany.value().getId());</span>
<span class="nc" id="L2438">                break;</span>
            }
            // Must be correct step
<span class="pc bpc" id="L2441" title="1 of 2 branches missed.">            if (getStep() != GameDef.OrStep.CALC_REVENUE) {</span>
<span class="nc" id="L2442">                errMsg = LocalText.getText(&quot;WrongActionNoRevenue&quot;);</span>
<span class="nc" id="L2443">                break;</span>
            }

            // Amount must be non-negative multiple of 10
<span class="fc" id="L2447">            amount = action.getActualRevenue();</span>
<span class="pc bpc" id="L2448" title="1 of 2 branches missed.">            if (amount &lt; 0) {</span>
<span class="nc" id="L2449">                errMsg =</span>
<span class="nc" id="L2450">                        LocalText.getText(&quot;NegativeAmountNotAllowed&quot;,</span>
<span class="nc" id="L2451">                                String.valueOf(amount));</span>
<span class="nc" id="L2452">                break;</span>
            }
<span class="pc bpc" id="L2454" title="1 of 2 branches missed.">            if (amount % 10 != 0) {</span>
<span class="nc" id="L2455">                errMsg =</span>
<span class="nc" id="L2456">                        LocalText.getText(&quot;AmountMustBeMultipleOf10&quot;,</span>
<span class="nc" id="L2457">                                String.valueOf(amount));</span>
<span class="nc" id="L2458">                break;</span>
            }

            // Check chosen revenue distribution
<span class="fc bfc" id="L2462" title="All 2 branches covered.">            if (amount &gt; 0) {</span>
                // Check the allocation type index (see SetDividend for values)
<span class="fc" id="L2464">                revenueAllocation = action.getRevenueAllocation();</span>
<span class="pc bpc" id="L2465" title="2 of 4 branches missed.">                if (revenueAllocation &lt; 0</span>
                    || revenueAllocation &gt;= SetDividend.NUM_OPTIONS) {
<span class="nc" id="L2467">                    errMsg =</span>
<span class="nc" id="L2468">                            LocalText.getText(&quot;InvalidAllocationTypeIndex&quot;,</span>
<span class="nc" id="L2469">                                    String.valueOf(revenueAllocation));</span>
<span class="nc" id="L2470">                    break;</span>
                }

                // Validate the chosen allocation type
<span class="fc" id="L2474">                int[] allowedAllocations =</span>
<span class="fc" id="L2475">                        ((SetDividend) selectedAction).getAllowedAllocations();</span>
<span class="fc" id="L2476">                boolean valid = false;</span>
<span class="pc bpc" id="L2477" title="1 of 2 branches missed.">                for (int aa : allowedAllocations) {</span>
<span class="fc bfc" id="L2478" title="All 2 branches covered.">                    if (revenueAllocation == aa) {</span>
<span class="fc" id="L2479">                        valid = true;</span>
<span class="fc" id="L2480">                        break;</span>
                    }
                }
<span class="pc bpc" id="L2483" title="1 of 2 branches missed.">                if (!valid) {</span>
<span class="nc" id="L2484">                    errMsg =</span>
<span class="nc" id="L2485">                            LocalText.getText(SetDividend.getAllocationNameKey(revenueAllocation));</span>
<span class="nc" id="L2486">                    break;</span>
                }
<span class="fc" id="L2488">            } else {</span>
                // If there is no revenue, use withhold.
<span class="fc" id="L2490">                action.setRevenueAllocation(SetDividend.WITHHOLD);</span>
            }

<span class="fc bfc" id="L2493" title="All 2 branches covered.">            if (amount == 0</span>
<span class="fc bfc" id="L2494" title="All 2 branches covered.">                &amp;&amp; operatingCompany.value().getNumberOfTrains() == 0) {</span>
<span class="fc" id="L2495">                DisplayBuffer.add(this, LocalText.getText(</span>
                        &quot;RevenueWithNoTrains&quot;,
<span class="fc" id="L2497">                        operatingCompany.value().getId(), Bank.format(this, 0)));</span>
            }

            break;
        }

<span class="fc" id="L2503">        return errMsg;</span>
    }

    protected void executeSetRevenueAndDividend(SetDividend action) {

<span class="fc" id="L2508">        int amount = action.getActualRevenue();</span>
<span class="fc" id="L2509">        int revenueAllocation = action.getRevenueAllocation();</span>

<span class="fc" id="L2511">        operatingCompany.value().setLastRevenue(amount);</span>
<span class="fc" id="L2512">        operatingCompany.value().setLastRevenueAllocation(revenueAllocation);</span>

        // Pay any debts from treasury, revenue and/or president's cash
        // The remaining dividend may be less that the original income
<span class="fc" id="L2516">        amount = executeDeductions(action);</span>

<span class="fc bfc" id="L2518" title="All 2 branches covered.">        if (amount == 0) {</span>

<span class="fc" id="L2520">            ReportBuffer.add(this, LocalText.getText(</span>
                    &quot;CompanyDoesNotPayDividend&quot;,
<span class="fc" id="L2522">                    operatingCompany.value().getId()));</span>
<span class="fc" id="L2523">            withhold(amount);</span>

<span class="fc bfc" id="L2525" title="All 2 branches covered.">        } else if (revenueAllocation == SetDividend.PAYOUT) {</span>

<span class="fc" id="L2527">            ReportBuffer.add(this,</span>
<span class="fc" id="L2528">                    LocalText.getText(&quot;CompanyPaysOutFull&quot;,</span>
<span class="fc" id="L2529">                            operatingCompany.value().getId(),</span>
<span class="fc" id="L2530">                            Bank.format(this, amount)));</span>

<span class="fc" id="L2532">            payout(amount);</span>

<span class="fc bfc" id="L2534" title="All 2 branches covered.">        } else if (revenueAllocation == SetDividend.SPLIT) {</span>

<span class="fc" id="L2536">            ReportBuffer.add(this,</span>
<span class="fc" id="L2537">                    LocalText.getText(&quot;CompanySplits&quot;,</span>
<span class="fc" id="L2538">                            operatingCompany.value().getId(),</span>
<span class="fc" id="L2539">                            Bank.format(this, amount)));</span>

<span class="fc" id="L2541">            splitRevenue(amount);</span>

<span class="pc bpc" id="L2543" title="1 of 2 branches missed.">        } else if (revenueAllocation == SetDividend.WITHHOLD) {</span>

<span class="fc" id="L2545">            ReportBuffer.add(this,</span>
<span class="fc" id="L2546">                    LocalText.getText(&quot;CompanyWithholds&quot;,</span>
<span class="fc" id="L2547">                            operatingCompany.value().getId(),</span>
<span class="fc" id="L2548">                            Bank.format(this, amount)));</span>

<span class="fc" id="L2550">            withhold(amount);</span>

        }

        // Rust any obsolete trains
<span class="fc" id="L2555">        operatingCompany.value().getPortfolioModel().rustObsoleteTrains();</span>

        // We have done the payout step, so continue from there
<span class="fc" id="L2558">        nextStep(GameDef.OrStep.PAYOUT);</span>
<span class="fc" id="L2559">    }</span>

    /**
     * Distribute the dividend amongst the shareholders.
     *
     * @param amount
     */
    public void payout(int amount) {

<span class="pc bpc" id="L2568" title="1 of 2 branches missed.">        if (amount == 0) return;</span>

        int part;
        int shares;

<span class="fc" id="L2573">        Map&lt;MoneyOwner, Integer&gt; sharesPerRecipient = countSharesPerRecipient();</span>

        // Calculate, round up, report and add the cash

        // Define a precise sequence for the reporting
<span class="fc" id="L2578">        Set&lt;MoneyOwner&gt; recipientSet = sharesPerRecipient.keySet();</span>
<span class="fc bfc" id="L2579" title="All 2 branches covered.">        for (MoneyOwner recipient : SequenceUtil.sortCashHolders(recipientSet)) {</span>
<span class="fc bfc" id="L2580" title="All 2 branches covered.">            if (recipient instanceof Bank) continue;</span>
<span class="fc" id="L2581">            shares = (sharesPerRecipient.get(recipient));</span>
<span class="pc bpc" id="L2582" title="1 of 2 branches missed.">            if (shares == 0) continue;</span>
<span class="fc" id="L2583">            part =</span>
<span class="fc" id="L2584">                    (int) Math.ceil(amount * shares</span>
<span class="fc" id="L2585">                                    * operatingCompany.value().getShareUnit()</span>
                                    / 100.0);

<span class="fc" id="L2588">            String partText = Currency.fromBank(part, recipient);</span>
<span class="fc" id="L2589">            ReportBuffer.add(this, LocalText.getText(&quot;Payout&quot;,</span>
<span class="fc" id="L2590">                    recipient.getId(), partText, shares,</span>
<span class="fc" id="L2591">                    operatingCompany.value().getShareUnit()));</span>
<span class="fc" id="L2592">        }</span>

        // Move the token
<span class="fc" id="L2595">        operatingCompany.value().payout(amount);</span>

<span class="fc" id="L2597">    }</span>

    protected Map&lt;MoneyOwner, Integer&gt; countSharesPerRecipient() {

<span class="fc" id="L2601">        Map&lt;MoneyOwner, Integer&gt; sharesPerRecipient =</span>
                new HashMap&lt;MoneyOwner, Integer&gt;();

        // Changed to accomodate the CGR 5% share roundup rule.
        // For now it is assumed, that actual payouts are always rounded up
        // (the withheld half of split revenues is not handled here, see
        // splitRevenue()).

        // First count the shares per recipient
<span class="fc bfc" id="L2610" title="All 2 branches covered.">        for (PublicCertificate cert : operatingCompany.value().getCertificates()) {</span>
<span class="fc" id="L2611">            MoneyOwner recipient = getBeneficiary(cert);</span>
<span class="fc bfc" id="L2612" title="All 2 branches covered.">            if (!sharesPerRecipient.containsKey(recipient)) {</span>
<span class="fc" id="L2613">                sharesPerRecipient.put(recipient, cert.getShares());</span>
            } else {
<span class="fc" id="L2615">                sharesPerRecipient.put(recipient,</span>
<span class="fc" id="L2616">                        sharesPerRecipient.get(recipient) + cert.getShares());</span>
            }
<span class="fc" id="L2618">        }</span>
<span class="fc" id="L2619">        return sharesPerRecipient;</span>
    }

    /** Who gets the per-share revenue? */
    protected MoneyOwner getBeneficiary(PublicCertificate cert) {
        MoneyOwner beneficiary;

        // Special cases apply if the holder is the IPO or the Pool
<span class="fc bfc" id="L2627" title="All 2 branches covered.">        if (operatingCompany.value().paysOutToTreasury(cert)) {</span>
<span class="fc" id="L2628">            beneficiary = operatingCompany.value();</span>
<span class="fc bfc" id="L2629" title="All 2 branches covered.">        } else if (cert.getOwner() instanceof MoneyOwner) {</span>
<span class="fc" id="L2630">            beneficiary = (MoneyOwner) cert.getOwner();</span>
        } else { // TODO: check if this is a correct assumption that otherwise
                 // the money goes to the bank
<span class="fc" id="L2633">            beneficiary = bank;</span>
        }
<span class="fc" id="L2635">        return beneficiary;</span>
    }

    /**
     * Withhold a given amount of revenue (and store it).
     *
     * @param The revenue amount.
     */
    public void withhold(int amount) {

<span class="fc" id="L2645">        PublicCompany company = operatingCompany.value();</span>

        // Payout revenue to company
<span class="fc" id="L2648">        Currency.fromBank(amount, company);</span>

        // Move the token
<span class="fc" id="L2651">        company.withhold(amount);</span>

<span class="fc bfc" id="L2653" title="All 2 branches covered.">        if (!company.hasStockPrice()) return;</span>

        // Check if company has entered a closing area
<span class="fc" id="L2656">        StockSpace newSpace = company.getCurrentSpace();</span>
<span class="pc bpc" id="L2657" title="3 of 4 branches missed.">        if (newSpace.closesCompany() &amp;&amp; company.canClose()) {</span>
<span class="nc" id="L2658">            company.setClosed();</span>
<span class="nc" id="L2659">            ReportBuffer.add(this, LocalText.getText(&quot;CompanyClosesAt&quot;,</span>
<span class="nc" id="L2660">                    company.getId(), newSpace.getId()));</span>
<span class="nc" id="L2661">            finishTurn();</span>
<span class="nc" id="L2662">            return;</span>
        }

<span class="fc" id="L2665">    }</span>

    /**
     * Split a dividend. TODO Optional rounding down the payout
     *
     * @param amount
     */
    public void splitRevenue(int amount) {

<span class="pc bpc" id="L2674" title="1 of 2 branches missed.">        if (amount &gt; 0) {</span>
            // Withhold half of it
            // For now, hardcode the rule that payout is rounded up.
<span class="fc" id="L2677">            int numberOfShares = operatingCompany.value().getNumberOfShares();</span>
<span class="fc" id="L2678">            int withheld = (amount / (2 * numberOfShares)) * numberOfShares;</span>
<span class="fc" id="L2679">            String withheldText =</span>
<span class="fc" id="L2680">                    Currency.fromBank(withheld, operatingCompany.value());</span>

<span class="fc" id="L2682">            ReportBuffer.add(this, LocalText.getText(&quot;RECEIVES&quot;,</span>
<span class="fc" id="L2683">                    operatingCompany.value().getId(), withheldText));</span>

            // Payout the remainder
<span class="fc" id="L2686">            int payed = amount - withheld;</span>
<span class="fc" id="L2687">            payout(payed);</span>
        }

<span class="fc" id="L2690">    }</span>

    /** Default version, to be overridden if need be */
    protected int checkForDeductions(SetDividend action) {
<span class="fc" id="L2694">        return action.getActualRevenue();</span>
    }

    /** Default version, to be overridden if need be */
    protected int executeDeductions(SetDividend action) {
<span class="fc" id="L2699">        return action.getActualRevenue();</span>
    }

    protected boolean executeOperatingCost(OperatingCost action) {

<span class="nc" id="L2704">        String companyName = action.getCompanyName();</span>
<span class="nc" id="L2705">        OperatingCost.OCType typeOC = action.getOCType();</span>

<span class="nc" id="L2707">        int amount = action.getAmount();</span>

<span class="nc" id="L2709">        String errMsg = null;</span>

        while (true) {
            // Must be correct company.
<span class="nc bnc" id="L2713" title="All 2 branches missed.">            if (!companyName.equals(operatingCompany.value().getId())) {</span>
<span class="nc" id="L2714">                errMsg =</span>
<span class="nc" id="L2715">                        LocalText.getText(&quot;WrongCompany&quot;, companyName,</span>
<span class="nc" id="L2716">                                operatingCompany.value().getId());</span>
<span class="nc" id="L2717">                break;</span>
            }
            // amount is available
<span class="nc bnc" id="L2720" title="All 2 branches missed.">            if ((amount + operatingCompany.value().getCash()) &lt; 0) {</span>
<span class="nc" id="L2721">                errMsg =</span>
<span class="nc" id="L2722">                        LocalText.getText(&quot;NotEnoughMoney&quot;, companyName,</span>
<span class="nc" id="L2723">                                Bank.format(this,</span>
<span class="nc" id="L2724">                                        operatingCompany.value().getCash()),</span>
<span class="nc" id="L2725">                                Bank.format(this, amount));</span>
<span class="nc" id="L2726">                break;</span>
            }
<span class="nc bnc" id="L2728" title="All 2 branches missed.">            if (typeOC == OperatingCost.OCType.LAY_BASE_TOKEN</span>
<span class="nc bnc" id="L2729" title="All 2 branches missed.">                &amp;&amp; operatingCompany.value().getNumberOfFreeBaseTokens() == 0) {</span>
<span class="nc" id="L2730">                errMsg = LocalText.getText(&quot;HasNoTokensLeft&quot;, companyName);</span>
                break;
            }
            break;
        }

<span class="nc bnc" id="L2736" title="All 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L2737">            DisplayBuffer.add(this,</span>
<span class="nc" id="L2738">                    LocalText.getText(&quot;OCExecutionError&quot;, companyName, errMsg));</span>
<span class="nc" id="L2739">            return false;</span>
        }

<span class="nc" id="L2742">        String cashText = null;</span>
<span class="nc bnc" id="L2743" title="All 2 branches missed.">        if (amount &gt; 0) {</span>
            // positive amounts: remove cash from cashholder
<span class="nc" id="L2745">            cashText = Currency.toBank(operatingCompany.value(), amount);</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">        } else if (amount &lt; 0) {</span>
            // negative amounts: add cash to cashholder
<span class="nc" id="L2748">            cashText = Currency.fromBank(-amount, operatingCompany.value());</span>
        }

<span class="nc bnc" id="L2751" title="All 2 branches missed.">        if (typeOC == OperatingCost.OCType.LAY_TILE) {</span>
<span class="nc" id="L2752">            operatingCompany.value().layTilenNoMapMode(amount);</span>
<span class="nc" id="L2753">            ReportBuffer.add(this, LocalText.getText(&quot;OCLayTileExecuted&quot;,</span>
<span class="nc" id="L2754">                    operatingCompany.value().getId(), cashText));</span>
        }
<span class="nc bnc" id="L2756" title="All 2 branches missed.">        if (typeOC == OperatingCost.OCType.LAY_BASE_TOKEN) {</span>
            // move token to Bank
<span class="nc" id="L2758">            BaseToken token = operatingCompany.value().getNextBaseToken();</span>
<span class="nc bnc" id="L2759" title="All 2 branches missed.">            if (token == null) {</span>
<span class="nc" id="L2760">                log.error(&quot;Company &quot; + operatingCompany.value().getId()</span>
                          + &quot; has no free token&quot;);
<span class="nc" id="L2762">                return false;</span>
            } else {
                // FIXME: Check where to lay the base tokens in NoMapMode
                // (bank.getUnavailable().addBonusToken(token));
            }
<span class="nc" id="L2767">            operatingCompany.value().layBaseTokennNoMapMode(amount);</span>
<span class="nc" id="L2768">            ReportBuffer.add(this, LocalText.getText(&quot;OCLayBaseTokenExecuted&quot;,</span>
<span class="nc" id="L2769">                    operatingCompany.value().getId(), cashText));</span>
        }

<span class="nc" id="L2772">        return true;</span>
    }

    protected void prepareRevenueAndDividendAction() {

        // There is only revenue if there are any trains
<span class="pc bpc" id="L2778" title="1 of 2 branches missed.">        if (operatingCompany.value().canRunTrains()) {</span>
            int[] allowedRevenueActions =
<span class="fc bfc" id="L2780" title="All 2 branches covered.">                    operatingCompany.value().isSplitAlways()</span>
<span class="fc" id="L2781">                            ? new int[] { SetDividend.SPLIT }</span>
<span class="fc bfc" id="L2782" title="All 2 branches covered.">                            : operatingCompany.value().isSplitAllowed()</span>
<span class="fc" id="L2783">                                    ? new int[] { SetDividend.PAYOUT,</span>
                                            SetDividend.SPLIT,
<span class="fc" id="L2785">                                            SetDividend.WITHHOLD } : new int[] {</span>
                                            SetDividend.PAYOUT,
                                            SetDividend.WITHHOLD };

<span class="fc" id="L2789">            possibleActions.add(new SetDividend(</span>
<span class="fc" id="L2790">                    operatingCompany.value().getLastRevenue(), true,</span>
                    allowedRevenueActions));
        }
<span class="fc" id="L2793">    }</span>

    protected void prepareNoMapActions() {

        // LayTile Actions
<span class="nc bnc" id="L2798" title="All 2 branches missed.">        for (Integer tc : mapManager.getPossibleTileCosts()) {</span>
<span class="nc bnc" id="L2799" title="All 2 branches missed.">            if (tc &lt;= operatingCompany.value().getCash())</span>
<span class="nc" id="L2800">                possibleActions.add(new OperatingCost(</span>
<span class="nc" id="L2801">                        OperatingCost.OCType.LAY_TILE, tc, false));</span>
<span class="nc" id="L2802">        }</span>

        // LayBaseToken Actions
<span class="nc bnc" id="L2805" title="All 2 branches missed.">        if (operatingCompany.value().getNumberOfFreeBaseTokens() != 0) {</span>
<span class="nc" id="L2806">            Set&lt;Integer&gt; baseCosts =</span>
<span class="nc" id="L2807">                    operatingCompany.value().getBaseTokenLayCosts();</span>

            // change to set to allow for identity and ordering
<span class="nc" id="L2810">            Set&lt;Integer&gt; costsSet = new TreeSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L2811" title="All 2 branches missed.">            for (int cost : baseCosts)</span>
<span class="nc bnc" id="L2812" title="All 4 branches missed.">                if (!(cost == 0 &amp;&amp; baseCosts.size() != 1)) // fix for sequence</span>
                                                           // based home token
<span class="nc" id="L2814">                    costsSet.add(cost);</span>

            // SpecialBaseTokenLay Actions - workaround for a better handling of
            // those later
<span class="nc bnc" id="L2818" title="All 2 branches missed.">            for (SpecialBaseTokenLay stl : getSpecialProperties(SpecialBaseTokenLay.class)) {</span>
<span class="nc" id="L2819">                log.debug(&quot;Special tokenlay property: {}&quot;, stl);</span>
<span class="nc bnc" id="L2820" title="All 2 branches missed.">                if (stl.isFree()) {</span>
<span class="nc" id="L2821">                    costsSet.add(0);</span>
                }
<span class="nc" id="L2823">            }</span>

<span class="nc bnc" id="L2825" title="All 2 branches missed.">            for (int cost : costsSet) {</span>
<span class="nc bnc" id="L2826" title="All 2 branches missed.">                if (cost &lt;= operatingCompany.value().getCash()) // distance</span>
                                                                // method
                                                                // returns home
                                                                // base, but in
                                                                // sequence
                                                                // costsSet can
                                                                // be zero
<span class="nc" id="L2833">                    possibleActions.add(new OperatingCost(</span>
                            OperatingCost.OCType.LAY_BASE_TOKEN, cost, false));
<span class="nc" id="L2835">            }</span>
        }

        // Default OperatingCost Actions
        // possibleActions.add(new OperatingCost(
        // OperatingCost.OCType.LAY_TILE, 0, true
        // ));
        // if (operatingCompany.getObject().getNumberOfFreeBaseTokens() != 0
        // &amp;&amp; operatingCompany.getObject().getBaseTokenLayCost(null) != 0) {
        // possibleActions.add(new
        // OperatingCost(OperatingCost.OCType.LAY_BASE_TOKEN, 0, true));
        // }

<span class="nc" id="L2848">    }</span>

    /*
     * ======================================= 7. TRAIN PURCHASING
     * =======================================
     */

    public boolean buyTrain(BuyTrain action) {

<span class="fc" id="L2857">        Train train = action.getTrain();</span>
<span class="fc" id="L2858">        PublicCompany company = action.getCompany();</span>
<span class="fc" id="L2859">        String companyName = company.getId();</span>
<span class="fc" id="L2860">        Train exchangedTrain = action.getExchangedTrain();</span>
<span class="fc" id="L2861">        SpecialTrainBuy stb = null;</span>

<span class="fc" id="L2863">        String errMsg = null;</span>
<span class="fc" id="L2864">        int presidentCash = action.getPresidentCashToAdd();</span>
<span class="fc" id="L2865">        boolean presidentMustSellShares = false;</span>
<span class="fc" id="L2866">        int price = action.getPricePaid();</span>
<span class="fc" id="L2867">        int actualPresidentCash = 0;</span>
<span class="fc" id="L2868">        int cashToBeRaisedByPresident = 0;</span>
<span class="fc" id="L2869">        Player currentPlayer = operatingCompany.value().getPresident();</span>

        // Dummy loop to enable a quick jump out.
        while (true) {
            // Checks
            // Must be correct step
<span class="pc bpc" id="L2875" title="1 of 2 branches missed.">            if (getStep() != GameDef.OrStep.BUY_TRAIN) {</span>
<span class="nc" id="L2876">                errMsg = LocalText.getText(&quot;WrongActionNoTrainBuyingCost&quot;);</span>
<span class="nc" id="L2877">                break;</span>
            }

<span class="pc bpc" id="L2880" title="1 of 2 branches missed.">            if (train == null) {</span>
<span class="nc" id="L2881">                errMsg = LocalText.getText(&quot;NoTrainSpecified&quot;);</span>
<span class="nc" id="L2882">                break;</span>
            }

            // Amount must be non-negative
<span class="pc bpc" id="L2886" title="1 of 2 branches missed.">            if (price &lt; 0) {</span>
<span class="nc" id="L2887">                errMsg =</span>
<span class="nc" id="L2888">                        LocalText.getText(&quot;NegativeAmountNotAllowed&quot;,</span>
<span class="nc" id="L2889">                                Bank.format(this, price));</span>
<span class="nc" id="L2890">                break;</span>
            }

            // Fixed price must be honoured
<span class="fc" id="L2894">            int fixedPrice = action.getFixedCost();</span>
<span class="pc bpc" id="L2895" title="1 of 4 branches missed.">            if (fixedPrice != 0 &amp;&amp; fixedPrice != price) {</span>
<span class="nc" id="L2896">                errMsg =</span>
<span class="nc" id="L2897">                        LocalText.getText(&quot;FixedPriceNotPaid&quot;,</span>
<span class="nc" id="L2898">                                Bank.format(this, price),</span>
<span class="nc" id="L2899">                                Bank.format(this, fixedPrice));</span>
            }

            // Does the company have room for another train?
<span class="fc" id="L2903">            int trainLimit = operatingCompany.value().getCurrentTrainLimit();</span>
<span class="pc bpc" id="L2904" title="1 of 4 branches missed.">            if (!canBuyTrainNow() &amp;&amp; !action.isForExchange()) {</span>
<span class="nc" id="L2905">                errMsg =</span>
<span class="nc" id="L2906">                        LocalText.getText(&quot;WouldExceedTrainLimit&quot;,</span>
<span class="nc" id="L2907">                                String.valueOf(trainLimit));</span>
<span class="nc" id="L2908">                break;</span>
            }

            /* Check if this is an emergency buy */
<span class="fc bfc" id="L2912" title="All 2 branches covered.">            if (action.mustPresidentAddCash()) {</span>
                // From the Bank
<span class="fc" id="L2914">                presidentCash = action.getPresidentCashToAdd();</span>
<span class="fc bfc" id="L2915" title="All 2 branches covered.">                if (currentPlayer.getCashValue() &gt;= presidentCash) {</span>
<span class="fc" id="L2916">                    actualPresidentCash = presidentCash;</span>
                } else {
<span class="fc" id="L2918">                    presidentMustSellShares = true;</span>
<span class="fc" id="L2919">                    cashToBeRaisedByPresident =</span>
<span class="fc" id="L2920">                            presidentCash - currentPlayer.getCashValue();</span>
                }
<span class="fc bfc" id="L2922" title="All 2 branches covered.">            } else if (action.mayPresidentAddCash()) {</span>
                // From another company
<span class="fc" id="L2924">                presidentCash = price - operatingCompany.value().getCash();</span>
<span class="pc bpc" id="L2925" title="1 of 2 branches missed.">                if (presidentCash &gt; action.getPresidentCashToAdd()) {</span>
<span class="nc" id="L2926">                    errMsg =</span>
<span class="nc" id="L2927">                            LocalText.getText(</span>
                                    &quot;PresidentMayNotAddMoreThan&quot;,
<span class="nc" id="L2929">                                    Bank.format(this,</span>
<span class="nc" id="L2930">                                            action.getPresidentCashToAdd()));</span>
<span class="nc" id="L2931">                    break;</span>
<span class="pc bpc" id="L2932" title="1 of 2 branches missed.">                } else if (currentPlayer.getCashValue() &gt;= presidentCash) {</span>
<span class="fc" id="L2933">                    actualPresidentCash = presidentCash;</span>
                } else {
<span class="nc" id="L2935">                    presidentMustSellShares = true;</span>
<span class="nc" id="L2936">                    cashToBeRaisedByPresident =</span>
<span class="nc" id="L2937">                            presidentCash - currentPlayer.getCashValue();</span>
                }

            } else {
                // No forced buy - does the company have the money?
<span class="pc bpc" id="L2942" title="1 of 2 branches missed.">                if (price &gt; operatingCompany.value().getCash()) {</span>
<span class="nc" id="L2943">                    errMsg =</span>
<span class="nc" id="L2944">                            LocalText.getText(</span>
                                    &quot;NotEnoughMoney&quot;,
                                    companyName,
<span class="nc" id="L2947">                                    Bank.format(this,</span>
<span class="nc" id="L2948">                                            operatingCompany.value().getCash()),</span>
<span class="nc" id="L2949">                                    Bank.format(this, price));</span>
<span class="nc" id="L2950">                    break;</span>
                }
            }

<span class="fc bfc" id="L2954" title="All 2 branches covered.">            if (action.isForExchange()) {</span>
<span class="pc bpc" id="L2955" title="1 of 2 branches missed.">                if (exchangedTrain == null) {</span>
<span class="nc" id="L2956">                    errMsg = LocalText.getText(&quot;NoExchangedTrainSpecified&quot;);</span>
                    // TEMPORARY FIX to clean up invalidated saved files - DOES
                    // NOT WORK!!??
                    // exchangedTrain =
                    // operatingCompany.getObject().getPortfolio().getTrainList().get(0);
                    // action.setExchangedTrain(exchangedTrain);
<span class="nc" id="L2962">                    break;</span>
<span class="pc bpc" id="L2963" title="1 of 2 branches missed.">                } else if (operatingCompany.value().getPortfolioModel().getTrainOfType(</span>
<span class="fc" id="L2964">                        exchangedTrain.getCertType()) == null) {</span>
<span class="nc" id="L2965">                    errMsg =</span>
<span class="nc" id="L2966">                            LocalText.getText(&quot;CompanyDoesNotOwnTrain&quot;,</span>
<span class="nc" id="L2967">                                    operatingCompany.value().getId(),</span>
<span class="nc" id="L2968">                                    exchangedTrain.toText());</span>
<span class="nc" id="L2969">                    break;</span>
                }
            }

<span class="fc" id="L2973">            stb = action.getSpecialProperty();</span>
            // TODO Note: this is not yet validated

<span class="fc" id="L2976">            break;</span>
        }

<span class="pc bpc" id="L2979" title="1 of 2 branches missed.">        if (errMsg != null) {</span>
<span class="nc" id="L2980">            DisplayBuffer.add(</span>
                    this,
<span class="nc" id="L2982">                    LocalText.getText(&quot;CannotBuyTrainFor&quot;, companyName,</span>
<span class="nc" id="L2983">                            train.toText(), Bank.format(this, price), errMsg));</span>
<span class="nc" id="L2984">            return false;</span>
        }

        /* End of validation, start of execution */

<span class="fc" id="L2989">        Phase previousPhase = Phase.getCurrent(this);</span>

<span class="fc bfc" id="L2991" title="All 2 branches covered.">        if (presidentMustSellShares) {</span>
<span class="fc" id="L2992">            savedAction = action;</span>

<span class="fc" id="L2994">            gameManager.startShareSellingRound(</span>
<span class="fc" id="L2995">                    operatingCompany.value().getPresident(),</span>
<span class="fc" id="L2996">                    cashToBeRaisedByPresident, operatingCompany.value(), true);</span>

<span class="fc" id="L2998">            return true;</span>
        }

<span class="fc bfc" id="L3001" title="All 2 branches covered.">        if (actualPresidentCash &gt; 0) {</span>
            // FIXME: It used to be presidentCash, should it not have been
            // actualPresidentCash
            // MoneyModel.cashMove(currentPlayer, operatingCompany.value(),
            // presidentCash);
<span class="fc" id="L3006">            String cashText =</span>
<span class="fc" id="L3007">                    Currency.wire(currentPlayer, actualPresidentCash,</span>
<span class="fc" id="L3008">                            operatingCompany.value());</span>
<span class="fc" id="L3009">            ReportBuffer.add(this, LocalText.getText(&quot;PresidentAddsCash&quot;,</span>
<span class="fc" id="L3010">                    operatingCompany.value().getId(), currentPlayer.getId(),</span>
                    cashText));
        }

<span class="fc" id="L3014">        Owner oldOwner = train.getOwner();</span>

<span class="fc bfc" id="L3016" title="All 2 branches covered.">        if (exchangedTrain != null) {</span>
<span class="fc" id="L3017">            Train oldTrain =</span>
<span class="fc" id="L3018">                    operatingCompany.value().getPortfolioModel().getTrainOfType(</span>
<span class="fc" id="L3019">                            exchangedTrain.getCertType());</span>
<span class="pc bpc" id="L3020" title="1 of 2 branches missed.">            (train.isObsolete() ? scrapHeap : pool).addTrain(oldTrain);</span>
<span class="fc" id="L3021">            ReportBuffer.add(this, LocalText.getText(&quot;ExchangesTrain&quot;,</span>
<span class="fc" id="L3022">                    companyName, exchangedTrain.toText(), train.toText(),</span>
<span class="fc" id="L3023">                    oldOwner.getId(), Bank.format(this, price)));</span>
<span class="fc bfc" id="L3024" title="All 2 branches covered.">        } else if (stb == null) {</span>
<span class="fc" id="L3025">            ReportBuffer.add(this, LocalText.getText(&quot;BuysTrain&quot;, companyName,</span>
<span class="fc" id="L3026">                    train.toText(), oldOwner.getId(), Bank.format(this, price)));</span>
        } else {
<span class="fc" id="L3028">            ReportBuffer.add(this, LocalText.getText(&quot;BuysTrainUsingSP&quot;,</span>
<span class="fc" id="L3029">                    companyName, train.toText(), oldOwner.getId(),</span>
<span class="fc" id="L3030">                    Bank.format(this, price), stb.getOriginalCompany().getId()));</span>
        }

<span class="fc" id="L3033">        train.setType(action.getType()); // Needed for dual trains bought from</span>
                                         // the Bank

<span class="fc" id="L3036">        operatingCompany.value().buyTrain(train, price);</span>

<span class="fc bfc" id="L3038" title="All 2 branches covered.">        if (oldOwner == ipo.getParent()) {</span>
<span class="fc" id="L3039">            train.getCertType().addToBoughtFromIPO();</span>
<span class="fc" id="L3040">            trainManager.setAnyTrainBought(true);</span>
            // Clone the train if infinitely available
<span class="fc bfc" id="L3042" title="All 2 branches covered.">            if (train.getCertType().hasInfiniteQuantity()) {</span>
<span class="fc" id="L3043">                ipo.addTrain(trainManager.cloneTrain(train.getCertType()));</span>
            }

        }
<span class="fc bfc" id="L3047" title="All 2 branches covered.">        if (oldOwner instanceof BankPortfolio) {</span>
<span class="fc" id="L3048">            trainsBoughtThisTurn.add(train.getCertType());</span>
        }

<span class="fc bfc" id="L3051" title="All 2 branches covered.">        if (stb != null) {</span>
<span class="fc" id="L3052">            stb.setExercised();</span>
<span class="fc" id="L3053">            log.debug(&quot;This was a special train buy&quot;);</span>
        }

        // Check if the phase has changed.
<span class="fc" id="L3057">        trainManager.checkTrainAvailability(train, oldOwner);</span>

        // Check if any companies must discard trains
<span class="fc bfc" id="L3060" title="All 4 branches covered.">        if (Phase.getCurrent(this) != previousPhase &amp;&amp; checkForExcessTrains()) {</span>
<span class="fc" id="L3061">            stepObject.set(GameDef.OrStep.DISCARD_TRAINS);</span>
        }

<span class="fc bfc" id="L3064" title="All 2 branches covered.">        if (trainManager.hasPhaseChanged()) newPhaseChecks();</span>

<span class="fc" id="L3066">        return true;</span>
    }

    /**
     * Can the operating company buy a train now? Normally only calls
     * isBelowTrainLimit() to get the result. May be overridden if other
     * considerations apply (such as having a Pullmann in 18EU).
     *
     * @return
     */
    protected boolean canBuyTrainNow() {
<span class="fc" id="L3077">        return isBelowTrainLimit();</span>
    }

    public boolean checkForExcessTrains() {

<span class="fc" id="L3082">        excessTrainCompanies = new HashMap&lt;Player, List&lt;PublicCompany&gt;&gt;();</span>
        Player player;
<span class="fc bfc" id="L3084" title="All 2 branches covered.">        for (PublicCompany comp : operatingCompanies.view()) {</span>
<span class="fc bfc" id="L3085" title="All 2 branches covered.">            if (comp.getPortfolioModel().getNumberOfTrains() &gt; comp.getCurrentTrainLimit()) {</span>
<span class="fc" id="L3086">                player = comp.getPresident();</span>
<span class="pc bpc" id="L3087" title="1 of 2 branches missed.">                if (!excessTrainCompanies.containsKey(player)) {</span>
<span class="fc" id="L3088">                    excessTrainCompanies.put(player,</span>
                            new ArrayList&lt;PublicCompany&gt;(2));
                }
<span class="fc" id="L3091">                excessTrainCompanies.get(player).add(comp);</span>
            }

<span class="fc" id="L3094">        }</span>
<span class="fc bfc" id="L3095" title="All 2 branches covered.">        return !excessTrainCompanies.isEmpty();</span>
    }

    /** Stub */
<span class="fc" id="L3099">    protected void newPhaseChecks() {}</span>

    /**
     * Get a list of buyable trains for the currently operating company. Omit
     * trains that the company has no money for. If there is no cash to buy any
     * train from the Bank, prepare for emergency train buying.
     */
    public void setBuyableTrains() {

<span class="pc bpc" id="L3108" title="1 of 2 branches missed.">        if (operatingCompany.value() == null) return;</span>

<span class="fc" id="L3110">        int cash = operatingCompany.value().getCash();</span>

<span class="fc" id="L3112">        int cost = 0;</span>
        Set&lt;Train&gt; trains;

<span class="fc" id="L3115">        boolean hasTrains =</span>
<span class="fc bfc" id="L3116" title="All 2 branches covered.">                operatingCompany.value().getPortfolioModel().getNumberOfTrains() &gt; 0;</span>

        // Cannot buy a train without any cash, unless you have to
<span class="pc bpc" id="L3119" title="1 of 4 branches missed.">        if (cash == 0 &amp;&amp; hasTrains) return;</span>

<span class="fc" id="L3121">        boolean canBuyTrainNow = canBuyTrainNow();</span>
<span class="fc bfc" id="L3122" title="All 2 branches covered.">        boolean mustBuyTrain =</span>
<span class="fc bfc" id="L3123" title="All 2 branches covered.">                !hasTrains &amp;&amp; operatingCompany.value().mustOwnATrain();</span>
<span class="fc" id="L3124">        boolean emergency = false;</span>

<span class="fc" id="L3126">        SortedMap&lt;Integer, Train&gt; newEmergencyTrains =</span>
                new TreeMap&lt;Integer, Train&gt;();
<span class="fc" id="L3128">        SortedMap&lt;Integer, Train&gt; usedEmergencyTrains =</span>
                new TreeMap&lt;Integer, Train&gt;();

        // First check if any more trains may be bought from the Bank
        // Postpone train limit checking, because an exchange might be possible
<span class="fc bfc" id="L3133" title="All 2 branches covered.">        if (Phase.getCurrent(this).canBuyMoreTrainsPerTurn()</span>
<span class="fc bfc" id="L3134" title="All 2 branches covered.">            || trainsBoughtThisTurn.isEmpty()) {</span>
<span class="fc" id="L3135">            boolean mayBuyMoreOfEachType =</span>
<span class="fc" id="L3136">                    Phase.getCurrent(this).canBuyMoreTrainsPerTypePerTurn();</span>

            /* New trains */
<span class="fc" id="L3139">            trains = trainManager.getAvailableNewTrains();</span>
<span class="fc bfc" id="L3140" title="All 2 branches covered.">            for (Train train : trains) {</span>
<span class="pc bpc" id="L3141" title="1 of 2 branches missed.">                if (!operatingCompany.value().mayBuyTrainType(train)) continue;</span>
<span class="pc bpc" id="L3142" title="1 of 2 branches missed.">                if (!mayBuyMoreOfEachType</span>
<span class="nc bnc" id="L3143" title="All 2 branches missed.">                    &amp;&amp; trainsBoughtThisTurn.contains(train.getCertType())) {</span>
<span class="nc" id="L3144">                    continue;</span>
                }

                // Allow dual trains (since jun 2011)
<span class="fc" id="L3148">                List&lt;TrainType&gt; types =</span>
<span class="fc" id="L3149">                        train.getCertType().getPotentialTrainTypes();</span>
<span class="fc bfc" id="L3150" title="All 2 branches covered.">                for (TrainType type : types) {</span>
<span class="fc" id="L3151">                    cost = type.getCost();</span>
<span class="fc bfc" id="L3152" title="All 2 branches covered.">                    if (cost &lt;= cash) {</span>
<span class="fc bfc" id="L3153" title="All 2 branches covered.">                        if (canBuyTrainNow) {</span>
<span class="fc" id="L3154">                            BuyTrain action =</span>
<span class="fc" id="L3155">                                    new BuyTrain(train, type, ipo.getParent(),</span>
                                            cost);
<span class="fc" id="L3157">                            action.setForcedBuyIfNoRoute(mustBuyTrain); // TEMPORARY</span>
<span class="fc" id="L3158">                            possibleActions.add(action);</span>
<span class="fc" id="L3159">                        }</span>
<span class="fc bfc" id="L3160" title="All 2 branches covered.">                    } else if (mustBuyTrain) {</span>
<span class="fc" id="L3161">                        newEmergencyTrains.put(cost, train);</span>
                    }
<span class="fc" id="L3163">                }</span>

                // Even at train limit, exchange is allowed (per 1856)
<span class="fc bfc" id="L3166" title="All 4 branches covered.">                if (train.canBeExchanged() &amp;&amp; hasTrains) {</span>
<span class="fc" id="L3167">                    cost = train.getCertType().getExchangeCost();</span>
<span class="fc bfc" id="L3168" title="All 2 branches covered.">                    if (cost &lt;= cash) {</span>
<span class="fc" id="L3169">                        Set&lt;Train&gt; exchangeableTrains =</span>
<span class="fc" id="L3170">                                operatingCompany.value().getPortfolioModel().getUniqueTrains();</span>
<span class="fc" id="L3171">                        BuyTrain action =</span>
<span class="fc" id="L3172">                                new BuyTrain(train, ipo.getParent(), cost);</span>
<span class="fc" id="L3173">                        action.setTrainsForExchange(exchangeableTrains);</span>
                        // if (atTrainLimit) action.setForcedExchange(true);
<span class="fc" id="L3175">                        possibleActions.add(action);</span>
<span class="fc" id="L3176">                        canBuyTrainNow = true;</span>
                    }
                }

<span class="fc bfc" id="L3180" title="All 2 branches covered.">                if (!canBuyTrainNow) continue;</span>

                // Can a special property be used?
                // N.B. Assume that this never occurs in combination with
                // dual trains or train exchanges,
                // otherwise the below code must be duplicated above.
<span class="fc bfc" id="L3186" title="All 2 branches covered.">                for (SpecialTrainBuy stb : getSpecialProperties(SpecialTrainBuy.class)) {</span>
<span class="fc" id="L3187">                    int reducedPrice = stb.getPrice(cost);</span>
<span class="pc bpc" id="L3188" title="1 of 2 branches missed.">                    if (reducedPrice &gt; cash) continue;</span>
<span class="fc" id="L3189">                    BuyTrain bt =</span>
<span class="fc" id="L3190">                            new BuyTrain(train, ipo.getParent(), reducedPrice);</span>
<span class="fc" id="L3191">                    bt.setSpecialProperty(stb);</span>
<span class="fc" id="L3192">                    bt.setForcedBuyIfNoRoute(mustBuyTrain); // TEMPORARY</span>
<span class="fc" id="L3193">                    possibleActions.add(bt);</span>
<span class="fc" id="L3194">                }</span>

<span class="fc" id="L3196">            }</span>
<span class="fc bfc" id="L3197" title="All 2 branches covered.">            if (!canBuyTrainNow) return;</span>

            /* Used trains */
<span class="fc" id="L3200">            trains = pool.getUniqueTrains();</span>
<span class="fc bfc" id="L3201" title="All 2 branches covered.">            for (Train train : trains) {</span>
<span class="pc bpc" id="L3202" title="1 of 2 branches missed.">                if (!mayBuyMoreOfEachType</span>
<span class="nc bnc" id="L3203" title="All 2 branches missed.">                    &amp;&amp; trainsBoughtThisTurn.contains(train.getCertType())) {</span>
<span class="nc" id="L3204">                    continue;</span>
                }
<span class="fc" id="L3206">                cost = train.getCost();</span>
<span class="fc bfc" id="L3207" title="All 2 branches covered.">                if (cost &lt;= cash) {</span>
<span class="fc" id="L3208">                    BuyTrain bt = new BuyTrain(train, pool.getParent(), cost);</span>
<span class="fc" id="L3209">                    bt.setForcedBuyIfNoRoute(mustBuyTrain); // TEMPORARY</span>
<span class="fc" id="L3210">                    possibleActions.add(bt);</span>
<span class="pc bpc" id="L3211" title="1 of 2 branches missed.">                } else if (mustBuyTrain) {</span>
<span class="nc" id="L3212">                    usedEmergencyTrains.put(cost, train);</span>
                }
<span class="fc" id="L3214">            }</span>

<span class="fc bfc" id="L3216" title="All 2 branches covered.">            emergency =</span>
                    mustBuyTrain
<span class="fc bfc" id="L3218" title="All 2 branches covered.">                            &amp;&amp; possibleActions.getType(BuyTrain.class).isEmpty();</span>

            // If we must buy a train and haven't found one yet, the president
            // must add cash.
<span class="fc bfc" id="L3222" title="All 2 branches covered.">            if (emergency</span>
                // Some people think it's allowed in 1835 to buy a new train
                // with president cash
                // even if the company has enough cash to buy a used train.
                // Players who think differently can ignore that extra option.
<span class="fc bfc" id="L3227" title="All 2 branches covered.">                || GameDef.getGameParameterAsBoolean(this, GameDef.Parm.EMERGENCY_MAY_ALWAYS_BUY_NEW_TRAIN)</span>
<span class="fc bfc" id="L3228" title="All 2 branches covered.">                &amp;&amp; !newEmergencyTrains.isEmpty()) {</span>
<span class="fc bfc" id="L3229" title="All 2 branches covered.">                if (GameDef.getGameParameterAsBoolean(this, GameDef.Parm.EMERGENCY_MUST_BUY_CHEAPEST_TRAIN)) {</span>
                    // Find the cheapest one
                    // Assume there is always one available from IPO
<span class="fc" id="L3232">                    int cheapestTrainCost = newEmergencyTrains.firstKey();</span>
<span class="fc" id="L3233">                    Train cheapestTrain =</span>
<span class="fc" id="L3234">                            newEmergencyTrains.get(cheapestTrainCost);</span>
<span class="pc bpc" id="L3235" title="1 of 2 branches missed.">                    if (!usedEmergencyTrains.isEmpty()</span>
<span class="nc bnc" id="L3236" title="All 2 branches missed.">                        &amp;&amp; usedEmergencyTrains.firstKey() &lt; cheapestTrainCost) {</span>
<span class="nc" id="L3237">                        cheapestTrainCost = usedEmergencyTrains.firstKey();</span>
<span class="nc" id="L3238">                        cheapestTrain =</span>
<span class="nc" id="L3239">                                usedEmergencyTrains.get(cheapestTrainCost);</span>
                    }
<span class="fc" id="L3241">                    BuyTrain bt =</span>
                            new BuyTrain(cheapestTrain,
<span class="fc" id="L3243">                                    cheapestTrain.getOwner(), cheapestTrainCost);</span>
<span class="fc" id="L3244">                    bt.setPresidentMustAddCash(cheapestTrainCost - cash);</span>
<span class="fc" id="L3245">                    bt.setForcedBuyIfNoRoute(mustBuyTrain); // TODO TEMPORARY</span>
<span class="fc" id="L3246">                    possibleActions.add(bt);</span>
<span class="fc" id="L3247">                } else {</span>
                    // All possible bank trains are buyable
<span class="fc bfc" id="L3249" title="All 2 branches covered.">                    for (Train train : newEmergencyTrains.values()) {</span>
<span class="fc" id="L3250">                        BuyTrain bt =</span>
<span class="fc" id="L3251">                                new BuyTrain(train, ipo.getParent(),</span>
<span class="fc" id="L3252">                                        train.getCost());</span>
<span class="fc" id="L3253">                        bt.setPresidentMustAddCash(train.getCost() - cash);</span>
<span class="fc" id="L3254">                        bt.setForcedBuyIfNoRoute(mustBuyTrain); // TODO</span>
                                                                // TEMPORARY
<span class="fc" id="L3256">                        possibleActions.add(bt);</span>
<span class="fc" id="L3257">                    }</span>
<span class="pc bpc" id="L3258" title="1 of 2 branches missed.">                    for (Train train : usedEmergencyTrains.values()) {</span>
<span class="nc" id="L3259">                        BuyTrain bt =</span>
<span class="nc" id="L3260">                                new BuyTrain(train, pool.getParent(),</span>
<span class="nc" id="L3261">                                        train.getCost());</span>
<span class="nc" id="L3262">                        bt.setPresidentMustAddCash(train.getCost() - cash);</span>
<span class="nc" id="L3263">                        bt.setForcedBuyIfNoRoute(mustBuyTrain); // TODO</span>
                                                                // TEMPORARY
<span class="nc" id="L3265">                        possibleActions.add(bt);</span>
<span class="nc" id="L3266">                    }</span>
                }
            }
        }

<span class="pc bpc" id="L3271" title="1 of 2 branches missed.">        if (!canBuyTrainNow) return;</span>

        /* Other company trains, sorted by president (current player first) */
<span class="fc bfc" id="L3274" title="All 2 branches covered.">        if (Phase.getCurrent(this).isTrainTradingAllowed()) {</span>
            BuyTrain bt;
            Player p;
            int index;
<span class="fc" id="L3278">            int numberOfPlayers = playerManager.getNumberOfPlayers();</span>
<span class="fc" id="L3279">            int presidentCash =</span>
<span class="fc" id="L3280">                    operatingCompany.value().getPresident().getCashValue();</span>

            // Set up a list per player of presided companies
<span class="fc" id="L3283">            List&lt;List&lt;PublicCompany&gt;&gt; companiesPerPlayer =</span>
                    new ArrayList&lt;List&lt;PublicCompany&gt;&gt;(numberOfPlayers);
<span class="fc bfc" id="L3285" title="All 2 branches covered.">            for (int i = 0; i &lt; numberOfPlayers; i++)</span>
<span class="fc" id="L3286">                companiesPerPlayer.add(new ArrayList&lt;PublicCompany&gt;(4));</span>
            List&lt;PublicCompany&gt; companies;
            // Sort out which players preside over which companies.
<span class="fc bfc" id="L3289" title="All 2 branches covered.">            for (PublicCompany c : companyManager.getAllPublicCompanies()) {</span>
<span class="fc bfc" id="L3290" title="All 2 branches covered.">                if (!c.hasFloated()) continue;</span>
<span class="fc bfc" id="L3291" title="All 4 branches covered.">                if (c.isClosed() || c == operatingCompany.value()) continue;</span>
<span class="fc" id="L3292">                p = c.getPresident();</span>
<span class="fc" id="L3293">                index = p.getIndex();</span>
<span class="fc" id="L3294">                companiesPerPlayer.get(index).add(c);</span>
<span class="fc" id="L3295">            }</span>
            // Scan trains per company per player, operating company president
            // first
<span class="fc" id="L3298">            int currentPlayerIndex =</span>
<span class="fc" id="L3299">                    playerManager.getCurrentPlayer().getIndex();</span>
<span class="fc bfc" id="L3300" title="All 2 branches covered.">            for (int i = currentPlayerIndex; i &lt; currentPlayerIndex</span>
<span class="fc" id="L3301">                                                 + numberOfPlayers; i++) {</span>
<span class="fc" id="L3302">                companies = companiesPerPlayer.get(i % numberOfPlayers);</span>
<span class="fc bfc" id="L3303" title="All 2 branches covered.">                for (PublicCompany company : companies) {</span>
<span class="fc" id="L3304">                    trains = company.getPortfolioModel().getUniqueTrains();</span>
<span class="fc bfc" id="L3305" title="All 2 branches covered.">                    for (Train train : trains) {</span>
<span class="pc bpc" id="L3306" title="1 of 4 branches missed.">                        if (train.isObsolete() || !train.isTradeable())</span>
<span class="nc" id="L3307">                            continue;</span>
<span class="fc" id="L3308">                        bt = null;</span>
<span class="fc bfc" id="L3309" title="All 2 branches covered.">                        if (i != currentPlayerIndex</span>
<span class="fc bfc" id="L3310" title="All 2 branches covered.">                            &amp;&amp; GameDef.getGameParameterAsBoolean(this, GameDef.Parm.FIXED_PRICE_TRAINS_BETWEEN_PRESIDENTS)</span>
<span class="fc bfc" id="L3311" title="All 2 branches covered.">                            || operatingCompany.value().mustTradeTrainsAtFixedPrice()</span>
<span class="fc bfc" id="L3312" title="All 2 branches covered.">                            || company.mustTradeTrainsAtFixedPrice()) {</span>
                            // Fixed price
<span class="fc bfc" id="L3314" title="All 2 branches covered.">                            if ((cash &gt;= train.getCost())</span>
<span class="fc bfc" id="L3315" title="All 2 branches covered.">                                &amp;&amp; (operatingCompany.value().mayBuyTrainType(train))) {</span>
                                // TODO: Check if this still works, as now the
                                // company is the from type
<span class="fc" id="L3318">                                bt =</span>
                                        new BuyTrain(train, company,
<span class="fc" id="L3320">                                                train.getCost());</span>
                            } else {
                                continue;
                            }
<span class="pc bpc" id="L3324" title="3 of 4 branches missed.">                        } else if (cash &gt; 0</span>
                                   || emergency
<span class="nc bnc" id="L3326" title="All 2 branches missed.">                                   &amp;&amp; GameDef.getGameParameterAsBoolean(this, GameDef.Parm.EMERGENCY_MAY_BUY_FROM_COMPANY)) {</span>
                            // TODO: Check if this still works, as now the
                            // company is the from type
<span class="fc" id="L3329">                            bt = new BuyTrain(train, company, 0);</span>

                            // In some games the president may add extra cash up
                            // to the list price
<span class="fc bfc" id="L3333" title="All 4 branches covered.">                            if (emergency &amp;&amp; cash &lt; train.getCost()) {</span>
<span class="fc" id="L3334">                                bt.setPresidentMayAddCash(Math.min(</span>
<span class="fc" id="L3335">                                        train.getCost() - cash, presidentCash));</span>
                            }
                        }
<span class="pc bpc" id="L3338" title="1 of 2 branches missed.">                        if (bt != null) possibleActions.add(bt);</span>
<span class="fc" id="L3339">                    }</span>
<span class="fc" id="L3340">                }</span>
            }
        }

<span class="fc bfc" id="L3344" title="All 2 branches covered.">        if (!operatingCompany.value().mustOwnATrain()</span>
<span class="fc bfc" id="L3345" title="All 2 branches covered.">            || operatingCompany.value().getPortfolioModel().getNumberOfTrains() &gt; 0) {</span>
<span class="fc" id="L3346">            doneAllowed = true;</span>
        }
<span class="fc" id="L3348">    }</span>

    /**
     * Returns whether or not the company is allowed to buy a train, considering
     * its train limit.
     *
     * @return
     */
    protected boolean isBelowTrainLimit() {
<span class="fc bfc" id="L3357" title="All 2 branches covered.">        return operatingCompany.value().getNumberOfTrains() &lt; operatingCompany.value().getCurrentTrainLimit();</span>
    }

    public void checkForeignSales() {
<span class="pc bpc" id="L3361" title="1 of 2 branches missed.">        if (GameDef.getGameParameterAsBoolean(this, GameDef.Parm.REMOVE_TRAIN_BEFORE_SR)</span>
<span class="nc bnc" id="L3362" title="All 2 branches missed.">            &amp;&amp; trainManager.isAnyTrainBought()) {</span>
<span class="nc" id="L3363">            Train train =</span>
<span class="nc" id="L3364">                    Iterables.get(trainManager.getAvailableNewTrains(), 0);</span>
<span class="nc bnc" id="L3365" title="All 2 branches missed.">            if (train.getCertType().hasInfiniteQuantity()) return;</span>
<span class="nc" id="L3366">            scrapHeap.addTrain(train);</span>
<span class="nc" id="L3367">            ReportBuffer.add(this,</span>
<span class="nc" id="L3368">                    LocalText.getText(&quot;RemoveTrain&quot;, train.toText()));</span>
        }
<span class="fc" id="L3370">    }</span>

    /*
     * ======================================= 8. VARIOUS UTILITIES
     * =======================================
     */

    protected &lt;T extends SpecialProperty&gt; List&lt;T&gt; getSpecialProperties(
            Class&lt;T&gt; clazz) {
<span class="fc" id="L3379">        List&lt;T&gt; specialProperties = new ArrayList&lt;T&gt;();</span>
<span class="pc bpc" id="L3380" title="1 of 2 branches missed.">        if (!operatingCompany.value().isClosed()) {</span>
            // OC may have closed itself (e.g. in 1835 when M2 buys 1st 4T and
            // starts PR)
<span class="fc" id="L3383">            specialProperties.addAll(operatingCompany.value().getPortfolioModel().getSpecialProperties(</span>
                    clazz, false));
<span class="fc" id="L3385">            specialProperties.addAll(operatingCompany.value().getPresident().getPortfolioModel().getSpecialProperties(</span>
                    clazz, false));
        }
<span class="fc" id="L3388">        return specialProperties;</span>
    }

    /**
     * Update the status if the step has changed by an Undo or Redo
     */
    public void update(String text) {
<span class="fc" id="L3395">        prepareStep();</span>
<span class="fc" id="L3396">    }</span>

    @Override
    public String toString() {
<span class="fc" id="L3400">        return &quot;OperatingRound &quot; + thisOrNumber;</span>
    }

    /** @Overrides */
    public boolean equals(RoundFacade round) {
<span class="nc bnc" id="L3405" title="All 2 branches missed.">        return round instanceof OperatingRound</span>
<span class="nc bnc" id="L3406" title="All 2 branches missed.">               &amp;&amp; thisOrNumber.equals(((OperatingRound) round).thisOrNumber);</span>
    }

    @Override
    public String getRoundName() {
<span class="fc" id="L3411">        return toString();</span>
    }

    // Observer methods
    public Observable getObservable() {
<span class="nc" id="L3416">        return stepObject;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>