<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TileUpgrade.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.game</a> &gt; <span class="el_source">TileUpgrade.java</span></div><h1>TileUpgrade.java</h1><pre class="source lang-java linenums">package net.sf.rails.game;

import com.google.common.base.MoreObjects;
import com.google.common.base.Predicate;
import com.google.common.collect.*;
import com.google.common.collect.Sets.SetView;
import net.sf.rails.common.LocalText;
import net.sf.rails.common.parser.ConfigurationException;
import net.sf.rails.common.parser.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

public class TileUpgrade implements Upgrade {

<span class="fc" id="L17">    private static final Logger log =</span>
<span class="fc" id="L18">            LoggerFactory.getLogger(TileUpgrade.class);</span>

    /**
     * Rotation defines the following details for a tile upgrade
     */
    public static class Rotation {
        private final HexSidesSet connectedSides;
        private final HexSidesSet sidesWithNewTrack;
        private final HexSide rotation;
        private final Map&lt;Station, Station&gt; stationMapping;
        private final Set&lt;Station&gt; stationsWithNewTrack;
        private final boolean symmetric;

        private Rotation(Set&lt;Track&gt; connectedTracks, Set&lt;Track&gt; newTracks, HexSide rotation,
<span class="fc" id="L32">                         Map&lt;Station, Station&gt; mapping, boolean symmetric) {</span>

<span class="fc" id="L34">            this.rotation = rotation;</span>
<span class="fc" id="L35">            this.stationMapping = mapping;</span>
<span class="fc" id="L36">            this.symmetric = symmetric;</span>

<span class="fc" id="L38">            HexSidesSet.Builder sidesBuilder = HexSidesSet.builder();</span>
<span class="fc bfc" id="L39" title="All 2 branches covered.">            for (Track t : connectedTracks) {</span>
<span class="fc bfc" id="L40" title="All 2 branches covered.">                if (t.getStart().getTrackPointType() == TrackPoint.Type.SIDE) {</span>
<span class="fc" id="L41">                    sidesBuilder.set((HexSide) t.getStart());</span>
                }
<span class="pc bpc" id="L43" title="1 of 2 branches missed.">                if (t.getEnd().getTrackPointType() == TrackPoint.Type.SIDE) {</span>
<span class="fc" id="L44">                    sidesBuilder.set((HexSide) t.getEnd());</span>
                }
<span class="fc" id="L46">            }</span>
<span class="fc" id="L47">            connectedSides = sidesBuilder.build();</span>

<span class="fc" id="L49">            sidesBuilder = HexSidesSet.builder();</span>
<span class="fc" id="L50">            ImmutableSet.Builder&lt;Station&gt; stationBuilder = ImmutableSet.builder();</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">            for (Track t : newTracks) {</span>
<span class="fc bfc" id="L52" title="All 2 branches covered.">                if (t.getStart().getTrackPointType() == TrackPoint.Type.SIDE) {</span>
<span class="fc" id="L53">                    sidesBuilder.set((HexSide) t.getStart());</span>
                } else {
<span class="fc" id="L55">                    stationBuilder.add((Station) t.getStart());</span>
                }
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">                if (t.getEnd().getTrackPointType() == TrackPoint.Type.SIDE) {</span>
<span class="fc" id="L58">                    sidesBuilder.set((HexSide) t.getEnd());</span>
                } else {
<span class="nc" id="L60">                    stationBuilder.add((Station) t.getEnd());</span>
                }
<span class="fc" id="L62">            }</span>
<span class="fc" id="L63">            stationsWithNewTrack = stationBuilder.build();</span>

            // Special condition for restrictive tile lays:
            // If a station with new track has more slots then the replaced station of the base tile
            // then all sides connecting to the station of the base tile are considered as
            // sides with new track as well
<span class="fc bfc" id="L69" title="All 4 branches covered.">            if (stationMapping != null &amp;&amp; !stationsWithNewTrack.isEmpty()) {</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">                for (Track t : connectedTracks) {</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">                    if (t.getStart().getTrackPointType() == TrackPoint.Type.STATION</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">                            &amp;&amp; t.getEnd().getTrackPointType() == TrackPoint.Type.SIDE) {</span>
<span class="fc" id="L73">                        Station start = (Station) t.getStart();</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">                        if (stationsWithNewTrack.contains(start)</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">                                &amp;&amp; stationMapping.containsKey(start)</span>
<span class="fc" id="L76">                                &amp;&amp; start.getBaseSlots()</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">                                &lt; stationMapping.get(start).getBaseSlots()) {</span>
<span class="nc" id="L78">                            sidesBuilder.set((HexSide) t.getEnd());</span>
                        }
                    }
<span class="fc" id="L81">                }</span>
            }
<span class="fc" id="L83">            sidesWithNewTrack = sidesBuilder.build();</span>
<span class="fc" id="L84">        }</span>

        public HexSidesSet getConnectedSides() {
<span class="nc" id="L87">            return connectedSides;</span>
        }

        public HexSidesSet getSidesWithNewTrack() {
<span class="nc" id="L91">            return sidesWithNewTrack;</span>
        }

        public Map&lt;Station, Station&gt; getStationMapping() {
<span class="fc" id="L95">            return stationMapping;</span>
        }

        public Set&lt;Station&gt; getStationsWithNewTrack() {
<span class="nc" id="L99">            return stationsWithNewTrack;</span>
        }

        public boolean isSymmetric() {
<span class="nc" id="L103">            return symmetric;</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L108">            return new StringBuilder().append(&quot;rotation = &quot;).append(rotation).append(&quot;, connectedSides = &quot;).</span>
<span class="fc" id="L109">                    append(connectedSides.toString()).append(&quot;, sidesWithNewTrack = &quot;).append(sidesWithNewTrack.toString()).</span>
<span class="fc" id="L110">                    append(&quot;, stationMapping = &quot;).append(stationMapping).append(&quot;, stationsWithNewTrack = &quot;).append(stationsWithNewTrack).toString();</span>
        }
    }

    /**
     * Tile to upgrade
     */
    private final Tile baseTile;

    /**
     * The upgrade tile number
     */
    private final String targetTileId;

    /**
     * Temporary Strings to exclude hexes and phases. This will be
     * processed at finishConfiguration.
     */
    private final String hexes;
    private final String phases;

    /**
     * The upgrade tile
     */
    private Tile targetTile;

    /**
     * Possible rotations given the trackConfiguration
     */
    private Map&lt;HexSide, Rotation&gt; rotations;
    private HexSidesSet rotationSides;

    /**
     * Hexes where the upgrade can be executed
     */
<span class="fc" id="L145">    private List&lt;MapHex&gt; allowedHexes = null;</span>

    /**
     * Hexes where the upgrade cannot be executed Only one of allowedHexes
     * and disallowedHexes should be used
     */
<span class="fc" id="L151">    private List&lt;MapHex&gt; disallowedHexes = null;</span>

    /**
     * Phases in which the upgrade can be executed.
     */
<span class="fc" id="L156">    private List&lt;Phase&gt; allowedPhases = null;</span>


<span class="fc" id="L159">    private TileUpgrade(Tile baseTile, String targetId, String hexes, String phases) {</span>
<span class="fc" id="L160">        this.baseTile = baseTile;</span>
<span class="fc" id="L161">        this.targetTileId = targetId;</span>
<span class="fc" id="L162">        this.hexes = hexes;</span>
<span class="fc" id="L163">        this.phases = phases;</span>
<span class="fc" id="L164">    }</span>

    public static List&lt;TileUpgrade&gt; createFromTags(Tile tile, List&lt;Tag&gt; upgradeTags)
            throws ConfigurationException {

<span class="fc" id="L169">        ImmutableList.Builder&lt;TileUpgrade&gt; allUpgrades = ImmutableList.builder();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        for (Tag upgradeTag : upgradeTags) {</span>
<span class="fc" id="L171">            String ids = upgradeTag.getAttributeAsString(&quot;id&quot;);</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">            if (ids == null) continue;</span>

<span class="fc" id="L174">            String hexes = upgradeTag.getAttributeAsString(&quot;hex&quot;);</span>
<span class="fc" id="L175">            String phases = upgradeTag.getAttributeAsString(&quot;phase&quot;);</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">            for (String sid : ids.split(&quot;,&quot;)) {</span>
                try {
<span class="fc" id="L179">                    TileUpgrade upgrade = new TileUpgrade(tile, sid, hexes, phases);</span>
<span class="fc" id="L180">                    allUpgrades.add(upgrade);</span>
<span class="nc" id="L181">                } catch (NumberFormatException e) {</span>
<span class="nc" id="L182">                    log.error(&quot;Catched Exception&quot;, e);</span>
<span class="nc" id="L183">                    throw new ConfigurationException(LocalText.getText(</span>
<span class="nc" id="L184">                            &quot;InvalidUpgrade&quot;, tile.toText(), sid));</span>
<span class="fc" id="L185">                }</span>
            }
<span class="fc" id="L187">        }</span>
<span class="fc" id="L188">        return allUpgrades.build();</span>
    }

    public static TileUpgrade createSpecific(Tile current, Tile specific) {
<span class="fc" id="L192">        TileUpgrade upgrade = new TileUpgrade(current, specific.getId(), null, null);</span>
        try {
<span class="fc" id="L194">            upgrade.finishConfiguration(current.getRoot());</span>
<span class="nc" id="L195">        } catch (ConfigurationException e) {</span>
<span class="nc" id="L196">            log.error(LocalText.getText(&quot;InvalidUpgrade&quot;,</span>
<span class="nc" id="L197">                    current.toText(), specific.toText()), e);</span>
<span class="fc" id="L198">        }</span>
<span class="fc" id="L199">        return upgrade;</span>
    }

    public void finishConfiguration(RailsRoot root) throws ConfigurationException {
<span class="fc" id="L203">        targetTile = root.getTileManager().getTile(targetTileId);</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (targetTile == null) {</span>
<span class="nc" id="L205">            throw new ConfigurationException(LocalText.getText(&quot;InvalidUpgrade&quot;,</span>
<span class="nc" id="L206">                    baseTile.toText(), targetTileId));</span>
        }
<span class="fc" id="L208">        initRotations();</span>
<span class="fc" id="L209">        parsePhases(root);</span>
<span class="fc" id="L210">        parseHexes(root);</span>
<span class="fc" id="L211">    }</span>

    public Tile getTargetTile() {
<span class="fc" id="L214">        return targetTile;</span>
    }

    public String getTileId() {
<span class="nc" id="L218">        return targetTileId;</span>
    }

    public boolean isAllowedForHex(MapHex hex) {
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (allowedHexes != null) {</span>
<span class="nc" id="L223">            return allowedHexes.contains(hex);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        } else if (disallowedHexes != null) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            return !disallowedHexes.contains(hex);</span>
        } else {
<span class="nc" id="L227">            return true;</span>
        }
    }

    public boolean isAllowedForPhase(Phase phase) {
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (allowedPhases != null</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                &amp;&amp; !allowedPhases.contains(phase)) {</span>
<span class="nc" id="L234">            return false;</span>
        } else {
<span class="nc" id="L236">            return true;</span>
        }
    }

    private void initRotations() {
<span class="fc" id="L241">        HexSidesSet.Builder sideBuilder = HexSidesSet.builder();</span>
<span class="fc" id="L242">        ImmutableMap.Builder&lt;HexSide, Rotation&gt; rotationBuilder = ImmutableMap.builder();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">        for (HexSide side : HexSide.all()) {</span>
<span class="fc" id="L244">            Rotation rotation = processRotations(side);</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">            if (rotation != null) {</span>
<span class="fc" id="L246">                sideBuilder.set(side);</span>
<span class="fc" id="L247">                rotationBuilder.put(side, rotation);</span>
            }
<span class="fc" id="L249">        }</span>
<span class="fc" id="L250">        rotationSides = sideBuilder.build();</span>
<span class="fc" id="L251">        rotations = rotationBuilder.build();</span>
<span class="fc" id="L252">    }</span>

    private void parsePhases(RailsRoot root) throws ConfigurationException {
<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (phases == null) return;</span>

<span class="fc" id="L257">        ImmutableList.Builder&lt;Phase&gt; phaseBuilder = ImmutableList.builder();</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">        for (String phaseName : phases.split(&quot;,&quot;)) {</span>
<span class="fc" id="L259">            Phase phase = root.getPhaseManager().getPhaseByName(phaseName);</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">            if (phase == null) {</span>
<span class="nc" id="L261">                throw new ConfigurationException(LocalText.getText(</span>
                        &quot;IllegalPhaseDefinition&quot;,
<span class="nc" id="L263">                        this.toString()</span>
                ));
            } else {
<span class="fc" id="L266">                phaseBuilder.add(phase);</span>
            }
        }
<span class="fc" id="L269">        allowedPhases = phaseBuilder.build();</span>
<span class="fc" id="L270">    }</span>

    private List&lt;MapHex&gt; parseHexString(RailsRoot root, String sHexes)
            throws ConfigurationException {
<span class="fc" id="L274">        ImmutableList.Builder&lt;MapHex&gt; hexBuilder = ImmutableList.builder();</span>

<span class="fc bfc" id="L276" title="All 2 branches covered.">        for (String sHex : sHexes.split(&quot;,&quot;)) {</span>
<span class="fc" id="L277">            MapHex hex = root.getMapManager().getHex(sHex);</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">            if (hex == null) {</span>
<span class="nc" id="L279">                throw new ConfigurationException(LocalText.getText(&quot;InvalidUpgrade&quot;,</span>
<span class="nc" id="L280">                        baseTile.toText(), sHexes));</span>
            } else {
<span class="fc" id="L282">                hexBuilder.add(hex);</span>
            }
        }
<span class="fc" id="L285">        return hexBuilder.build();</span>
    }

    private void parseHexes(RailsRoot root) throws ConfigurationException {
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (hexes == null) return;</span>

<span class="fc bfc" id="L291" title="All 2 branches covered.">        boolean allowed = !hexes.startsWith(&quot;-&quot;);</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">        if (allowed) {</span>
<span class="fc" id="L293">            allowedHexes = parseHexString(root, hexes);</span>
        } else {
<span class="fc" id="L295">            disallowedHexes = parseHexString(root, hexes.substring(1));</span>
        }
<span class="fc" id="L297">    }</span>


    private boolean checkInvalidSides(Rotation rotation, HexSidesSet impassable) {
<span class="nc" id="L301">        log.trace(&quot;Check rotation {} against  impassable{}&quot;, rotation, impassable);</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (impassable == null) return false; // null implies that no station exists</span>
<span class="nc" id="L303">        return (rotation.getConnectedSides().intersects(impassable));</span>
    }

    private boolean checkSideConnectivity(Rotation rotation, HexSidesSet connected, boolean restrictive) {
<span class="nc" id="L307">        log.trace(&quot;Check rotation {} against {}&quot;, rotation, connected);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (connected == null) return true; // null implies no connectivity required</span>
<span class="nc bnc" id="L309" title="All 4 branches missed.">        if (restrictive &amp;&amp; !rotation.getSidesWithNewTrack().isEmpty()) {</span>
<span class="nc" id="L310">            return rotation.getSidesWithNewTrack().intersects(connected);</span>
        } else {
<span class="nc" id="L312">            return (rotation.getConnectedSides().intersects(connected));</span>
        }
    }

    private boolean checkStationConnectivity(Rotation rotation, Collection&lt;Station&gt; stations) {
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (rotation.getStationMapping() == null) return false;</span>
<span class="nc" id="L318">        log.trace(&quot;Check Stations {}, rotation = {}&quot;, stations, rotation);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        for (Station station : stations) {</span>
<span class="nc" id="L320">            Station targetStation = rotation.getStationMapping().get(station);</span>
<span class="nc bnc" id="L321" title="All 4 branches missed.">            if (targetStation != null &amp;&amp; rotation.getStationsWithNewTrack().contains(targetStation)) {</span>
<span class="nc" id="L322">                return true;</span>
            }
<span class="nc" id="L324">        }</span>
<span class="nc" id="L325">        return false;</span>
    }

    public HexSidesSet getRotationSet() {
<span class="nc" id="L329">        return rotationSides;</span>
    }

    public Rotation getRotation(HexSide rotation) {
<span class="fc" id="L333">        return rotations.get(rotation);</span>
    }

    public HexSidesSet getAllowedRotations(HexSidesSet connected, HexSidesSet impassable, HexSide baseRotation,
                                           Collection&lt;Station&gt; stations, boolean restrictive) {

<span class="nc" id="L339">        HexSidesSet.Builder builder = HexSidesSet.builder();</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        for (HexSide side : rotationSides) {</span>
<span class="nc" id="L341">            Rotation rotation = rotations.get(side);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">            if (checkInvalidSides(rotation, impassable)) continue;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            if (checkSideConnectivity(rotation, connected, restrictive) ||</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                    checkStationConnectivity(rotation, stations)) {</span>
<span class="nc" id="L345">                builder.set(side.rotate(baseRotation));</span>
            }
<span class="nc" id="L347">        }</span>
<span class="nc" id="L348">        HexSidesSet allowed = builder.build();</span>
<span class="nc" id="L349">        log.trace(&quot;allowed = {}hexSides = {}impassable ={} rotationSides = {}&quot;, allowed, connected, impassable, rotationSides);</span>
<span class="nc" id="L350">        return allowed;</span>
    }

    private Rotation processRotations(HexSide side) {

<span class="fc" id="L355">        TrackConfig base = baseTile.getTrackConfig();</span>
<span class="fc" id="L356">        TrackConfig target = targetTile.getTrackConfig();</span>
        // create rotation of target, unless default (= 0) rotation
<span class="fc bfc" id="L358" title="All 2 branches covered.">        if (side != HexSide.get(0)) {</span>
<span class="fc" id="L359">            target = TrackConfig.createByRotation(target, side);</span>
        }
        // check if there are stations to map
<span class="fc" id="L362">        Map&lt;Station, Station&gt; stationMapping = assignStations(base, target);</span>
<span class="pc bpc" id="L363" title="1 of 4 branches missed.">        if (stationMapping != null &amp;&amp; !stationMapping.isEmpty()) {</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">            if (stationMapping.containsValue(null)) {</span>
<span class="fc" id="L365">                base = TrackConfig.createByDowngrade(base, base.getTile().getStation(1));</span>
            }
<span class="fc" id="L367">            base = TrackConfig.createByStationMapping(base, stationMapping);</span>
        }

        // and finally check if all tracks are maintained
<span class="fc" id="L371">        Set&lt;Track&gt; baseTracks = base.getTracks();</span>
<span class="fc" id="L372">        Set&lt;Track&gt; targetTracks = target.getTracks();</span>
<span class="fc" id="L373">        SetView&lt;Track&gt; diffTrack = Sets.difference(baseTracks, targetTracks);</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (diffTrack.isEmpty()) {</span>
<span class="fc" id="L375">            SetView&lt;Track&gt; newTracks = Sets.difference(targetTracks, baseTracks);</span>
<span class="fc" id="L376">            boolean allowed = (targetTile.getPossibleRotations().get(side));</span>
<span class="fc" id="L377">            Rotation rotObject = new Rotation(targetTracks, newTracks, side, stationMapping, allowed);</span>
<span class="fc" id="L378">            log.trace(&quot;New Rotation for {} =&gt; {}: \n{}&quot;, baseTile, targetTile, rotObject);</span>
<span class="fc" id="L379">            return rotObject;</span>
        } else {
<span class="fc" id="L381">            log.trace(&quot;No Rotation found {} =&gt; {}, rotation ={}, remaining Tracks = {}&quot;, baseTile, targetTile, side, diffTrack);</span>
<span class="fc" id="L382">            return null;</span>
        }
    }

    private Map&lt;Station, Station&gt; assignStations(TrackConfig base, TrackConfig target) {
<span class="fc" id="L387">        int baseNb = base.getTile().getNumStations();</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">        if (baseNb == 0) return null;</span>

<span class="fc" id="L390">        int targetNb = target.getTile().getNumStations();</span>
<span class="fc" id="L391">        Map&lt;Station, Station&gt; stationMap = Maps.newHashMapWithExpectedSize(baseNb);</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (baseNb == 1) {</span>
            // only one station in base =&gt; baseStation
<span class="fc" id="L394">            Station baseStation = base.getTile().getStation(1);</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            if (targetNb == 1) {</span>
                // only one station in target =&gt; targetStation
<span class="fc" id="L397">                Station targetStation = target.getTile().getStation(1);</span>
                // default case: 1 =&gt; 1 mapping
<span class="fc" id="L399">                stationMap.put(baseStation, targetStation);</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">            } else if (targetNb == 0) {</span>
                // special case: downgrade in 1856 and there is only one station to consider
<span class="fc" id="L402">                Set&lt;TrackPoint&gt; baseTrack = base.getStationTracks(baseStation);</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">                for (TrackPoint side : baseTrack) {</span>
<span class="fc" id="L404">                    Set&lt;TrackPoint&gt; targetTrack = target.getSideTracks((HexSide) side);</span>
<span class="fc" id="L405">                    targetTrack.add(side); // connectivity with all other sides</span>
<span class="fc" id="L406">                    SetView&lt;TrackPoint&gt; diffTrack = Sets.difference(baseTrack, targetTrack);</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">                    if (!diffTrack.isEmpty()) return null;</span>
<span class="fc" id="L408">                }</span>
<span class="fc" id="L409">                stationMap.put(baseStation, null);</span>
            }
<span class="fc" id="L411">        } else { // more than one base station, assign by side connectivity</span>
<span class="fc" id="L412">            List&lt;Station&gt; noTrackBaseStations = Lists.newArrayList();</span>
<span class="fc" id="L413">            TreeSet&lt;Station&gt; targetStations = Sets.newTreeSet(target.getTile().getStations());</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">            for (Station b : base.getTile().getStations()) {</span>
<span class="fc" id="L415">                Set&lt;TrackPoint&gt; baseTrack = base.getStationTracks(b);</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">                if (baseTrack.isEmpty()) { // if track is empty, keep track to add target later</span>
<span class="fc" id="L417">                    noTrackBaseStations.add(b);</span>
                } else {
<span class="fc bfc" id="L419" title="All 2 branches covered.">                    for (Station t : target.getTile().getStations()) {</span>
<span class="fc" id="L420">                        Set&lt;TrackPoint&gt; targetTrack = target.getStationTracks(t);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">                        if (checkTrackConnectivity(baseTrack, targetTrack)) {</span>
<span class="fc" id="L422">                            stationMap.put(b, t);</span>
<span class="fc" id="L423">                            targetStations.remove(t);</span>
<span class="fc" id="L424">                            break;</span>
                        }
<span class="fc" id="L426">                    }</span>
                }
<span class="fc" id="L428">            }</span>
            // any base Stations remaining
<span class="fc bfc" id="L430" title="All 2 branches covered.">            for (Station b : noTrackBaseStations) {</span>
<span class="fc" id="L431">                Station t = targetStations.pollFirst();</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">                if (t != null) {</span>
<span class="fc" id="L433">                    stationMap.put(b, t);</span>
                }
<span class="fc" id="L435">            }</span>
            // check if all base and target stations are assigned
<span class="fc bfc" id="L437" title="All 2 branches covered.">            if (stationMap.keySet().size() != baseNb ||</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">                    Sets.newHashSet(stationMap.values()).size() != targetNb) {</span>
<span class="fc" id="L439">                stationMap = null;</span>
<span class="fc" id="L440">                log.debug(&quot;Mapping: Not all stations assigned, set stationMap to null&quot;);</span>
            }
        }
<span class="fc" id="L443">        return stationMap;</span>
    }

    private boolean checkTrackConnectivity(Set&lt;TrackPoint&gt; baseTrack, Set&lt;TrackPoint&gt; targetTrack) {
<span class="fc" id="L447">        SetView&lt;TrackPoint&gt; diffTrack = Sets.difference(baseTrack, targetTrack);</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">        if (diffTrack.isEmpty()) {</span>
            // target maintains connectivity
<span class="fc" id="L450">            return true;</span>
        } else {
            // if not all connections are maintained,
<span class="fc" id="L453">            Predicate&lt;TrackPoint&gt; checkForStation = new Predicate&lt;TrackPoint&gt;() {</span>
                public boolean apply(TrackPoint p) {
<span class="fc bfc" id="L455" title="All 2 branches covered.">                    return (p.getTrackPointType() == TrackPoint.Type.SIDE);</span>
                }
            };
            // check if remaining tracks only lead to other stations
<span class="fc bfc" id="L459" title="All 2 branches covered.">            if (Sets.filter(diffTrack, checkForStation).isEmpty()) {</span>
<span class="fc" id="L460">                return true;</span>
            }
        }
<span class="fc" id="L463">        return false;</span>
    }


    @Override
    public String toString() {
<span class="nc" id="L469">        return MoreObjects.toStringHelper(this)</span>
<span class="nc" id="L470">                .add(&quot;base&quot;, baseTile)</span>
<span class="nc" id="L471">                .add(&quot;targetTile&quot;, targetTile)</span>
<span class="nc" id="L472">                .toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>