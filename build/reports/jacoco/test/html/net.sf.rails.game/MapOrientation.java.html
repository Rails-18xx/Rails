<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapOrientation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.game</a> &gt; <span class="el_source">MapOrientation.java</span></div><h1>MapOrientation.java</h1><pre class="source lang-java linenums">package net.sf.rails.game;

import java.util.Map;

import com.google.common.collect.ImmutableMap;

import net.sf.rails.common.parser.ConfigurationException;
import net.sf.rails.common.parser.Tag;
import net.sf.rails.ui.swing.hexmap.GUIHex;
import net.sf.rails.ui.swing.hexmap.GUIHex.HexPoint;


/**
 * Tile orientation enumeration.
 *
 * Map orientation refers to &quot;flat edges&quot; parallel with coordinates system
 * axis. Thus there are two orientations: North-South
 * ({@link MapOrientation#NS NS}) and East-West
 * ({@link MapOrientation#EW EW}).
 *
 * Although it seems neither is dominating in 18xx games North-South is used by
 * default for management and classification. So North-South orientation is
 * treated here as the natural one.
 *
 * * &lt;p&gt; The term &quot;rotation&quot; is used to indicate the amount of rotation (in 60
 * degree units) from the standard orientation of the tile (sometimes the term
 * orientation is also used to refer to rotation).
 * &lt;p&gt;Rotation is always relative to the standard orientation, which has the
 * printed tile number on the S edge for {@link MapOrientation#NS}-oriented
 * tiles, or on the SW edge for {@link MapOrientation#EW}-oriented tiles. The
 * rotation numbers are indicated in the below picture for an
 * {@code NS}-oriented tile: &lt;p&gt; &lt;code&gt;
 *
 *       ____3____
 *      /         \
 *     2           4
 *    /     NS      \
 *    \             /
 *     1           5
 *      \____0____/
 * &lt;/code&gt; &lt;p&gt; For {@code EW}-oriented
 * tiles the above picture should be rotated 30 degrees clockwise.
 *
 */

<span class="fc" id="L46">public enum MapOrientation {</span>
    /**
     * North-South tile orientation.
     *
     * &lt;p&gt;This is default orientation for internal uses (which includes SVG
     * images).&lt;/p&gt;
     */
<span class="fc" id="L53">    NS,</span>

    /**
     * East-West tile orientation.
     */
<span class="fc" id="L58">    EW;</span>


    private boolean lettersGoHorizontal;
    private boolean letterAHasEvenNumbers;

    public static MapOrientation create(Tag tag) throws ConfigurationException {
        MapOrientation mapOrientation;
<span class="fc" id="L66">        String orientation = tag.getAttributeAsString(&quot;tileOrientation&quot;);</span>
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (orientation == null)</span>
<span class="nc" id="L68">            throw new ConfigurationException(&quot;Map orientation undefined&quot;);</span>
        try {
<span class="fc" id="L70">            mapOrientation =  MapOrientation.valueOf(orientation);</span>
        }
<span class="nc" id="L72">        catch(IllegalArgumentException exception) {</span>
<span class="nc" id="L73">            throw new ConfigurationException(&quot;Invalid Map orientation: &quot; + orientation, exception);</span>
<span class="fc" id="L74">        }</span>

<span class="fc" id="L76">        String letterOrientation = tag.getAttributeAsString(&quot;letterOrientation&quot;);</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (letterOrientation.equals(&quot;horizontal&quot;)) {</span>
<span class="fc" id="L78">            mapOrientation.lettersGoHorizontal = true;</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        } else if (letterOrientation.equals(&quot;vertical&quot;)) {</span>
<span class="fc" id="L80">            mapOrientation.lettersGoHorizontal = false;</span>
        } else {
<span class="nc" id="L82">            throw new ConfigurationException(&quot;Invalid letter orientation: &quot;</span>
                  + letterOrientation);
        }

<span class="fc" id="L86">        String even = tag.getAttributeAsString(&quot;even&quot;);</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">        mapOrientation.letterAHasEvenNumbers = ((even.toUpperCase().charAt(0) - 'A')) % 2 == 0;</span>
<span class="fc" id="L88">        return mapOrientation;</span>
    }

<span class="fc" id="L91">    private static final String[] nsOrNames = {&quot;S&quot;, &quot;SW&quot;, &quot;NW&quot;, &quot;N&quot;, &quot;NE&quot;, &quot;SE&quot;};</span>
<span class="fc" id="L92">    private static final String[] ewOrNames = {&quot;SW&quot;, &quot;W&quot;, &quot;NW&quot;, &quot;NE&quot;, &quot;E&quot;, &quot;SE&quot;};</span>

    public String getORNames(HexSide orientation) {
<span class="pc bpc" id="L95" title="1 of 3 branches missed.">        switch (this) {</span>
        case NS:
<span class="fc" id="L97">            return nsOrNames[orientation.getTrackPointNumber()];</span>
        case EW:
<span class="fc" id="L99">            return ewOrNames[orientation.getTrackPointNumber()];</span>
        default:
<span class="nc" id="L101">            throw new AssertionError(this);</span>
        }
    }

    /**
     * @return the lettersGoHorizontal
     */
    public boolean lettersGoHorizontal() {
<span class="fc" id="L109">        return lettersGoHorizontal;</span>
    }

    /**
     * @return the letterAHasEvenNumbers
     */
    public boolean letterAHasEvenNumbers() {
<span class="nc" id="L116">        return letterAHasEvenNumbers;</span>
    }

    public String getUIClassName() {
        // FIXME: Rails 2.0, move this to some default .xml!
<span class="nc bnc" id="L121" title="All 3 branches missed.">        switch(this) {</span>
        case NS:
<span class="nc" id="L123">            return &quot;net.sf.rails.ui.swing.hexmap.NSHexMap&quot;;</span>
        case EW:
<span class="nc" id="L125">            return &quot;net.sf.rails.ui.swing.hexmap.EWHexMap&quot;;</span>
        default:
<span class="nc" id="L127">            throw new AssertionError(this);</span>
        }

    }

    // information to define neighbours
<span class="fc" id="L133">    private static final int[] rowDeltaNS = new int[] { +2, +1, -1, -2, -1, +1 };</span>
<span class="fc" id="L134">    private static final int[] colDeltaNS = new int[] {  0, -1, -1,  0, +1, +1 };</span>
<span class="fc" id="L135">    private static final int[] rowDeltaEW = new int[] { +1,  0, -1, -1,  0, +1 };</span>
<span class="fc" id="L136">    private static final int[] colDeltaEW = new int[] { -1, -2, -1, +1, +2, +1 };</span>

    public MapHex.Coordinates getAdjacentCoordinates(MapHex.Coordinates origin, HexSide orientation) {
<span class="fc" id="L139">        int p = orientation.getTrackPointNumber();</span>
<span class="pc bpc" id="L140" title="1 of 3 branches missed.">        switch(this) {</span>
        case NS:
<span class="fc" id="L142">            return origin.translate(rowDeltaNS[p], colDeltaNS[p]);</span>
        case EW:
<span class="fc" id="L144">            return origin.translate(rowDeltaEW[p], colDeltaEW[p]);</span>
        default:
<span class="nc" id="L146">            throw new AssertionError(this);</span>
        }
    }

<span class="fc" id="L150">    public static final double SQRT3 = Math.sqrt(3.0);</span>

    public Map&lt;HexSide, HexPoint&gt; setGUIVertices( double cx, double cy, double scale) {

<span class="nc" id="L154">        ImmutableMap.Builder&lt;HexSide, HexPoint&gt; coordinates = ImmutableMap.builder();</span>

<span class="nc bnc" id="L156" title="All 3 branches missed.">        switch(this) {</span>
        case NS:
            /* The numbering is the following:
             *      3--4
             *     /    \
             *    2      5
             *     \    /
             *      1--0
             */
<span class="nc" id="L165">            coordinates.put(HexSide.get(0), new GUIHex.HexPoint(cx + 2 * scale, cy + 2 * SQRT3 * scale));</span>
<span class="nc" id="L166">            coordinates.put(HexSide.get(1), new GUIHex.HexPoint(cx, cy + 2 * SQRT3 * scale));</span>
<span class="nc" id="L167">            coordinates.put(HexSide.get(2), new GUIHex.HexPoint(cx - scale, cy + SQRT3 * scale));</span>
<span class="nc" id="L168">            coordinates.put(HexSide.get(3), new GUIHex.HexPoint(cx, cy));</span>
<span class="nc" id="L169">            coordinates.put(HexSide.get(4), new GUIHex.HexPoint(cx + 2 * scale, cy));</span>
<span class="nc" id="L170">            coordinates.put(HexSide.get(5), new GUIHex.HexPoint(cx + 3 * scale, cy + SQRT3 * scale));</span>
<span class="nc" id="L171">            break;</span>
        case EW:
            /* The numbering is the following:
             *         3
             *        / \
             *       2   4
             *       |   |
             *       1   5
             *        \ /
             *         0
             */
<span class="nc" id="L182">            coordinates.put(HexSide.get(0), new GUIHex.HexPoint(cx + SQRT3 * scale, cy + scale));</span>
<span class="nc" id="L183">            coordinates.put(HexSide.get(1), new GUIHex.HexPoint(cx, cy));</span>
<span class="nc" id="L184">            coordinates.put(HexSide.get(2), new GUIHex.HexPoint(cx, cy - 2 * scale));</span>
<span class="nc" id="L185">            coordinates.put(HexSide.get(3), new GUIHex.HexPoint(cx + SQRT3 * scale, cy - 3 * scale));</span>
<span class="nc" id="L186">            coordinates.put(HexSide.get(4), new GUIHex.HexPoint(cx +2 * SQRT3 * scale, cy - 2 * scale));</span>
<span class="nc" id="L187">            coordinates.put(HexSide.get(5), new GUIHex.HexPoint(cx +2 * SQRT3 * scale, cy));</span>
<span class="nc" id="L188">            break;</span>
        default:
<span class="nc" id="L190">            throw new AssertionError(this);</span>
        }
<span class="nc" id="L192">        return coordinates.build();</span>
    }

    public static final double DEG30 = Math.PI / 6.0;

    private double rotationInRadians(HexSide rotation) {
<span class="nc bnc" id="L198" title="All 3 branches missed.">        switch(this) {</span>
        case NS:
<span class="nc" id="L200">            return (2 * rotation.getTrackPointNumber()) * DEG30;</span>
        case EW:
<span class="nc" id="L202">            return (2 * rotation.getTrackPointNumber() + 1) * DEG30;</span>
        default:
<span class="nc" id="L204">            throw new AssertionError(this);</span>
        }
    }

    /**
     * Returns rotation to be applied to {@link MapOrientation#NS}-oriented
     * tile to achieve this orientation.
     *
     * &lt;p&gt;The rotation has to be done around center point of the tile.&lt;/p&gt;
     *
     * &lt;p&gt;This function returns {@literal 0} for {@link MapOrientation#NS}
     * since {@code NS}-oriented tile does not need any rotation to be
     * transformed into {@code NS}-oriented tile.&lt;/p&gt;
     *
     * @return Rotation to be applied to {@link MapOrientation#NS}-oriented
     *         tile to achieve this orientation.
     */

    public static double rotationInRadians(RailsItem item, HexSide rotation) {
<span class="nc" id="L223">        return item.getRoot().getMapManager().getMapOrientation().rotationInRadians(rotation);</span>
    }

    /**
     * @return orientation of the map (NS or EW)
     */
    public static MapOrientation get(RailsItem item) {
<span class="nc" id="L230">        return item.getRoot().getMapManager().getMapOrientation();</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>