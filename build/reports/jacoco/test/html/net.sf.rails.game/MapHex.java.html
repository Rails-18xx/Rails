<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapHex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.game</a> &gt; <span class="el_source">MapHex.java</span></div><h1>MapHex.java</h1><pre class="source lang-java linenums">package net.sf.rails.game;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.base.MoreObjects;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import com.google.common.collect.Sets.SetView;

import net.sf.rails.algorithms.RevenueBonusTemplate;
import net.sf.rails.common.LocalText;
import net.sf.rails.common.ReportBuffer;
import net.sf.rails.common.parser.Configurable;
import net.sf.rails.common.parser.ConfigurationException;
import net.sf.rails.common.parser.Tag;
import net.sf.rails.game.TileUpgrade.Rotation;
import net.sf.rails.game.model.RailsModel;
import net.sf.rails.game.state.GenericState;
import net.sf.rails.game.state.HashBiMapState;
import net.sf.rails.game.state.HashMapState;
import net.sf.rails.game.state.PortfolioSet;
import net.sf.rails.util.Util;
import rails.game.action.LayTile;

// TODO: Rewrite the mechanisms as model

/**
 * Represents a Hex on the Map from the Model side.
 */
public class MapHex extends RailsModel implements RailsOwner, Configurable {

<span class="fc" id="L45">    private static final Logger log = LoggerFactory.getLogger(MapHex.class);</span>

    public static class Coordinates {

        // externally used coordinates
        private final int row;
        private final int col;

<span class="fc" id="L53">        private static final Pattern namePattern = Pattern.compile(&quot;(\\D+?)(-?\\d+)&quot;);</span>

<span class="fc" id="L55">        private Coordinates(int row, int col) {</span>
<span class="fc" id="L56">            this.row = row;</span>
<span class="fc" id="L57">            this.col = col;</span>
<span class="fc" id="L58">        }</span>

        public static Coordinates createFromId(String id,
                                               MapOrientation mapOrientation) throws ConfigurationException {

<span class="fc" id="L63">            Matcher m = namePattern.matcher(id);</span>

<span class="pc bpc" id="L65" title="1 of 2 branches missed.">            if (!m.matches()) {</span>
<span class="nc" id="L66">                throw new ConfigurationException(&quot;Invalid name format: &quot; + id);</span>
            }
<span class="fc" id="L68">            String letters = m.group(1);</span>
            int letter;
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">            if (letters.length() == 1) {</span>
<span class="fc" id="L71">                letter = letters.charAt(0);</span>
            } else { // for row 'AA' in 1825U1
<span class="nc" id="L73">                letter = 26 + letters.charAt(1);</span>
            }
            // FIXME: Replace with negative numbers instead of &gt; 100
            int number;
            try {
<span class="fc" id="L78">                number = Integer.parseInt(m.group(2));</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">                if (number &gt; 90) number -= 100; // For 1825U1 column 99 (= -1)</span>
<span class="nc" id="L80">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L81">                throw new ConfigurationException(</span>
<span class="nc" id="L82">                        &quot;Invalid number format: &quot; + m.group(2));</span>
<span class="fc" id="L83">            }</span>

            /*
             * Translate hex names (as on the board) to coordinates used for
             * drawing.
             */
            int row, column;
<span class="fc bfc" id="L90" title="All 2 branches covered.">            if (mapOrientation.lettersGoHorizontal()) {</span>
<span class="fc" id="L91">                row = number;</span>
<span class="fc" id="L92">                column = letter - '@';</span>
            } else { // letters go vertical (normal case)
<span class="fc" id="L94">                row = letter - '@';</span>
<span class="fc" id="L95">                column = number;</span>
            }
<span class="fc" id="L97">            return new Coordinates(row, column);</span>
        }

        public static Coordinates maximum(Collection&lt;MapHex&gt; hexes) {
            int maxRow, maxCol;
<span class="fc" id="L102">            maxRow = maxCol = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">            for (MapHex hex : hexes) {</span>
<span class="fc" id="L104">                Coordinates coordinates = hex.coordinates;</span>
<span class="fc" id="L105">                maxRow = Math.max(maxRow, coordinates.row);</span>
<span class="fc" id="L106">                maxCol = Math.max(maxCol, coordinates.col);</span>
<span class="fc" id="L107">            }</span>
<span class="fc" id="L108">            return new Coordinates(maxRow, maxCol);</span>
        }

        public static Coordinates minimum(Collection&lt;MapHex&gt; hexes) {
            int minRow, minCol;
<span class="fc" id="L113">            minRow = minCol = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">            for (MapHex hex : hexes) {</span>
<span class="fc" id="L115">                Coordinates coordinates = hex.coordinates;</span>
<span class="fc" id="L116">                minRow = Math.min(minRow, coordinates.row);</span>
<span class="fc" id="L117">                minCol = Math.min(minCol, coordinates.col);</span>
<span class="fc" id="L118">            }</span>
<span class="fc" id="L119">            return new Coordinates(minRow, minCol);</span>
        }

        public int getRow() {
<span class="nc" id="L123">            return row;</span>
        }

        public int getCol() {
<span class="nc" id="L127">            return col;</span>
        }

        public Coordinates translate(int deltaRow, int deltaCol) {
<span class="fc" id="L131">            return new Coordinates(row + deltaRow, col + deltaCol);</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L136">            return Objects.hashCode(row, col);</span>
        }

        @Override
        public boolean equals(Object other) {
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">            if (!(other instanceof Coordinates)) return false;</span>
<span class="pc bpc" id="L142" title="1 of 4 branches missed.">            return row == ((Coordinates) other).row</span>
                    &amp;&amp; col == ((Coordinates) other).col;
        }

        @Override
        public String toString() {
<span class="fc" id="L148">            return MoreObjects.toStringHelper(this)</span>
<span class="fc" id="L149">                    .addValue(row)</span>
<span class="fc" id="L150">                    .addValue(col)</span>
<span class="fc" id="L151">                    .toString();</span>
        }
    }

    ////////////////////////
    // static fields
    ////////////////////////

    private final Coordinates coordinates;

    private String preprintedTileId;
    private String preprintedPictureId;
    private HexSide preprintedTileRotation;

    private List&lt;Integer&gt; tileCost;

    private String stopName;
<span class="fc" id="L168">    private String reservedForCompanyName = null;</span>
<span class="fc" id="L169">    private PublicCompany reservedForCompany = null;</span>

    /**
     * Values if this is an off-board hex
     */
<span class="fc" id="L174">    private List&lt;Integer&gt; valuesPerPhase = null;</span>

    /*
     * Temporary storage for impassable hexsides. Once neighbours has been set
     * up, this attribute is no longer used. Only the black or blue bars on the
     * map need be specified, and each one only once. Impassable non-track sides
     * of &quot;offboard&quot; (red) and &quot;fixed&quot; (grey or brown) preprinted tiles will be
     * derived and need not be specified.
     */
<span class="fc" id="L183">    private String impassableTemplate = null;</span>
<span class="fc" id="L184">    private final HexSidesSet.Builder impassableBuilder = HexSidesSet.builder();</span>
    private HexSidesSet impassableSides;

<span class="fc" id="L187">    private final HexSidesSet.Builder invalidBuilder = HexSidesSet.builder();</span>
    private HexSidesSet invalidSides;

<span class="fc" id="L190">    private List&lt;PublicCompany&gt; destinations = null;</span>

    /**
     * Storage of revenueBonus that are bound to the hex
     */
<span class="fc" id="L195">    private List&lt;RevenueBonusTemplate&gt; revenueBonuses = null;</span>

    /**
     * Optional attribute to provide the type of any stops on the hex. Normally
     * the type will be derived from the tile properties.
     */
<span class="fc" id="L201">    private StopType stopType = null;</span>

    ////////////////////////
    // dynamic fields
    ////////////////////////
<span class="fc" id="L206">    private final GenericState&lt;Tile&gt; currentTile =</span>
<span class="fc" id="L207">            GenericState.create(this, &quot;currentTile&quot;);</span>
<span class="fc" id="L208">    private final GenericState&lt;HexSide&gt; currentTileRotation =</span>
<span class="fc" id="L209">            GenericState.create(this, &quot;currentTileRotation&quot;);</span>

    // Stops (Cities, Towns etc.)
<span class="fc" id="L212">    private final HashBiMapState&lt;Station, Stop&gt; stops =</span>
<span class="fc" id="L213">            HashBiMapState.create(this, &quot;stops&quot;);</span>

    // Homes (in 18EU and others the home is selected later in the game
    // Remark: this was a static field in Rails1.x, causing potential undo
    // problems
<span class="fc" id="L218">    private final HashMapState&lt;PublicCompany, Stop&gt; homes =</span>
<span class="fc" id="L219">            HashMapState.create(this, &quot;homes&quot;);</span>

<span class="fc" id="L221">    private final GenericState&lt;PrivateCompany&gt; blockingPrivateCompany =</span>
<span class="fc" id="L222">            GenericState.create(this, &quot;blockingPrivateCompany&quot;);</span>

    /**
     * Is the hex blocked for home tokens? &lt;p&gt; NOTE:&lt;br&gt; ALWAYS means: Always
     * Blocked, no token lay possible (until attribute is changed) RESERVE_SLOT
     * means: Reserves slots (for multi-cities depending on
     * isHomeBlockedForAllCities&lt;br&gt; NEVER means: Never blocked (unless there is
     * not a single free slot remaining)&lt;br&gt; Remark: The latter is used for 1835
     * Berlin, which is home to PR, but the absence of a PR token does not block
     * the third slot when the green tile is laid. &lt;br&gt;
     * &lt;p&gt;
     * Remark: in Rails 1.x it was a static field, causing potential undo
     * problems
     */
<span class="fc" id="L236">    public static enum BlockedToken {</span>
<span class="fc" id="L237">        ALWAYS, RESERVE_SLOT, NEVER</span>
    }

    ;

<span class="fc" id="L242">    private final GenericState&lt;BlockedToken&gt; isBlockedForTokenLays =</span>
<span class="fc" id="L243">            GenericState.create(this, &quot;isBlockedForTokenLays&quot;);</span>

    /**
     * OffStation BonusTokens
     */
<span class="fc" id="L248">    private final PortfolioSet&lt;BonusToken&gt; bonusTokens =</span>
<span class="fc" id="L249">            PortfolioSet.create(this, &quot;bonusTokens&quot;, BonusToken.class);</span>

    private MapHex(MapManager parent, String id, Coordinates coordinates) {
<span class="fc" id="L252">        super(parent, id);</span>
<span class="fc" id="L253">        this.coordinates = coordinates;</span>
<span class="fc" id="L254">    }</span>

    public static MapHex create(MapManager parent, Tag tag)
            throws ConfigurationException {
        // name serves as id
<span class="fc" id="L259">        String id = tag.getAttributeAsString(&quot;name&quot;);</span>
<span class="fc" id="L260">        Coordinates coordinates =</span>
<span class="fc" id="L261">                Coordinates.createFromId(id, parent.getMapOrientation());</span>
<span class="fc" id="L262">        MapHex hex = new MapHex(parent, id, coordinates);</span>
<span class="fc" id="L263">        hex.configureFromXML(tag);</span>
<span class="fc" id="L264">        return hex;</span>
    }

    public void configureFromXML(Tag tag) throws ConfigurationException {

<span class="fc" id="L269">        preprintedTileId = tag.getAttributeAsString(&quot;tile&quot;, null);</span>
<span class="fc" id="L270">        preprintedPictureId = tag.getAttributeAsString(&quot;pic&quot;, preprintedTileId);</span>
<span class="fc" id="L271">        int orientation = tag.getAttributeAsInteger(&quot;orientation&quot;, 0);</span>
<span class="fc" id="L272">        preprintedTileRotation = HexSide.get(orientation);</span>

<span class="fc" id="L274">        impassableTemplate = tag.getAttributeAsString(&quot;impassable&quot;);</span>
<span class="fc" id="L275">        tileCost = tag.getAttributeAsIntegerList(&quot;cost&quot;);</span>

        // Off-board revenue values
<span class="fc" id="L278">        valuesPerPhase = tag.getAttributeAsIntegerList(&quot;value&quot;);</span>

        // City name
<span class="fc" id="L281">        stopName = tag.getAttributeAsString(&quot;city&quot;, &quot;&quot;);</span>

<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (tag.getAttributeAsString(&quot;unlaidHomeBlocksTokens&quot;) == null) {</span>
            // default (undefined) is RESERVE_SLOT
<span class="fc" id="L285">            isBlockedForTokenLays.set(BlockedToken.RESERVE_SLOT);</span>
        } else {
<span class="fc bfc" id="L287" title="All 2 branches covered.">            if (tag.getAttributeAsBoolean(&quot;unlaidHomeBlocksTokens&quot;, false)) {</span>
<span class="fc" id="L288">                isBlockedForTokenLays.set(BlockedToken.ALWAYS);</span>
            } else {
<span class="fc" id="L290">                isBlockedForTokenLays.set(BlockedToken.NEVER);</span>
            }
        }
<span class="fc" id="L293">        reservedForCompanyName = tag.getAttributeAsString(&quot;reserved&quot;);</span>

        // revenue bonus
<span class="fc" id="L296">        List&lt;Tag&gt; bonusTags = tag.getChildren(&quot;RevenueBonus&quot;);</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (bonusTags != null) {</span>
<span class="fc" id="L298">            revenueBonuses = new ArrayList&lt;RevenueBonusTemplate&gt;();</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">            for (Tag bonusTag : bonusTags) {</span>
<span class="fc" id="L300">                RevenueBonusTemplate bonus = new RevenueBonusTemplate();</span>
<span class="fc" id="L301">                bonus.configureFromXML(bonusTag);</span>
<span class="fc" id="L302">                revenueBonuses.add(bonus);</span>
<span class="fc" id="L303">            }</span>
        }

        // Stop properties
<span class="fc" id="L307">        Tag accessTag = tag.getChild(&quot;Access&quot;);</span>
<span class="fc" id="L308">        stopType = StopType.parseStop(this, accessTag,</span>
<span class="fc" id="L309">                getParent().getDefaultStopTypes());</span>
<span class="fc" id="L310">    }</span>

    public void finishConfiguration(RailsRoot root) {
<span class="fc" id="L313">        currentTile.set(root.getTileManager().getTile(preprintedTileId));</span>
<span class="fc" id="L314">        currentTileRotation.set(preprintedTileRotation);</span>

<span class="fc" id="L316">        reservedForCompany = getRoot().getCompanyManager().getPublicCompany(</span>
                reservedForCompanyName);

        // We need completely new objects, not just references to the Tile's
        // stations.
<span class="fc bfc" id="L321" title="All 2 branches covered.">        for (Station station : currentTile.value().getStations()) {</span>
<span class="fc" id="L322">            Stop stop = Stop.create(this, station);</span>
<span class="fc" id="L323">            stops.put(station, stop);</span>
<span class="fc" id="L324">        }</span>

<span class="fc" id="L326">        impassableSides = impassableBuilder.build();</span>
<span class="fc" id="L327">        invalidSides = invalidBuilder.build();</span>
<span class="fc" id="L328">    }</span>

    @Override
    public MapManager getParent() {
<span class="fc" id="L332">        return (MapManager) super.getParent();</span>
    }

    public void addImpassableSide(HexSide side) {
<span class="fc" id="L336">        impassableBuilder.set(side);</span>
<span class="fc" id="L337">        log.debug(&quot;Added impassable &quot; + side + &quot; to &quot; + this);</span>
        // all impassable sides are invalids
<span class="fc" id="L339">        addInvalidSide(side);</span>
<span class="fc" id="L340">    }</span>

    public HexSidesSet getImpassableSides() {
<span class="nc" id="L343">        return impassableSides;</span>
    }

    public void addInvalidSide(HexSide side) {
<span class="fc" id="L347">        invalidBuilder.set(side);</span>
<span class="fc" id="L348">        log.debug(&quot;Added invalid &quot; + side + &quot; to &quot; + this);</span>
<span class="fc" id="L349">    }</span>

    public HexSidesSet getInvalidSides() {
<span class="nc" id="L352">        return invalidSides;</span>
    }

    public boolean isImpassableNeighbour(MapHex neighbour) {
<span class="fc bfc" id="L356" title="All 2 branches covered.">        return impassableTemplate != null</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">                &amp;&amp; impassableTemplate.indexOf(neighbour.getId()) &gt; -1;</span>
    }

    public boolean isValidNeighbour(MapHex neighbour, HexSide side) {
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (isImpassableNeighbour(neighbour)) return false;</span>
        /*
         * The preprinted tile on this hex is offmap or fixed and has no track
         * to this side.
         */
<span class="fc" id="L366">        Tile neighbourTile = neighbour.getCurrentTile();</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (neighbourTile.isUpgradeable()) return true;</span>
<span class="fc" id="L368">        HexSide rotated = side.opposite().rotate(</span>
<span class="fc" id="L369">                neighbour.getCurrentTileRotation().negative());</span>
<span class="fc" id="L370">        return neighbourTile.hasTracks(rotated);</span>
    }

    public String getOrientationName(HexSide orientation) {
<span class="fc" id="L374">        return getParent().getMapOrientation().getORNames(orientation);</span>
    }

    @Deprecated
    public String getOrientationName(int orientation) {
<span class="fc" id="L379">        return getOrientationName(HexSide.get(orientation));</span>
    }

    /* ----- Instance methods ----- */

    public Coordinates getCoordinates() {
<span class="fc" id="L385">        return coordinates;</span>
    }

    public boolean isPreprintedTileCurrent() {
<span class="fc" id="L389">        return currentTile.value().getId().equals(preprintedTileId);</span>
    }

    /**
     * @return Returns the preprintedTileId.
     */
    public String getPreprintedTileId() {
<span class="fc" id="L396">        return preprintedTileId;</span>
    }

    public HexSide getPreprintedTileRotation() {
<span class="nc" id="L400">        return preprintedTileRotation;</span>
    }

    /**
     * Return the current picture ID (i.e. the tile ID to be displayed, rather
     * than used for route determination). &lt;p&gt; Usually, the picture ID is equal
     * to the tile ID. Different values may be defined per hex or per tile.
     * Restriction: definitions per hex can apply to preprinted tiles only.
     *
     * @return The current picture ID
     */
    public String getPictureId(Tile tile) {
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (tile.getId().equals(preprintedTileId)) {</span>
<span class="nc" id="L413">            return preprintedPictureId;</span>
        } else {
<span class="nc" id="L415">            return tile.getPictureId();</span>
        }
    }

    public Tile getCurrentTile() {
<span class="fc" id="L420">        return currentTile.value();</span>
    }

    public HexSide getCurrentTileRotation() {
<span class="fc" id="L424">        return currentTileRotation.value();</span>
    }

    public int getTileCost() {
<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (isPreprintedTileCurrent()) {</span>
<span class="fc" id="L429">            return getTileCost(0);</span>
        } else {
<span class="fc" id="L431">            return getTileCost(currentTile.value().getColourNumber());</span>
        }
    }

    // TODO: Replace index by TileColours
    private int getTileCost(int index) {
        try {
<span class="fc" id="L438">            return tileCost.get(index);</span>
<span class="fc" id="L439">        } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L440">            return 0;</span>
        }
    }

    public List&lt;Integer&gt; getTileCostsList() {
<span class="fc" id="L445">        return tileCost;</span>
    }

    public StopType getStopType() {
<span class="fc" id="L449">        return stopType;</span>
    }

    /**
     * new wrapper function for the LayTile action that calls the actual upgrade
     * mehod
     *
     * @param action executed LayTile action
     */
    public void upgrade(LayTile action) {
<span class="fc" id="L459">        Tile newTile = action.getLaidTile();</span>
<span class="fc" id="L460">        HexSide newRotation = HexSide.get(action.getOrientation());</span>
<span class="fc" id="L461">        Map&lt;String, Integer&gt; relaidTokens = action.getRelaidBaseTokens();</span>

<span class="fc" id="L463">        upgrade(newTile, newRotation, relaidTokens);</span>
<span class="fc" id="L464">    }</span>

    public void upgrade(Tile newTile, HexSide newRotation,
                        Map&lt;String, Integer&gt; relaidTokens) {

<span class="fc" id="L469">        TileUpgrade upgrade = currentTile.value().getSpecificUpgrade(newTile);</span>
<span class="fc" id="L470">        Rotation rotation = upgrade.getRotation(</span>
<span class="fc" id="L471">                newRotation.rotate(currentTileRotation.value().negative()));</span>
        Map&lt;Station, Station&gt; stationMapping;

        /*
         * Martin Brumm 17.12.2016 18AL and maybe others allows a tile to be
         * laid with an additional stop So we need to check that the current
         * station number is maintained or we have to check special cases..
         */

<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        if (rotation != null) {</span>
<span class="fc" id="L481">            log.debug(&quot;Valid rotation found {}&quot;, rotation);</span>
<span class="fc" id="L482">            stationMapping = rotation.getStationMapping();</span>
        } else {
<span class="nc" id="L484">            stationMapping = null;</span>
<span class="nc" id="L485">            log.error(&quot;No valid rotation was found: newRotation= {}currentRotation{}&quot;, newRotation, currentTileRotation.value());</span>
        }

<span class="fc" id="L488">        BiMap&lt;Stop, Station&gt; stopsToNewStations = HashBiMap.create();</span>
<span class="fc" id="L489">        Set&lt;Stop&gt; droppedStops = Sets.newHashSet();</span>
        SetView&lt;Stop&gt; unassignedStops;

<span class="fc bfc" id="L492" title="All 2 branches covered.">        if (relaidTokens != null) {</span>
            // Check for manual handling of tokens
<span class="fc bfc" id="L494" title="All 2 branches covered.">            for (String compName : relaidTokens.keySet()) {</span>
<span class="fc" id="L495">                PublicCompany company =</span>
<span class="fc" id="L496">                        getRoot().getCompanyManager().getPublicCompany(</span>
                                compName);
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">                for (Stop stop : stops) {</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">                    if (stop.hasTokenOf(company)) {</span>
<span class="fc" id="L500">                        Station newStation =</span>
<span class="fc" id="L501">                                newTile.getStation(relaidTokens.get(compName));</span>
<span class="fc" id="L502">                        stopsToNewStations.put(stop, newStation);</span>
<span class="fc" id="L503">                        log.debug(&quot;Mapped by relaid tokens: station {} to {}&quot;, stop.getRelatedStation(), newStation);</span>
<span class="fc" id="L504">                        break;</span>
                    }
<span class="nc" id="L506">                }</span>
<span class="fc" id="L507">            }</span>
            // Map all other stops in sequence to the remaining stations

<span class="fc" id="L510">            unassignedStops = Sets.difference(stops.viewValues(),</span>
<span class="fc" id="L511">                    stopsToNewStations.keySet());</span>

<span class="fc bfc" id="L513" title="All 2 branches covered.">            for (Stop stop : unassignedStops) {</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">                for (Station newStation : newTile.getStations()) {</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">                    if (!stopsToNewStations.containsValue(newStation)) {</span>
<span class="fc" id="L516">                        stopsToNewStations.put(stop, newStation);</span>
<span class="fc" id="L517">                        log.debug(&quot;Mapped after relaid tokens: station &quot;</span>
<span class="fc" id="L518">                                + stop.getRelatedStation() + &quot; to &quot;</span>
                                + newStation);
<span class="fc" id="L520">                        break;</span>
                    }
<span class="fc" id="L522">                }</span>
<span class="fc" id="L523">            }</span>
        } else { // default mapping routine

<span class="fc bfc" id="L526" title="All 2 branches covered.">            for (Stop stop : stops) {</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">                if (stopsToNewStations.containsKey(stop)) continue;</span>
<span class="fc" id="L528">                Station oldStation = stop.getRelatedStation();</span>
                // Search stationMapping for assignments of stops to new
                // stations
<span class="fc" id="L531">                Station newStation = null;</span>
<span class="fc" id="L532">                String debugText = null;</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">                if (stationMapping == null) {</span>
<span class="nc" id="L534">                    int oldNumber = stop.getRelatedStation().getNumber();</span>
<span class="nc" id="L535">                    newStation = newTile.getStation(oldNumber);</span>
<span class="nc" id="L536">                    debugText = &quot;Mapped by default id&quot;;</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">                } else if (stationMapping.containsKey(oldStation)) {</span>
                    // Match found in StationMapping, then assign the new
                    // station to the stop
<span class="fc" id="L540">                    newStation = stationMapping.get(oldStation);</span>
<span class="fc" id="L541">                    debugText = &quot;Mapped by stationMapping&quot;;</span>
                }
<span class="fc bfc" id="L543" title="All 2 branches covered.">                if (newStation == null) { // no mapping =&gt; log error</span>
<span class="fc" id="L544">                    droppedStops.add(stop);</span>
<span class="fc" id="L545">                    log.debug(&quot;{}: station {} is dropped&quot;, debugText, oldStation);</span>
                } else {
<span class="fc bfc" id="L547" title="All 2 branches covered.">                    if (stopsToNewStations.containsValue(newStation)) {</span>
                        // new station already assigned a stop, use that
                        // and move tokens between stops
<span class="fc" id="L550">                        Stop otherStop =</span>
<span class="fc" id="L551">                                stopsToNewStations.inverse().get(newStation);</span>
<span class="fc" id="L552">                        moveTokens(stop, otherStop);</span>
<span class="fc" id="L553">                        droppedStops.add(stop);</span>
                        // FIXME: Due to Rails1.x compatibility
<span class="fc" id="L555">                        otherStop.addPreviousNumbers(stop.getLegacyNumber());</span>
<span class="fc" id="L556">                    } else {</span>
                        // otherwise use the existing stop
<span class="fc" id="L558">                        stopsToNewStations.put(stop, newStation);</span>
                    }
<span class="fc" id="L560">                    log.debug(&quot;{}: station {} to {}&quot;, debugText, oldStation, newStation);</span>
                }
<span class="fc" id="L562">            }</span>
        }
<span class="fc bfc" id="L564" title="All 4 branches covered.">        if ((stops.size() == 0) &amp;&amp; (newTile.getNumStations() &gt; 0)) {</span>

<span class="fc bfc" id="L566" title="All 2 branches covered.">            for (Station newStation : newTile.getStations()) {</span>
<span class="fc" id="L567">                Stop stop = Stop.create(this, newStation);</span>
<span class="fc" id="L568">                stopsToNewStations.put(stop, newStation);</span>
<span class="fc" id="L569">            }</span>
        }

        // Check for unassigned Stops
<span class="fc" id="L573">        unassignedStops = Sets.difference(stops.viewValues(),</span>
<span class="fc" id="L574">                Sets.union(stopsToNewStations.keySet(), droppedStops));</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">        if (!unassignedStops.isEmpty()) {</span>
<span class="nc" id="L576">            log.error(&quot;Unassigned Stops :{}&quot;, unassignedStops);</span>
        }

        // Check for unassigned Stations
<span class="fc" id="L580">        SetView&lt;Station&gt; unassignedStations = Sets.difference(</span>
<span class="fc" id="L581">                ImmutableSet.copyOf(stopsToNewStations.values()),</span>
<span class="fc" id="L582">                newTile.getStations());</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (!unassignedStations.isEmpty()) {</span>
<span class="nc" id="L584">            log.error(&quot;Unassigned Stations :{}&quot;, unassignedStations);</span>
        }
<span class="fc" id="L586">        executeTileLay(newTile, newRotation, stopsToNewStations);</span>

<span class="fc" id="L588">    }</span>

    private void moveTokens(Stop origin, Stop target) {
<span class="fc bfc" id="L591" title="All 2 branches covered.">        for (BaseToken token : origin.getBaseTokens()) {</span>
<span class="fc" id="L592">            PublicCompany company = token.getParent();</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">            if (target.hasTokenOf(company)) {</span>
                // No duplicate tokens allowed in one city, so move to free
                // tokens
<span class="fc" id="L596">                token.moveTo(company);</span>
<span class="fc" id="L597">                log.debug(&quot;Duplicate token &quot; + token.getUniqueId()</span>
<span class="fc" id="L598">                        + &quot; moved from &quot; + origin.getSpecificId() + &quot; to &quot;</span>
<span class="fc" id="L599">                        + company.getId());</span>
<span class="fc" id="L600">                ReportBuffer.add(this, LocalText.getText(</span>
<span class="fc" id="L601">                        &quot;DuplicateTokenRemoved&quot;, company.getId(), getId()));</span>
            } else {
<span class="fc" id="L603">                token.moveTo(target);</span>
<span class="fc" id="L604">                log.debug(&quot;Token &quot; + token.getUniqueId() + &quot; moved from &quot;</span>
<span class="fc" id="L605">                        + origin.getSpecificId() + &quot; to &quot;</span>
<span class="fc" id="L606">                        + target.getSpecificId());</span>
            }
<span class="fc" id="L608">        }</span>
<span class="fc" id="L609">    }</span>

    /**
     * Execute a tile replacement. This method should only be called from
     * TileMove objects. It is also used to undo tile lays.
     *
     * @param newTile        The new tile to be laid on this hex.
     * @param newOrientation The orientation of the new tile (0-5).
     * @param newStops       The new stops used now
     */
    private void executeTileLay(Tile newTile, HexSide newOrientation,
                                BiMap&lt;Stop, Station&gt; newStops) {

        // TODO: Is the check for null still required?
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">        if (currentTile.value() != null) {</span>
<span class="fc" id="L624">            currentTile.value().remove(this);</span>
        }

<span class="fc" id="L627">        log.debug(&quot;On hex {} replacing tile {}/{} by {}/{}&quot;, getId(), currentTile.value().getId(), currentTileRotation, newTile.getId(), newOrientation);</span>

<span class="fc" id="L629">        newTile.add(this);</span>
<span class="fc" id="L630">        currentTile.set(newTile);</span>
<span class="fc" id="L631">        currentTileRotation.set(newOrientation);</span>

<span class="fc" id="L633">        stops.clear();</span>
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">        if (newStops != null) {</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">            for (Stop stop : newStops.keySet()) {</span>
<span class="fc" id="L636">                Station station = newStops.get(stop);</span>
<span class="fc" id="L637">                stops.put(station, stop);</span>
<span class="fc" id="L638">                stop.setRelatedStation(station);</span>
<span class="fc" id="L639">                log.debug(&quot;Tile #{} station {} has tracks to {}&quot;, newTile.getId(), station.getNumber(), getConnectionString(station));</span>
<span class="fc" id="L640">            }</span>
        }
<span class="fc" id="L642">    }</span>

    public boolean layBaseToken(PublicCompany company, Stop stop) {
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">        if (stops.isEmpty()) {</span>
<span class="nc" id="L646">            log.error(&quot;Tile {} has no station for home token of company {}&quot;, getId(), company.getId());</span>
<span class="nc" id="L647">            return false;</span>
        }

<span class="fc" id="L650">        BaseToken token = company.getNextBaseToken();</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">        if (token == null) {</span>
<span class="nc" id="L652">            log.error(&quot;Company {} has no free token&quot;, company.getId());</span>
<span class="nc" id="L653">            return false;</span>
        } else {
            // transfer token
<span class="fc" id="L656">            token.moveTo(stop);</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">            if (isHomeFor(company)</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">                    &amp;&amp; isBlockedForTokenLays.value() == BlockedToken.ALWAYS) {</span>
                // FIXME: Assume that there is only one home base on such a
                // tile,
                // so we don't need to check for other ones
                // Solution is to check for the number of home tokens still to
                // lay
<span class="fc" id="L664">                isBlockedForTokenLays.set(BlockedToken.NEVER);</span>
            }

<span class="fc" id="L667">            return true;</span>
        }
    }

    /**
     * Lay a bonus token.
     *
     * @param token        The bonus token object to place
     * @param phaseManager The PhaseManager is also passed in case the token
     *                     must register itself for removal when a certain phase starts.
     * @return
     */
    public boolean layBonusToken(BonusToken token, PhaseManager phaseManager) {
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">        Preconditions.checkArgument(token != null, &quot;No token specified&quot;);</span>
<span class="fc" id="L681">        bonusTokens.add(token);</span>
<span class="fc" id="L682">        token.prepareForRemoval(phaseManager);</span>
<span class="fc" id="L683">        return true;</span>
    }

    public ImmutableSet&lt;BaseToken&gt; getBaseTokens() {
<span class="fc" id="L687">        ImmutableSet.Builder&lt;BaseToken&gt; tokens = ImmutableSet.builder();</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">        for (Stop stop : stops) {</span>
<span class="fc" id="L689">            tokens.addAll(stop.getBaseTokens());</span>
<span class="fc" id="L690">        }</span>
<span class="fc" id="L691">        return tokens.build();</span>
    }

    public PortfolioSet&lt;BonusToken&gt; getBonusTokens() {
<span class="nc" id="L695">        return bonusTokens;</span>
    }

    public boolean hasTokenSlotsLeft(Station station) {
        // FIXME: Is this still required
        // if (station == 0) station = 1; // Temp. fix for old save files
<span class="nc" id="L701">        return stops.get(station).hasTokenSlotsLeft();</span>
    }

    public boolean hasTokenSlotsLeft() {
<span class="nc bnc" id="L705" title="All 2 branches missed.">        for (Stop stop : stops) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">            if (stop.hasTokenSlotsLeft()) return true;</span>
<span class="nc" id="L707">        }</span>
<span class="nc" id="L708">        return false;</span>
    }

    /**
     * Check if the hex has already a token of the company in any station
     */
    public boolean hasTokenOfCompany(PublicCompany company) {
<span class="fc bfc" id="L715" title="All 2 branches covered.">        return (getStopOfBaseToken(company) != null);</span>
    }

    /**
     * Return the stop that contains the base token of a company If no token in
     * the hex, returns null
     */
    public Stop getStopOfBaseToken(PublicCompany company) {
<span class="fc bfc" id="L723" title="All 2 branches covered.">        for (Stop stop : stops) {</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">            if (stop.hasTokenOf(company)) return stop;</span>
<span class="fc" id="L725">        }</span>
<span class="fc" id="L726">        return null;</span>
    }

    public ImmutableSet&lt;Stop&gt; getStops() {
<span class="fc" id="L730">        return stops.viewValues();</span>
    }

    public ImmutableSet&lt;Stop&gt; getTokenableStops(PublicCompany company) {
<span class="nc" id="L734">        ImmutableSet.Builder&lt;Stop&gt; tokenableStops = ImmutableSet.builder();</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">        for (Stop stop : stops) {</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">            if (stop.isTokenableFor(company)) {</span>
<span class="nc" id="L737">                tokenableStops.add(stop);</span>
            }
<span class="nc" id="L739">        }</span>
<span class="nc" id="L740">        return tokenableStops.build();</span>
    }

    public Stop getRelatedStop(Station station) {
<span class="fc" id="L744">        return stops.get(station);</span>
    }

    // FIXME: Due to Rails1.x compatibility use legacy number or previous
    // numbers
    public Stop getRelatedStop(int stationNb) {
<span class="fc bfc" id="L750" title="All 2 branches covered.">        for (Stop stop : stops) {</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">            if (stop.getLegacyNumber() == stationNb) return stop;</span>
<span class="fc" id="L752">        }</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">        for (Stop stop : stops) {</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">            if (stop.checkPreviousNumbers(stationNb)) return stop;</span>
<span class="fc" id="L755">        }</span>
<span class="fc" id="L756">        return null;</span>
        // return stops.get(getStation(stationNb));
    }

    public ImmutableSet&lt;Station&gt; getStations() {
<span class="nc" id="L761">        return stops.viewKeySet();</span>
    }

    public Station getStation(int stationNb) {
<span class="nc" id="L765">        return currentTile.value().getStation(stationNb);</span>
    }

    public void addHome(PublicCompany company, Stop home) {
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">        if (stops.isEmpty()) {</span>
<span class="nc" id="L770">            log.error(&quot;No cities for home station on hex {}&quot;, getId());</span>
        } else {
            // not yet decided =&gt; create a null stop
<span class="fc bfc" id="L773" title="All 2 branches covered.">            if (home == null) {</span>
<span class="fc" id="L774">                homes.put(company, Stop.create(this, null));</span>
<span class="fc" id="L775">                log.debug(&quot;Added home of {} in hex {} city not yet decided&quot;, company, this.toString());</span>
            } else {
<span class="fc" id="L777">                homes.put(company, home);</span>
<span class="fc" id="L778">                log.debug(&quot;Added home of {} set to {} id= {}&quot;, company, home, home.getSpecificId());</span>
            }
        }
<span class="fc" id="L781">    }</span>

    public Map&lt;PublicCompany, Stop&gt; getHomes() {
<span class="nc" id="L784">        return homes.view();</span>
    }

    public boolean isHomeFor(PublicCompany company) {
<span class="fc" id="L788">        return homes.containsKey(company);</span>
    }

    public void addDestination(PublicCompany company) {
<span class="fc bfc" id="L792" title="All 2 branches covered.">        if (destinations == null) destinations = new ArrayList&lt;PublicCompany&gt;();</span>
<span class="fc" id="L793">        destinations.add(company);</span>
<span class="fc" id="L794">    }</span>

    public List&lt;PublicCompany&gt; getDestinations() {
<span class="nc" id="L797">        return destinations;</span>
    }

    /**
     * @return true if the hex is blocked by private company
     */
    public boolean isBlockedByPrivateCompany() {
<span class="nc bnc" id="L804" title="All 2 branches missed.">        return blockingPrivateCompany.value() != null;</span>
    }

    /**
     * @return blocking private company
     */
    public PrivateCompany getBlockingPrivateCompany() {
<span class="nc" id="L811">        return blockingPrivateCompany.value();</span>
    }

    /**
     * @param private company that blocks the hex (use argument null to unblock)
     */
    public void setBlockingPrivateCompany(PrivateCompany company) {
<span class="fc" id="L818">        blockingPrivateCompany.set(company);</span>
<span class="fc" id="L819">    }</span>

    /**
     * @return Returns false if no base tokens may yet be laid on this hex and
     * station.
     * &lt;p&gt;
     * NOTE: this method currently only checks for prohibitions caused by the
     * presence of unlaid home base tokens. It does NOT (yet) check for free
     * space.
     * &lt;p&gt;
     * &lt;p&gt;
     * There are the following cases to check for each company located there
     * &lt;p&gt;
     * A) City is decided or there is only one city =&gt; check if the city has a
     * free slot or not (examples: NYNH in 1830 for a two city tile, NYC for a
     * one city tile) B) City is not decided (example: Erie in 1830) two
     * subcases depending on isHomeBlockedForAllCities - (true): all cities of
     * the hex have remaining slots available - (false): no city of the hex has
     * remaining slots available C) Or the company does not block its home city
     * at all (example:Pr in 1835) then isBlockedForTokenLays attribute is used
     * &lt;p&gt;
     * NOTE: It now deals with more than one company with a home base on the
     * same hex.
     * &lt;p&gt;
     * Remark: This was a static field in Rails1.x causing potential undo
     * problems.
     */
    public boolean isBlockedForTokenLays(PublicCompany company,
                                         Stop stopToLay) {

<span class="fc bfc" id="L849" title="All 2 branches covered.">        if (isHomeFor(company)) {</span>
            // Company can always lay a home base
<span class="fc" id="L851">            return false;</span>
        }

<span class="pc bpc" id="L854" title="1 of 4 branches missed.">        switch (isBlockedForTokenLays.value()) {</span>
            case ALWAYS:
<span class="fc" id="L856">                return true;</span>
            case NEVER:
<span class="fc" id="L858">                return false;</span>
            case RESERVE_SLOT:
<span class="fc" id="L860">                return isBlockedForReservedHomes(stopToLay);</span>
        }

<span class="nc" id="L863">        return false;</span>
    }

    public boolean isBlockedForReservedHomes(Stop stopToLay) {
        // if no slots are reserved or home is empty
<span class="pc bpc" id="L868" title="1 of 2 branches missed.">        if (isBlockedForTokenLays.value() != BlockedToken.RESERVE_SLOT</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">                || homes.isEmpty()) {</span>
<span class="fc" id="L870">            return false;</span>
        }

        // check if the city is potential home for other companies
<span class="fc" id="L874">        int anyBlockCompanies = 0;</span>
<span class="fc" id="L875">        int cityBlockCompanies = 0;</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">        for (PublicCompany comp : homes.viewKeySet()) {</span>
<span class="fc bfc" id="L877" title="All 4 branches covered.">            if (comp.hasLaidHomeBaseTokens() || comp.isClosed()) continue;</span>
            // home base not laid yet
<span class="fc" id="L879">            Stop homeStop = homes.get(comp);</span>
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">            if (homeStop == null) {</span>
<span class="nc" id="L881">                anyBlockCompanies++; // undecided companies that block any</span>
                // cities
<span class="fc bfc" id="L883" title="All 2 branches covered.">            } else if (stopToLay == homeStop) {</span>
<span class="fc" id="L884">                cityBlockCompanies++; // companies which are located in the city</span>
                // in question
            } else {
<span class="fc" id="L887">                anyBlockCompanies++; // companies which are located somewhere</span>
                // else
            }
<span class="fc" id="L890">        }</span>
<span class="fc" id="L891">        log.debug(&quot;IsBlockedForTokenLays: anyBlockCompanies = &quot;</span>
                + anyBlockCompanies + &quot; , cityBlockCompanies = &quot;
                + cityBlockCompanies);

        // check if there are sufficient individual city slots
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">        if (cityBlockCompanies + 1 &gt; stopToLay.getTokenSlotsLeft()) {</span>
<span class="nc" id="L897">            return true; // the additional token exceeds the number of available</span>
            // slots
        }

        // check if the overall hex slots are sufficient
<span class="fc" id="L902">        int allTokenSlotsLeft = 0;</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">        for (Stop stop : stops) {</span>
<span class="fc" id="L904">            allTokenSlotsLeft += stop.getTokenSlotsLeft();</span>
<span class="fc" id="L905">        }</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">        if (anyBlockCompanies + cityBlockCompanies + 1 &gt; allTokenSlotsLeft) {</span>
<span class="nc" id="L907">            return true; // all located companies plus the additonal token</span>
            // exceeds the available slots
        }
<span class="fc" id="L910">        return false;</span>
    }

    public BlockedToken getBlockedForTokenLays() {
<span class="nc" id="L914">        return isBlockedForTokenLays.value();</span>
    }

    public boolean hasValuesPerPhase() {
<span class="nc bnc" id="L918" title="All 2 branches missed.">        return !valuesPerPhase.isEmpty();</span>
    }

    // FIXME: Replace by Map to Phases
    public List&lt;Integer&gt; getValuesPerPhase() {
<span class="nc" id="L923">        return valuesPerPhase;</span>
    }

    public int getCurrentValueForPhase(Phase phase) {
<span class="nc bnc" id="L927" title="All 4 branches missed.">        if (hasValuesPerPhase() &amp;&amp; phase != null) {</span>
<span class="nc" id="L928">            return valuesPerPhase.get(Math.min(valuesPerPhase.size(),</span>
<span class="nc" id="L929">                    phase.getOffBoardRevenueStep()) - 1);</span>
        } else {
<span class="nc" id="L931">            return 0;</span>
        }
    }

    public String getStopName() {
<span class="fc" id="L936">        return stopName;</span>
    }

    public PublicCompany getReservedForCompany() {
<span class="nc" id="L940">        return reservedForCompany;</span>
    }

    public boolean isReservedForCompany() {
<span class="nc bnc" id="L944" title="All 2 branches missed.">        return reservedForCompany != null;</span>
    }

    public List&lt;RevenueBonusTemplate&gt; getRevenueBonuses() {
<span class="nc" id="L948">        return revenueBonuses;</span>
    }

    public String getConnectionString(Station station) {
<span class="fc" id="L952">        return TrackConfig.getConnectionString(this, currentTile.value(),</span>
<span class="fc" id="L953">                currentTileRotation.value(), station);</span>
    }

    @Override
    public String toText() {
<span class="fc bfc" id="L958" title="All 2 branches covered.">        if (Util.hasValue(stopName)) {</span>
<span class="fc" id="L959">            return getId() + &quot; &quot; + stopName;</span>
        } else {
<span class="fc" id="L961">            return getId();</span>
        }
    }

    @Override
    public String toString() {
<span class="fc" id="L967">        return super.toString() + coordinates;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>