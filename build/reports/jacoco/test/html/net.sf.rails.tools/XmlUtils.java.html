<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.tools</a> &gt; <span class="el_source">XmlUtils.java</span></div><h1>XmlUtils.java</h1><pre class="source lang-java linenums">/* $Header: /Users/blentz/rails_rcs/cvs/18xx/tools/XmlUtils.java,v 1.1 2010/02/03 20:16:38 evos Exp $*/
package net.sf.rails.tools;

import java.io.IOException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import net.sf.rails.common.parser.ConfigurationException;


/**
 * Booch utility class providing helper functions for working with XML.
 */
public final class XmlUtils {

    /**
     * No-args private constructor, to prevent (meaningless) construction of one
     * of these.
     */
    private XmlUtils() {}

    /**
     * Extracts the String value of a given attribute from a NodeNameMap.
     * Returns null if no such attribute can be found. See
     * extractStringAttribute(NamedNodeMap nnp, String attrName, String
     * defaultValue)
     *
     * @param nnp the NodeNameMap to search for the Attribute
     * @param attrName the name of the attribute who's value is desired
     * @return the named attribute's value or null if absent.
     */
    /** @deprecated */
    @Deprecated
    public static String extractStringAttribute(NamedNodeMap nnp,
            String attrName) {
<span class="nc" id="L46">        return extractStringAttribute(nnp, attrName, null);</span>
    }

    /**
     * Extracts the String value of a given attribute from a NodeNameMap.
     * Returns a default value if no such attribute can be found.
     *
     * @param nnp the NodeNameMap to search for the Attribute
     * @param attrName the name of the attribute who's value is desired
     * @param defaultValue the value to be returned if the attribute is absent.
     * @return the named attribute's value, or the default value if absent.
     */
    /** @deprecated */
    @Deprecated
    public static String extractStringAttribute(NamedNodeMap nnp,
            String attrName, String defaultValue) {

<span class="nc bnc" id="L63" title="All 2 branches missed.">        if (nnp == null) return defaultValue;</span>
<span class="nc" id="L64">        Node nameAttr = nnp.getNamedItem(attrName);</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (nameAttr == null) return defaultValue;</span>
<span class="nc" id="L66">        return nameAttr.getNodeValue();</span>
    }

    /**
     * Extracts the integer value of a given attribute from a NodeNameMap.
     * Returns zero if no such attribute can be found.
     *
     * @see
     * @param nnp the NodeNameMap to search for the Attribute
     * @param attrName the name of the attribute who's value is desired
     * @return the named attribute's value, or zero if absent.
     */
    /** @deprecated */
    @Deprecated
    public static int extractIntegerAttribute(NamedNodeMap nnp, String attrName)
            throws ConfigurationException {
<span class="nc" id="L82">        return extractIntegerAttribute(nnp, attrName, 0);</span>
    }

    /**
     * Extracts the integer value of a given attribute from a NodeNameMap.
     * Returns a default value if no such attribute can be found.
     *
     * @see
     * @param nnp the NodeNameMap to search for the Attribute
     * @param attrName the name of the attribute who's value is desired.
     * @param defaultValue The value returned if the attribute is absent.
     * @return the named attribute's value or the dedault value.
     */
    /** @deprecated */
    @Deprecated
    public static int extractIntegerAttribute(NamedNodeMap nnp,
            String attrName, int defaultValue) throws ConfigurationException {

<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (nnp == null) return defaultValue;</span>
<span class="nc" id="L101">        Node nameAttr = nnp.getNamedItem(attrName);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (nameAttr == null) {</span>
<span class="nc" id="L103">            return defaultValue;</span>
        }
<span class="nc" id="L105">        String value = nameAttr.getNodeValue();</span>
        try {
<span class="nc" id="L107">            return Integer.parseInt(value);</span>
<span class="nc" id="L108">        } catch (Exception e) {</span>
<span class="nc" id="L109">            throw new ConfigurationException(&quot;Invalid integer value: &quot; + value,</span>
                    e);
        }
    }

    /**
     * Extracts the boolean value of a given attribute from a NodeNameMap. Any
     * string that starts with T or t (for &quot;true&quot;) or Y or y (for &quot;yes&quot;) is
     * considered to represent true, all other values will produce false.
     *
     * @param nnp The NodeNameMap to search for the Attribute
     * @param attrName The name of the attribute who's value is desired
     * @return The named attribute's value, or false if absent.
     */
    /** @deprecated */
    @Deprecated
    public static boolean extractBooleanAttribute(NamedNodeMap nnp,
            String attrName) throws ConfigurationException {
<span class="nc" id="L127">        return extractBooleanAttribute(nnp, attrName, false);</span>
    }

    /**
     * Extracts the boolean value of a given attribute from a NodeNameMap.
     * Returns a default value if no such attribute can be found. Any string
     * that starts with T or t (for &quot;true&quot;) or Y or y (for &quot;yes&quot;) is considered
     * to represent true, all other values will produce false.
     *
     * @param nnp The NodeNameMap to search for the Attribute
     * @param attrName The name of the attribute who's value is desired
     * @param defaultValue The value returned if the attribute is absent.
     * @return The named attribute's value or the default value.
     */
    /** @deprecated */
    @Deprecated
    public static boolean extractBooleanAttribute(NamedNodeMap nnp,
            String attrName, boolean defaultValue)
            throws ConfigurationException {

<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (nnp == null) return defaultValue;</span>
<span class="nc" id="L148">        Node nameAttr = nnp.getNamedItem(attrName);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (nameAttr == null) {</span>
<span class="nc" id="L150">            return defaultValue;</span>
        }
<span class="nc" id="L152">        String value = nameAttr.getNodeValue();</span>
<span class="nc" id="L153">        return value.matches(&quot;^[TtYy].*&quot;);</span>
    }

    /** @deprecated */
    @Deprecated
    public static int[] extractIntegerArrayAttribute(NamedNodeMap nnp,
            String attrName) throws ConfigurationException {

<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (nnp == null) return null;</span>
<span class="nc" id="L162">        Node nameAttr = nnp.getNamedItem(attrName);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (nameAttr == null) return new int[0];</span>
<span class="nc" id="L164">        String[] values = nameAttr.getNodeValue().split(&quot;,&quot;);</span>
<span class="nc" id="L165">        int[] result = new int[values.length];</span>
<span class="nc" id="L166">        int i = 0;</span>
        try {
<span class="nc bnc" id="L168" title="All 2 branches missed.">            for (i = 0; i &lt; values.length; i++) {</span>
<span class="nc" id="L169">                result[i] = Integer.parseInt(values[i]);</span>
            }
<span class="nc" id="L171">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L172">            throw new ConfigurationException(&quot;Invalid integer '&quot; + values[i]</span>
                                             + &quot;' in attribute '&quot; + attrName
                                             + &quot;'&quot;);
<span class="nc" id="L175">        }</span>
<span class="nc" id="L176">        return result;</span>

    }

    /**
     * Opens and parses an xml file. Searches the root level of the file for an
     * element with the supplied name.
     *
     * @param fileName the name of the file to open
     * @param elementName the name of the element to find
     * @return the named element in the named file
     * @throws ConfigurationException if there is any problem opening and
     * parsing the file, or if the file does not contain a top level element
     * with the given name.
     */
    public static Element findElementInFile(String fileName, String elementName)
            throws ConfigurationException {
<span class="nc" id="L193">        Document doc = null;</span>
        try {
            // Step 1: create a DocumentBuilderFactory and setNamespaceAware
<span class="nc" id="L196">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L197">            dbf.setNamespaceAware(true);</span>
<span class="nc" id="L198">            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span>

            // Step 2: create a DocumentBuilder
<span class="nc" id="L201">            DocumentBuilder db = dbf.newDocumentBuilder();</span>

            // Step 3: parse the input file to get a Document object
<span class="nc" id="L204">            doc = db.parse(net.sf.rails.util.Util.getStreamForFile(fileName));</span>

<span class="nc" id="L206">        } catch (ParserConfigurationException | SAXException | IOException e) {</span>
<span class="nc" id="L207">            throw new ConfigurationException(&quot;Could not read/parse &quot; + fileName</span>
                                             + &quot; to find element &quot;
                                             + elementName, e);
<span class="nc" id="L210">        }</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (doc == null) {</span>
<span class="nc" id="L213">            throw new ConfigurationException(&quot;Cannot find file &quot; + fileName);</span>
        }

        // Now find the named Element
<span class="nc" id="L217">        NodeList nodeList = doc.getChildNodes();</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        for (int iNode = 0; (iNode &lt; nodeList.getLength()); iNode++) {</span>
<span class="nc" id="L219">            Node childNode = nodeList.item(iNode);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">            if ((childNode != null)</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">                &amp;&amp; (childNode.getNodeName().equals(elementName))</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                &amp;&amp; (childNode.getNodeType() == Node.ELEMENT_NODE)) {</span>
<span class="nc" id="L223">                return (Element) childNode;</span>
            }
        }
<span class="nc" id="L226">        throw new ConfigurationException(&quot;Could not find &quot; + elementName</span>
                                         + &quot; in &quot; + fileName);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>