<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NetworkVertex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.algorithms</a> &gt; <span class="el_source">NetworkVertex.java</span></div><h1>NetworkVertex.java</h1><pre class="source lang-java linenums">package net.sf.rails.algorithms;

import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.util.*;

import net.sf.rails.game.*;
import net.sf.rails.ui.swing.hexmap.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.jgrapht.graph.SimpleGraph;


public final class NetworkVertex implements Comparable&lt;NetworkVertex&gt; {

<span class="fc" id="L17">    private static final Logger log =</span>
<span class="fc" id="L18">        LoggerFactory.getLogger(NetworkVertex.class);</span>

<span class="fc" id="L20">    public static enum VertexType {</span>
<span class="fc" id="L21">        STATION,</span>
<span class="fc" id="L22">        SIDE,</span>
<span class="fc" id="L23">        HQ,</span>
    }
<span class="fc" id="L25">    public static enum StationType {</span>
<span class="fc" id="L26">        MAJOR,</span>
<span class="fc" id="L27">        MINOR,</span>
<span class="fc" id="L28">        COALMINE</span>
    }

    // vertex types and flag for virtual (thus not related to a rails object)
    private final VertexType type;
    private final boolean virtual;

    // vertex properties (for virtual vertexes)
    private final String virtualId;

    // general vertex properties
    private StationType stationType;
<span class="fc" id="L40">    private int value = 0;</span>
<span class="fc" id="L41">    private boolean sink = false;</span>
<span class="fc" id="L42">    private String stopName = null;</span>

    // references to rails objects, if not virtual
    private final MapHex hex;
    private final TrackPoint trackPoint;
    // only for station objects
    private final Stop stop;


    /** constructor for station on mapHex */
<span class="fc" id="L52">    public NetworkVertex(MapHex hex, Station station) {</span>
<span class="fc" id="L53">        this.type = VertexType.STATION;</span>
<span class="fc" id="L54">        this.hex = hex;</span>
<span class="fc" id="L55">        this.trackPoint = station;</span>
<span class="fc" id="L56">        this.stop = hex.getRelatedStop(station);</span>
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        if (stop != null) {</span>
<span class="fc" id="L58">            log.debug(&quot;Found stop {}&quot;, stop);</span>
        } else {
<span class="nc" id="L60">            log.debug(&quot;No stop found&quot;);</span>
        }

<span class="fc" id="L63">        this.virtual = false;</span>
<span class="fc" id="L64">        this.virtualId = null;</span>
<span class="fc" id="L65">    }</span>

    /** constructor for side on mapHex */
<span class="fc" id="L68">    public NetworkVertex(MapHex hex, HexSide side) {</span>
<span class="fc" id="L69">        this.type = VertexType.SIDE;</span>
<span class="fc" id="L70">        this.hex = hex;</span>
<span class="fc" id="L71">        this.trackPoint = side;</span>
<span class="fc" id="L72">        this.stop = null;</span>

<span class="fc" id="L74">        this.virtual = false;</span>
<span class="fc" id="L75">        this.virtualId = null;</span>
<span class="fc" id="L76">    }</span>

    /**  constructor for public company hq */
    public NetworkVertex(PublicCompany company) {
<span class="fc" id="L80">        this(VertexType.HQ, &quot;HQ&quot;);</span>
<span class="fc" id="L81">    }</span>

<span class="fc" id="L83">    private NetworkVertex(VertexType type, String name) {</span>
<span class="fc" id="L84">        this.type = type;</span>
<span class="fc" id="L85">        this.hex = null;</span>
<span class="fc" id="L86">        this.trackPoint = null;</span>
<span class="fc" id="L87">        this.stop = null;</span>

<span class="fc" id="L89">        this.virtual = true;</span>
<span class="fc" id="L90">        this.virtualId = name;</span>
<span class="fc" id="L91">    }</span>

    /** factory method for virtual vertex
     */
    public static NetworkVertex getVirtualVertex(VertexType type, String name) {
<span class="nc" id="L96">        NetworkVertex vertex = new NetworkVertex(type, name);</span>
<span class="nc" id="L97">        return vertex;</span>
    }

    void addToRevenueCalculator(RevenueCalculator rc, int vertexId) {
<span class="nc" id="L101">        rc.setVertex(vertexId, isMajor(), isMinor(), sink);</span>
<span class="nc" id="L102">    }</span>

    public String getIdentifier(){
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (virtual) {</span>
<span class="fc" id="L106">            return virtualId;</span>
        } else {
<span class="fc" id="L108">            return hex.getId() + &quot;.&quot; + trackPoint.getTrackPointNumber();</span>
        }
    }

    public boolean isVirtual() {
<span class="fc" id="L113">        return virtual;</span>
    }

    public boolean isStation(){
<span class="fc bfc" id="L117" title="All 2 branches covered.">        return type == VertexType.STATION;</span>
    }

    public boolean isSide(){
<span class="fc bfc" id="L121" title="All 2 branches covered.">        return type == VertexType.SIDE;</span>
    }

    public boolean isHQ(){
<span class="nc bnc" id="L125" title="All 2 branches missed.">        return type == VertexType.HQ;</span>
    }

    public VertexType getType() {
<span class="fc" id="L129">        return type;</span>
    }

    public boolean isMajor(){
<span class="nc bnc" id="L133" title="All 4 branches missed.">        return (stationType != null &amp;&amp; stationType == StationType.MAJOR);</span>
    }

    public boolean isMinor(){
<span class="nc bnc" id="L137" title="All 4 branches missed.">        return (stationType != null &amp;&amp; stationType == StationType.MINOR);</span>
    }

    public boolean isMine( ) {
<span class="nc bnc" id="L141" title="All 4 branches missed.">        return (stationType != null &amp;&amp; stationType == StationType.COALMINE);</span>
    }

    public StationType getStationType() {
<span class="nc" id="L145">        return stationType;</span>
    }

    public NetworkVertex setStationType(StationType stationType) {
<span class="fc" id="L149">        this.stationType = stationType;</span>
<span class="fc" id="L150">        return this;</span>
    }

    public int getValue() {
<span class="nc" id="L154">        return value;</span>
    }

    public int getValueByTrain(NetworkTrain train) {
        int valueByTrain;
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (isMajor()) {</span>
<span class="nc" id="L160">            valueByTrain = value * train.getMultiplyMajors();</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        } else if (isMinor()) {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            if (train.ignoresMinors()) {</span>
<span class="nc" id="L163">                valueByTrain = 0;</span>
            } else {
<span class="nc" id="L165">                valueByTrain = value * train.getMultiplyMinors();</span>
            }
<span class="nc bnc" id="L167" title="All 2 branches missed.">        } else if (isMine()) { //Sofar Coal mines count nothing for the dividend income, the revenue from a mine is counted differently.</span>
<span class="nc" id="L168">            valueByTrain = 0;</span>
        } else {
<span class="nc" id="L170">            valueByTrain = value;</span>
        }
<span class="nc" id="L172">        return valueByTrain;</span>
    }

    public NetworkVertex setValue(int value) {
<span class="nc" id="L176">        this.value = value;</span>
<span class="nc" id="L177">        return this;</span>
    }

    public boolean isSink() {
<span class="fc" id="L181">        return sink;</span>
    }

    public NetworkVertex setSink(boolean sink) {
<span class="fc" id="L185">        this.sink = sink;</span>
<span class="fc" id="L186">        return this;</span>
    }

    public String getStopName() {
<span class="nc" id="L190">        return stopName;</span>
    }

    public NetworkVertex setStopName(String locationName) {
<span class="nc" id="L194">        this.stopName = locationName;</span>
<span class="nc" id="L195">        return this;</span>
    }

    // getter for rails objects
    public MapHex getHex(){
<span class="fc" id="L200">        return hex;</span>
    }

    public Station getStation(){
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (type == VertexType.STATION) {</span>
<span class="fc" id="L205">            return (Station) trackPoint;</span>
        } else {
<span class="nc" id="L207">            return null;</span>
        }
    }

    public HexSide getSide(){
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (type == VertexType.SIDE) {</span>
<span class="nc" id="L213">            return (HexSide) trackPoint;</span>
        } else {
<span class="nc" id="L215">            return null;</span>
        }
    }

    public Stop getStop() {
<span class="nc" id="L220">        return stop;</span>
    }

    public boolean isOfType(VertexType vertexType, StationType stationType) {
<span class="nc bnc" id="L224" title="All 6 branches missed.">        return (type == vertexType &amp;&amp; (!isStation() || getStationType() == stationType));</span>
    }

    /**
     * Initialize for rails vertexes
     * @return true = can stay inside the network, false = has to be removed
     */
    public boolean initRailsVertex(PublicCompany company) {
        // side vertices use the defaults, virtuals cannot use this function
<span class="pc bpc" id="L233" title="1 of 4 branches missed.">        if (virtual || type == VertexType.SIDE) return true;</span>

        // Only station remains
<span class="fc" id="L236">        Station station = (Station) trackPoint;</span>

<span class="fc" id="L238">        log.debug(&quot;Init of vertex {}&quot;, this);</span>

        // check if it has to be removed because it is run-to only
        // if company == null, then no vertex gets removed
<span class="pc bpc" id="L242" title="2 of 4 branches missed.">        if (company != null &amp;&amp; !stop.isRunToAllowedFor(company)) {</span>
<span class="nc" id="L243">           log.info(&quot;Vertex is removed&quot;);</span>
<span class="nc" id="L244">           return false;</span>
        }

        // check if it is a major or minor
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (stop.getScoreType() == StopType.Score.MAJOR) {</span>
<span class="fc" id="L249">            setStationType(StationType.MAJOR);</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        } else if (stop.getScoreType() == StopType.Score.MINOR) {</span>
<span class="fc" id="L251">            setStationType(StationType.MINOR);</span>
        }

        // check if it is a sink
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (company == null) { // if company == null, then all sinks are deactivated</span>
<span class="nc" id="L256">            sink = false;</span>
        } else {
<span class="fc bfc" id="L258" title="All 2 branches covered.">            sink = !stop.isRunThroughAllowedFor(company);</span>
        }

        // define locationName
<span class="fc" id="L262">        stopName = null;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (station.getType() == Station.Type.OFFMAPCITY) {</span>
<span class="pc bpc" id="L264" title="2 of 4 branches missed.">            if (hex.getStopName() != null &amp;&amp; !hex.getStopName().equals(&quot;&quot;)) {</span>
<span class="fc" id="L265">                stopName = hex.getStopName();</span>
            }
        } else {
<span class="pc bpc" id="L268" title="1 of 4 branches missed.">            if (hex.getStopName() != null &amp;&amp; !hex.getStopName().equals(&quot;&quot;)</span>
<span class="pc bpc" id="L269" title="3 of 4 branches missed.">                    &amp;&amp; station.getStopName() != null &amp;&amp; !station.getStopName().equals(&quot;&quot;)) {</span>
<span class="nc" id="L270">                stopName = hex.getStopName() + &quot;.&quot; + station.getStopName();</span>
            }
        }

        // no removal
<span class="fc" id="L275">        return true;</span>

    }

    public void setRailsVertexValue(Phase phase) {
        // side vertices and  virtuals cannot use this function
<span class="nc bnc" id="L281" title="All 4 branches missed.">        if (virtual || type == VertexType.SIDE) return;</span>

        // define value
<span class="nc" id="L284">        value = stop.getValueForPhase(phase);</span>
<span class="nc" id="L285">    }</span>


    @Override
    public String toString(){
<span class="fc" id="L290">        StringBuilder message = new StringBuilder();</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (isVirtual())</span>
<span class="nc" id="L292">            message.append(virtualId);</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">        else if (isStation())</span>
<span class="fc" id="L294">            message.append(hex.getId()).append(&quot;.&quot;).append(((Station) trackPoint).getNumber());</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        else if (isSide())</span>
<span class="fc" id="L296">            message.append(hex.getId()).append(&quot;.&quot;).append(hex.getOrientationName((HexSide) trackPoint));</span>
        else
<span class="nc" id="L298">            message.append(&quot;HQ&quot;);</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (isSink())</span>
<span class="fc" id="L300">            message.append(&quot;/*&quot;);</span>
<span class="fc" id="L301">        return message.toString();</span>
    }

    public int compareTo(NetworkVertex otherVertex) {
<span class="nc" id="L305">        return this.getIdentifier().compareTo(otherVertex.getIdentifier());</span>
    }

<span class="nc" id="L308">    public static final class ValueOrder implements Comparator&lt;NetworkVertex&gt; {</span>

        public int compare(NetworkVertex vA, NetworkVertex vB) {
<span class="nc" id="L311">            int result = -((Integer)vA.getValue()).compareTo(vB.getValue()); // compare by value, descending</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (result == 0)</span>
<span class="nc" id="L313">                result = vA.compareTo(vB); // otherwise use natural ordering</span>
<span class="nc" id="L314">            return result;</span>
        }
    }

    /**
     *
     * @param graph network graph
     * @param company the company (with regard to values, sinks and removals)
     * @param phase the current phase (with regard to values)
     */
    public static void initAllRailsVertices(NetworkGraph graph,
            PublicCompany company,  Phase phase) {

        // store vertices for removal
<span class="fc" id="L328">        List&lt;NetworkVertex&gt; verticesToRemove = new ArrayList&lt;NetworkVertex&gt;();</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">        for (NetworkVertex v:graph.getGraph().vertexSet()) {</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">            if (company != null) {</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">                if (!v.initRailsVertex(company)) {</span>
<span class="nc" id="L332">                    verticesToRemove.add(v);</span>
                }
            }
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">            if (phase != null) {</span>
<span class="nc" id="L336">                v.setRailsVertexValue(phase);</span>
            }
<span class="fc" id="L338">        }</span>
<span class="fc" id="L339">        graph.getGraph().removeAllVertices(verticesToRemove);</span>
<span class="fc" id="L340">    }</span>

    /**
     * Returns the maximum positive value (lower bound zero)
     */
    public static int maxVertexValue(Collection&lt;NetworkVertex&gt; vertices) {
<span class="nc" id="L346">        int maximum = 0;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        for (NetworkVertex vertex:vertices) {</span>
<span class="nc" id="L348">            maximum = Math.max(maximum, vertex.getValue());</span>
<span class="nc" id="L349">        }</span>
<span class="nc" id="L350">        return maximum;</span>
    }


    /**
     * Return the sum of vertex values
     */
    public static int sum(Collection&lt;NetworkVertex&gt; vertices) {
<span class="nc" id="L358">        int sum = 0;</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">        for (NetworkVertex vertex:vertices) {</span>
<span class="nc" id="L360">            sum += vertex.getValue();</span>
<span class="nc" id="L361">        }</span>
<span class="nc" id="L362">        return sum;</span>
    }

    /**
     * Returns the number of specified vertex type in a vertex collection
     * If station then specify station type
     */
    public static int numberOfVertexType(Collection&lt;NetworkVertex&gt; vertices, VertexType vertexType, StationType stationType) {
<span class="nc" id="L370">        int number = 0;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        for (NetworkVertex vertex:vertices) {</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (vertex.isOfType(vertexType, stationType)) number++;</span>
<span class="nc" id="L373">        }</span>
<span class="nc" id="L374">        return number;</span>
    }

    /**
     * creates a new virtual vertex with identical properties and links
     */
    public static NetworkVertex duplicateVertex(SimpleGraph&lt;NetworkVertex, NetworkEdge&gt; graph,
            NetworkVertex vertex, String newIdentifier, boolean addOldVertexAsHidden) {
        // create new vertex
<span class="nc" id="L383">        NetworkVertex newVertex = NetworkVertex.getVirtualVertex(vertex.type, newIdentifier);</span>
        // copy values
<span class="nc" id="L385">        newVertex.stationType = vertex.stationType;</span>
<span class="nc" id="L386">        newVertex.value = vertex.value;</span>
<span class="nc" id="L387">        newVertex.sink = vertex.sink;</span>
<span class="nc" id="L388">        newVertex.stopName = vertex.stopName;</span>
<span class="nc" id="L389">        graph.addVertex(newVertex);</span>
        // copy edges
<span class="nc" id="L391">        Set&lt;NetworkEdge&gt; edges = graph.edgesOf(vertex);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        for (NetworkEdge edge:edges) {</span>
            List&lt;NetworkVertex&gt; hiddenVertices;
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (edge.getSource() == vertex) {</span>
<span class="nc" id="L395">                hiddenVertices = edge.getHiddenVertices();</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">                if (addOldVertexAsHidden) hiddenVertices.add(vertex);</span>
<span class="nc" id="L397">                NetworkEdge newEdge = new NetworkEdge(newVertex, edge.getTarget(), edge.isGreedy(), edge.getDistance(), hiddenVertices);</span>
<span class="nc" id="L398">                graph.addEdge(newVertex, edge.getTarget(), newEdge);</span>
<span class="nc" id="L399">            } else {</span>
<span class="nc" id="L400">                hiddenVertices = new ArrayList&lt;NetworkVertex&gt;();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">                if (addOldVertexAsHidden) hiddenVertices.add(vertex);</span>
<span class="nc" id="L402">                hiddenVertices.addAll(edge.getHiddenVertices());</span>
<span class="nc" id="L403">                NetworkEdge newEdge = new NetworkEdge(edge.getSource(), newVertex, edge.isGreedy(), edge.getDistance(), hiddenVertices);</span>
<span class="nc" id="L404">                graph.addEdge(newEdge.getSource(), newVertex, newEdge);</span>
            }
<span class="nc" id="L406">        }</span>
<span class="nc" id="L407">        return newVertex;</span>
    }

    /**
     * replaces one vertex by another for a network graph
     * copies all edges
     */
    public static boolean replaceVertex(SimpleGraph&lt;NetworkVertex, NetworkEdge&gt; graph,
            NetworkVertex oldVertex, NetworkVertex newVertex) {
        // add new vertex
<span class="nc" id="L417">        graph.addVertex(newVertex);</span>
        // replace old edges
<span class="nc" id="L419">        Set&lt;NetworkEdge&gt; oldEdges = graph.edgesOf(oldVertex);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        for (NetworkEdge oldEdge:oldEdges) {</span>
<span class="nc" id="L421">            NetworkEdge newEdge = NetworkEdge.replaceVertex(oldEdge, oldVertex, newVertex);</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (newEdge.getSource() == newVertex) {</span>
<span class="nc" id="L423">                graph.addEdge(newVertex, newEdge.getTarget(), newEdge);</span>
            } else {
<span class="nc" id="L425">                graph.addEdge(newEdge.getSource(), newVertex, newEdge);</span>
            }
<span class="nc" id="L427">        }</span>
        // remove old vertex
<span class="nc" id="L429">        return graph.removeVertex(oldVertex);</span>
    }

    /**
     * Filters all vertices from a collection of vertices that lay in a specified collection of hexes
     */
    public static Set&lt;NetworkVertex&gt; getVerticesByHexes(Collection&lt;NetworkVertex&gt; vertices, Collection&lt;MapHex&gt; hexes) {
<span class="nc" id="L436">        Set&lt;NetworkVertex&gt; hexVertices = new HashSet&lt;NetworkVertex&gt;();</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        for (NetworkVertex vertex:vertices) {</span>
<span class="nc bnc" id="L438" title="All 4 branches missed.">            if (vertex.getHex() != null &amp;&amp; hexes.contains(vertex.getHex())) {</span>
<span class="nc" id="L439">                hexVertices.add(vertex);</span>
            }
<span class="nc" id="L441">        }</span>
<span class="nc" id="L442">        return hexVertices;</span>
    }

    /**
     * Returns all vertices for a specified hex
     */
    public static Set&lt;NetworkVertex&gt; getVerticesByHex(Collection&lt;NetworkVertex&gt; vertices, MapHex hex) {
<span class="nc" id="L449">        Set&lt;NetworkVertex&gt; hexVertices = new HashSet&lt;NetworkVertex&gt;();</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">        for (NetworkVertex vertex:vertices) {</span>
<span class="nc bnc" id="L451" title="All 4 branches missed.">            if (vertex.getHex() != null &amp;&amp; hex == vertex.getHex()) {</span>
<span class="nc" id="L452">                hexVertices.add(vertex);</span>
            }
<span class="nc" id="L454">        }</span>
<span class="nc" id="L455">        return hexVertices;</span>
    }

    public static NetworkVertex getVertexByIdentifier(Collection&lt;NetworkVertex&gt; vertices, String identifier) {
<span class="nc bnc" id="L459" title="All 2 branches missed.">        for (NetworkVertex vertex:vertices) {</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            if (vertex.getIdentifier().equals(identifier)) {</span>
<span class="nc" id="L461">                return vertex;</span>
            }
<span class="nc" id="L463">        }</span>
<span class="nc" id="L464">        return null;</span>
    }

    public static Point2D getVertexPoint2D(HexMap map, NetworkVertex vertex) {
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (vertex.isVirtual()) return null;</span>

<span class="nc" id="L470">        GUIHex guiHex = map.getHex(vertex.getHex());</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">        if (vertex.isMajor()) {</span>
<span class="nc" id="L472">            return guiHex.getStopPoint2D(vertex.getStop());</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">        } else if (vertex.isMinor()) {</span>
<span class="nc" id="L474">            return guiHex.getStopPoint2D(vertex.getStop());</span>
            //            return guiHex.getCenterPoint2D();
<span class="nc bnc" id="L476" title="All 2 branches missed.">        } else if (vertex.isSide()) {</span>
            // FIXME: Check if this still works
<span class="nc" id="L478">            return guiHex.getSidePoint2D(vertex.getSide());</span>
        } else {
<span class="nc" id="L480">            return null;</span>
        }
    }

    public static Rectangle getVertexMapCoverage(HexMap map, Collection&lt;NetworkVertex&gt; vertices) {

<span class="nc" id="L486">        Rectangle rectangle = null;</span>

        // find coverage are of the vertices
<span class="nc" id="L489">        double minX=0,minY=0,maxX=0,maxY=0;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        for (NetworkVertex vertex:vertices) {</span>
<span class="nc" id="L491">            Point2D point = getVertexPoint2D(map, vertex);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">            if (point != null) {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                if (minX == 0) { // init</span>
<span class="nc" id="L494">                    rectangle = new Rectangle((int)point.getX(), (int)point.getY(), 0, 0);</span>
<span class="nc" id="L495">                    minX = point.getX();</span>
<span class="nc" id="L496">                    minY = point.getY();</span>
<span class="nc" id="L497">                    maxX = minX; maxY = minY;</span>
                } else {
<span class="nc" id="L499">                    rectangle.add(point);</span>
<span class="nc" id="L500">                    minX = Math.min(minX, point.getX());</span>
<span class="nc" id="L501">                    minY = Math.min(minY, point.getY());</span>
<span class="nc" id="L502">                    maxX = Math.max(maxX, point.getX());</span>
<span class="nc" id="L503">                    maxY = Math.max(maxY, point.getY());</span>
                }
            }
<span class="nc" id="L506">        }</span>
<span class="nc" id="L507">        log.debug(&quot;Vertex Map Coverage minX={}, minY={}, maxX={}, maxY={}&quot;, minX, minY, maxX, maxY);</span>
        //        Rectangle rectangle = new Rectangle((int)minX, (int)minY, (int)maxX, (int)maxY);
<span class="nc" id="L509">        log.debug(&quot;Created rectangle={}&quot;, rectangle);</span>
<span class="nc" id="L510">        return (rectangle);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>