<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NetworkEdge.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.algorithms</a> &gt; <span class="el_source">NetworkEdge.java</span></div><h1>NetworkEdge.java</h1><pre class="source lang-java linenums">package net.sf.rails.algorithms;

import java.awt.Shape;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import net.sf.rails.ui.swing.hexmap.HexMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.jgrapht.Graph;


public final class NetworkEdge implements Comparable&lt;NetworkEdge&gt; {

<span class="fc" id="L20">    private static final Logger log = LoggerFactory.getLogger(NetworkEdge.class);</span>

    private final NetworkVertex source;

    private final NetworkVertex target;

    private boolean greedy;

    private final int distance;

    private final List&lt;NetworkVertex&gt; hiddenVertices;
    // list of vertexes that were merged into the edge

    private int routeCosts;
    // for the multigraph approach defines the number of routes excluded

<span class="fc" id="L36">    public NetworkEdge(NetworkVertex source, NetworkVertex target, boolean greedy) {</span>
<span class="fc" id="L37">        this.source = source;</span>
<span class="fc" id="L38">        this.target = target;</span>
<span class="fc" id="L39">        this.greedy = greedy;</span>
<span class="fc bfc" id="L40" title="All 2 branches covered.">        if (greedy)</span>
<span class="fc" id="L41">            this.distance = 1;</span>
        else
<span class="fc" id="L43">            this.distance = 0;</span>
<span class="fc" id="L44">        hiddenVertices = new ArrayList&lt;NetworkVertex&gt;();</span>
<span class="fc" id="L45">    }</span>

    public NetworkEdge(NetworkVertex source, NetworkVertex target, boolean greedy,
<span class="nc" id="L48">                int distance, List&lt;NetworkVertex&gt; hiddenVertexes) {</span>
<span class="nc" id="L49">        this.source = source;</span>
<span class="nc" id="L50">        this.target = target;</span>
<span class="nc" id="L51">        this.greedy = greedy;</span>
<span class="nc" id="L52">        this.distance = distance;</span>
<span class="nc" id="L53">        this.hiddenVertices = hiddenVertexes;</span>
<span class="nc" id="L54">    }</span>

    public NetworkVertex getSource() {
<span class="nc" id="L57">        return source;</span>
    }

    public NetworkVertex getTarget() {
<span class="nc" id="L61">        return target;</span>
    }

    private NetworkVertex getLowVertex() {
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (source.compareTo(target) &lt;= 0) {</span>
<span class="nc" id="L66">            return source;</span>
        } else {
<span class="nc" id="L68">            return target;</span>
        }
    }

    private NetworkVertex getHighVertex() {
<span class="nc bnc" id="L73" title="All 2 branches missed.">        if (source.compareTo(target) &lt;= 0) {</span>
<span class="nc" id="L74">            return target;</span>
        } else {
<span class="nc" id="L76">            return source;</span>
        }
    }

    /** returns the other vertex, if given vertex is not source/target of vertex, returns null */
    NetworkVertex getOtherVertex(NetworkVertex vertex) {
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (this.source == vertex) {</span>
<span class="nc" id="L83">            return target;</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">        } else if (this.target == vertex) {</span>
<span class="nc" id="L85">            return source;</span>
        }
<span class="nc" id="L87">        return null;</span>
    }

    /** gets common vertex, if both source and target are common, returns source of this edge */
    NetworkVertex getCommonVertex(NetworkEdge otherEdge) {
<span class="nc bnc" id="L92" title="All 4 branches missed.">       if (this.source == otherEdge.source || this.source == otherEdge.target) {</span>
<span class="nc" id="L93">           return this.source;</span>
<span class="nc bnc" id="L94" title="All 4 branches missed.">       } else if (this.target == otherEdge.source || this.target == otherEdge.target) {</span>
<span class="nc" id="L95">           return this.target;</span>
       }
<span class="nc" id="L97">       return null;</span>
    }

    public boolean isGreedy() {
<span class="fc" id="L101">        return greedy;</span>
    }

    public void setGreedy(boolean greedy) {
<span class="nc" id="L105">       this.greedy = greedy;</span>
<span class="nc" id="L106">    }</span>

    public int getDistance() {
<span class="nc" id="L109">        return distance;</span>
    }

    int getRouteCosts() {
<span class="nc" id="L113">        return routeCosts;</span>
    }

    void setRouteCosts(int routeCosts) {
<span class="nc" id="L117">        this.routeCosts = routeCosts;</span>
<span class="nc" id="L118">    }</span>

    public List&lt;NetworkVertex&gt; getHiddenVertices() {
<span class="nc" id="L121">        return hiddenVertices;</span>
    }

    /**
     * all vertices from source to target, including hidden vertices
     */
    public List&lt;NetworkVertex&gt; getVertexPath() {
<span class="nc" id="L128">        List&lt;NetworkVertex&gt; vertexPath = new ArrayList&lt;NetworkVertex&gt;();</span>
<span class="nc" id="L129">        vertexPath.add(source);</span>
<span class="nc" id="L130">        vertexPath.addAll(hiddenVertices);</span>
<span class="nc" id="L131">        vertexPath.add(target);</span>
<span class="nc" id="L132">        return vertexPath;</span>
    }

    public String toFullInfoString() {
<span class="fc" id="L136">        StringBuilder info = new StringBuilder();</span>
<span class="fc" id="L137">        info.append(&quot;Edge &quot;).append(getConnection());</span>
<span class="fc" id="L138">        info.append(&quot;, greedy = &quot;).append(greedy);</span>
<span class="fc" id="L139">        info.append(&quot;, distance = &quot;).append(distance);</span>
<span class="fc" id="L140">        info.append(&quot;, hidden vertexes = &quot;).append(hiddenVertices);</span>
<span class="fc" id="L141">        return info.toString();</span>
    }

    public String getOrderedConnection() {
<span class="nc" id="L145">        return getLowVertex() + &quot; -&gt; &quot; + getHighVertex();</span>
    }

    public String getConnection() {
<span class="fc" id="L149">      return source + &quot; -&gt; &quot; + target;</span>
    }

    @Override
    // set to &quot;&quot; to faciltate visual graph
    public String toString() {
<span class="nc" id="L155">        return getConnection();</span>
//        if (!greedy)
//            return &quot;*** / &quot; + distance;
//        else
//          return &quot;&quot; + distance;
    }

    /**
     * Natural order based on the ordering of the connected vertices
     */
    public int compareTo(NetworkEdge otherEdge) {
<span class="nc" id="L166">        int result = this.getLowVertex().compareTo(otherEdge.getLowVertex());</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (result == 0) {</span>
<span class="nc" id="L168">            result = this.getHighVertex().compareTo(otherEdge.getHighVertex());</span>
        }
<span class="nc" id="L170">        return result;</span>
    }

    /**
     * Ordering based on routecosts
     */
<span class="nc" id="L176">    public static final class CostOrder implements Comparator&lt;NetworkEdge&gt; {</span>

        public int compare(NetworkEdge edgeA, NetworkEdge edgeB) {
<span class="nc" id="L179">            int result = Integer.compare(edgeA.getRouteCosts(), edgeB.getRouteCosts());</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (result == 0)</span>
<span class="nc" id="L181">                result = edgeA.compareTo(edgeB); // otherwise use natural ordering</span>
<span class="nc" id="L182">            return result;</span>
        }
    }


    static class MergeResult {
        protected NetworkEdge newEdge;
        protected NetworkVertex removedVertex;
<span class="nc" id="L190">        MergeResult(NetworkEdge newEdge, NetworkVertex removedVertex) {</span>
<span class="nc" id="L191">            this.newEdge = newEdge;</span>
<span class="nc" id="L192">            this.removedVertex = removedVertex;</span>
<span class="nc" id="L193">        }</span>
    }

    public static MergeResult mergeEdges(NetworkEdge edgeA, NetworkEdge edgeB) {
<span class="nc" id="L197">        log.info(&quot;Merge of edge {} and edge {}&quot;, edgeA.toFullInfoString(), edgeB.toFullInfoString());</span>

<span class="nc" id="L199">        NetworkVertex sourceA = edgeA.getSource();</span>
<span class="nc" id="L200">        NetworkVertex targetA = edgeA.getTarget();</span>
<span class="nc" id="L201">        NetworkVertex sourceB = edgeB.getSource();</span>
<span class="nc" id="L202">        NetworkVertex targetB = edgeB.getTarget();</span>

<span class="nc" id="L204">        NetworkVertex newSource, newTarget, vertex = null;</span>

<span class="nc" id="L206">        boolean reverseA = false, reverseB = false;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (sourceA == sourceB) {</span>
<span class="nc" id="L208">            newSource = targetA;</span>
<span class="nc" id="L209">            newTarget = targetB;</span>
<span class="nc" id="L210">            vertex = sourceA;</span>
<span class="nc" id="L211">            reverseA = true;</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        } else if (sourceA == targetB) {</span>
<span class="nc" id="L213">            newSource = targetA;</span>
<span class="nc" id="L214">            newTarget = sourceB;</span>
<span class="nc" id="L215">            vertex = sourceA;</span>
<span class="nc" id="L216">            reverseA = true;</span>
<span class="nc" id="L217">            reverseB = true;</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        } else if (targetA == sourceB) {</span>
<span class="nc" id="L219">            newSource = sourceA;</span>
<span class="nc" id="L220">            newTarget = targetB;</span>
<span class="nc" id="L221">            vertex = targetA;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        } else if (targetA == targetB) {</span>
<span class="nc" id="L223">            newSource = sourceA;</span>
<span class="nc" id="L224">            newTarget = sourceB;</span>
<span class="nc" id="L225">            vertex = targetA;</span>
<span class="nc" id="L226">            reverseB = true;</span>
        } else {
<span class="nc" id="L228">            return null;</span>
        }

<span class="nc" id="L231">        log.info(&quot;Merge newSource = {} newTarget = {} remove vertex = {}&quot;, newSource, newTarget, vertex);</span>

        // define new edge
<span class="nc" id="L234">        int distance = edgeA.getDistance() + edgeB.getDistance();</span>

        // create new hiddenVertexes
<span class="nc" id="L237">        List&lt;NetworkVertex&gt; hiddenVertexes = new ArrayList&lt;NetworkVertex&gt;();</span>
<span class="nc" id="L238">        List&lt;NetworkVertex&gt; hiddenA = edgeA.getHiddenVertices();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (reverseA) {</span>
<span class="nc" id="L240">            hiddenA = new ArrayList&lt;NetworkVertex&gt;(hiddenA); // clone</span>
<span class="nc" id="L241">            Collections.reverse(hiddenA);</span>
        }
<span class="nc" id="L243">        List&lt;NetworkVertex&gt; hiddenB = edgeB.getHiddenVertices();</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (reverseB) {</span>
<span class="nc" id="L245">            hiddenB = new ArrayList&lt;NetworkVertex&gt;(hiddenB); // clone</span>
<span class="nc" id="L246">            Collections.reverse(hiddenB);</span>
        }
<span class="nc" id="L248">        hiddenVertexes.addAll(hiddenA);</span>
<span class="nc" id="L249">        hiddenVertexes.add(vertex);</span>
<span class="nc" id="L250">        hiddenVertexes.addAll(hiddenB);</span>
<span class="nc" id="L251">        NetworkEdge newEdge =</span>
            new NetworkEdge(newSource, newTarget, true, distance, hiddenVertexes);
<span class="nc" id="L253">        log.info(&quot;New edge = {}&quot;, newEdge.toFullInfoString());</span>

        // returns newEdge
<span class="nc" id="L256">        return new MergeResult(newEdge, vertex);</span>
    }

    public static boolean mergeEdgesInGraph(Graph&lt;NetworkVertex, NetworkEdge&gt; graph,
            NetworkEdge edgeA, NetworkEdge edgeB) {

        // use generic merge function
<span class="nc" id="L263">        MergeResult mergeResult = mergeEdges(edgeA, edgeB);</span>
<span class="nc" id="L264">        NetworkEdge newEdge = mergeResult.newEdge;</span>
<span class="nc" id="L265">        NetworkVertex removedVertex = mergeResult.removedVertex;</span>

<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (newEdge == null) return false;</span>

        // check if graph contains the edge already
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (graph.containsEdge(newEdge.getSource(), newEdge.getTarget())) return false;</span>

<span class="nc" id="L272">        graph.addEdge(newEdge.getSource(), newEdge.getTarget(), newEdge);</span>

<span class="nc" id="L274">        log.info(&quot;New edge = {}&quot;, newEdge.toFullInfoString());</span>

        // remove vertex
<span class="nc" id="L277">        graph.removeVertex(removedVertex);</span>

<span class="nc" id="L279">        return true;</span>
    }

    /**
     * for a given edge it replaces one of the vertices by a different one
     * otherwise copies all edge attributes
     * @return copied edge with replaced vertex, null if oldVertex is neither source, nor target
     */
    public static NetworkEdge replaceVertex(NetworkEdge edge, NetworkVertex oldVertex, NetworkVertex newVertex) {
        NetworkEdge newEdge;
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (edge.source == oldVertex) {</span>
<span class="nc" id="L290">            newEdge= new NetworkEdge(newVertex, edge.target, edge.greedy, edge.distance, edge.hiddenVertices);</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        } else if (edge.target == oldVertex) {</span>
<span class="nc" id="L292">            newEdge= new NetworkEdge(edge.source, newVertex, edge.greedy, edge.distance, edge.hiddenVertices);</span>
        } else {
<span class="nc" id="L294">            newEdge = null;</span>
        }
<span class="nc" id="L296">        return newEdge;</span>
    }

    public static Shape getEdgeShape(HexMap map, NetworkEdge edge){
<span class="nc" id="L300">        Point2D source = NetworkVertex.getVertexPoint2D(map, edge.getSource());</span>
<span class="nc" id="L301">        Point2D target = NetworkVertex.getVertexPoint2D(map, edge.getTarget());</span>
        Shape edgeShape;
<span class="nc bnc" id="L303" title="All 4 branches missed.">        if (source != null &amp;&amp; target != null) {</span>
<span class="nc" id="L304">            edgeShape = new Line2D.Double(source, target);</span>
        } else {
<span class="nc" id="L306">            edgeShape = null;</span>
        }
<span class="nc" id="L308">        return edgeShape;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>