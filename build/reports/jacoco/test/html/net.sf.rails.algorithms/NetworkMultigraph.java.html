<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NetworkMultigraph.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.algorithms</a> &gt; <span class="el_source">NetworkMultigraph.java</span></div><h1>NetworkMultigraph.java</h1><pre class="source lang-java linenums">package net.sf.rails.algorithms;


import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import net.sf.rails.algorithms.RevenueAdapter.EdgeTravel;

import org.jgrapht.Graphs;
import org.jgrapht.graph.Multigraph;
import org.jgrapht.graph.SimpleGraph;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;

/**
 * the phase 2 graph is a multigraph due to the multiple routes between vertices
 */
public class NetworkMultigraph {

<span class="nc" id="L29">    private static final Logger log =</span>
<span class="nc" id="L30">            LoggerFactory.getLogger(NetworkMultigraph.class);</span>

    private final NetworkGraph inGraph;
<span class="nc" id="L33">    private final Multigraph&lt;NetworkVertex, NetworkEdge&gt; graph2 =</span>
            new Multigraph&lt;NetworkVertex, NetworkEdge&gt;(NetworkEdge.class);
<span class="nc" id="L35">    private final Multimap&lt;NetworkEdge, NetworkEdge&gt; partial2route =</span>
<span class="nc" id="L36">            HashMultimap.create();</span>
<span class="nc" id="L37">    private final Multimap&lt;NetworkEdge, NetworkEdge&gt; route2partial =</span>
<span class="nc" id="L38">            HashMultimap.create();</span>

<span class="nc" id="L40">    private NetworkMultigraph(NetworkGraph inGraph) {</span>
<span class="nc" id="L41">        this.inGraph = inGraph;</span>
<span class="nc" id="L42">    }</span>

    public static NetworkMultigraph create(NetworkGraph inGraph, Collection&lt;NetworkVertex&gt; protectedVertices) {
<span class="nc" id="L45">        NetworkMultigraph newGraph = new NetworkMultigraph(inGraph);</span>
<span class="nc" id="L46">        newGraph.initMultigraph(protectedVertices);</span>
<span class="nc" id="L47">        return newGraph;</span>
    }

    public Multigraph&lt;NetworkVertex, NetworkEdge&gt; getGraph() {
<span class="nc" id="L51">        return graph2;</span>
    }

    private void initMultigraph(Collection&lt;NetworkVertex&gt; protectedVertices) {
<span class="nc" id="L55">        log.debug(&quot;Ingraph&quot; + inGraph.getGraph());</span>
        // clone the inGraph
<span class="nc" id="L57">        SimpleGraph&lt;NetworkVertex, NetworkEdge&gt; graph = new SimpleGraph&lt;NetworkVertex, NetworkEdge&gt;(NetworkEdge.class);</span>
<span class="nc" id="L58">        Graphs.addGraph(graph, inGraph.getGraph());</span>

        // define the relevant vertices: stations and protected
<span class="nc" id="L61">        Set&lt;NetworkVertex&gt; relevantVertices = new HashSet&lt;NetworkVertex&gt;();</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        if (protectedVertices != null) {</span>
            // check if they are in the graph
<span class="nc bnc" id="L64" title="All 2 branches missed.">            for (NetworkVertex vertex:protectedVertices) {</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">                if (graph.containsVertex(vertex)) {</span>
<span class="nc" id="L66">                    relevantVertices.add(vertex);</span>
                }
<span class="nc" id="L68">            }</span>

        }

        // add station vertices
<span class="nc bnc" id="L73" title="All 2 branches missed.">        for (NetworkVertex vertex:graph.vertexSet()) {</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">            if (vertex.isStation()) {</span>
<span class="nc" id="L75">                relevantVertices.add(vertex);</span>
            }
<span class="nc" id="L77">        }</span>

        // change to sink and store them
<span class="nc" id="L80">        List&lt;NetworkVertex&gt; sinkVertices = new ArrayList&lt;NetworkVertex&gt;();</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        for (NetworkVertex vertex:relevantVertices) {</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">            if (!vertex.isSink()) {</span>
<span class="nc" id="L83">                vertex.setSink(true);</span>
            } else {
<span class="nc" id="L85">                sinkVertices.add(vertex);</span>
            }
<span class="nc" id="L87">        }</span>

        // add all the relevantVertices to the phase 2 graph
<span class="nc" id="L90">        Graphs.addAllVertices(graph2, relevantVertices);</span>

<span class="nc" id="L92">        List&lt;NetworkVertex&gt; relevantVertices2 = new ArrayList&lt;NetworkVertex&gt;(relevantVertices);</span>
        //  Collections.sort(relevantVertices2);

        // run the iterator for routes for each vertex
<span class="nc bnc" id="L96" title="All 2 branches missed.">        for (NetworkVertex startVertex:relevantVertices2) {</span>
<span class="nc" id="L97">            startVertex.setSink(false); // deactivate sink for that vertex</span>
            // define iterator to find all routes from here
<span class="nc" id="L99">            NetworkIterator iterator = new NetworkIterator(graph, startVertex).setRouteIterator(true);</span>
<span class="nc" id="L100">            log.info(&quot;Phase 2 Graph: Start routes from {}&quot;, startVertex);</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">            while ( iterator.hasNext() ) {</span>
                // found new route
<span class="nc" id="L103">                NetworkVertex nextVertex = iterator.next();</span>
<span class="nc bnc" id="L104" title="All 4 branches missed.">                if (nextVertex.isSink() &amp;&amp; nextVertex != startVertex) {</span>
<span class="nc" id="L105">                    List&lt;NetworkVertex&gt; route = iterator.getCurrentRoute();</span>
<span class="nc" id="L106">                    log.info(&quot;Phase 2 Graph: Route found to {} with route = {}&quot;, nextVertex, route);</span>
                    // define routeEdge
<span class="nc" id="L108">                    NetworkEdge routeEdge = null;</span>
<span class="nc" id="L109">                    Set&lt;NetworkEdge&gt; partialEdges = new HashSet&lt;NetworkEdge&gt;();</span>
                    // previousVertex
<span class="nc" id="L111">                    NetworkVertex currentVertex = null;</span>
                    // define new edge by going through the route edges
<span class="nc bnc" id="L113" title="All 2 branches missed.">                    for (NetworkVertex routeVertex:route) {</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">                        if (currentVertex != null) {</span>
<span class="nc" id="L115">                            NetworkEdge partialEdge = graph.getEdge(currentVertex, routeVertex);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">                            if (routeEdge == null) {</span>
<span class="nc" id="L117">                                routeEdge = partialEdge;</span>
                            } else {
<span class="nc" id="L119">                                routeEdge = NetworkEdge.mergeEdges(routeEdge, partialEdge).newEdge;</span>
                            }
<span class="nc" id="L121">                            partialEdges.add(partialEdge);</span>
                        }
<span class="nc" id="L123">                        currentVertex = routeVertex;</span>
<span class="nc" id="L124">                    }</span>
                    // define partial2route entries
<span class="nc bnc" id="L126" title="All 2 branches missed.">                    for (NetworkEdge partialEdge:partialEdges) {</span>
<span class="nc" id="L127">                        partial2route.put(partialEdge, routeEdge);</span>
<span class="nc" id="L128">                    }</span>
                    // store route2partial
<span class="nc" id="L130">                    route2partial.putAll(routeEdge, partialEdges);</span>
<span class="nc" id="L131">                    graph2.addEdge(startVertex, currentVertex, routeEdge);</span>
                }
<span class="nc" id="L133">            }</span>
            // remove that vertex from the graph to avoid duplication of the routes
<span class="nc" id="L135">            graph.removeVertex(startVertex);</span>
<span class="nc" id="L136">        }</span>

        // restore sinkVertices
<span class="nc bnc" id="L139" title="All 2 branches missed.">        for (NetworkVertex vertex:sinkVertices) {</span>
<span class="nc" id="L140">            vertex.setSink(true);</span>
<span class="nc" id="L141">        }</span>

<span class="nc" id="L143">        log.debug(&quot;Defined graph phase 2 = {}&quot;, graph2);</span>

        // TODO: Check if this has no effect as it only logs?
<span class="nc" id="L146">        List&lt;NetworkEdge&gt; edges = new ArrayList&lt;NetworkEdge&gt;(graph2.edgeSet());</span>
<span class="nc" id="L147">        Collections.sort(edges);</span>
<span class="nc" id="L148">        StringBuilder s = new StringBuilder();</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        for (NetworkEdge e:edges) {</span>
<span class="nc" id="L150">            s.append(&quot;\n&quot;).append(e.getOrderedConnection());</span>
<span class="nc" id="L151">        }</span>
<span class="nc" id="L152">        log.debug(&quot;Edges = {}&quot;, s.toString());</span>
<span class="nc" id="L153">    }</span>

    public Map&lt;NetworkEdge, EdgeTravel&gt; getPhaseTwoEdgeSets(RevenueAdapter adapter) {

<span class="nc" id="L157">        Map&lt;NetworkEdge, EdgeTravel&gt; edgeSets = new HashMap&lt;NetworkEdge, EdgeTravel&gt;();</span>
        // convert route2partial and partial2route into edgesets
<span class="nc bnc" id="L159" title="All 2 branches missed.">        for (NetworkEdge route:route2partial.keySet()){</span>
<span class="nc" id="L160">            EdgeTravel edgeTrav = new EdgeTravel();</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            for (NetworkEdge partial:route2partial.get(route)) {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                if (partial2route.get(partial).size() &gt;= 2) { // only keep true sets</span>
<span class="nc" id="L163">                    edgeTrav.set.addAll(partial2route.get(partial));</span>
                }
<span class="nc" id="L165">            }</span>
<span class="nc" id="L166">            edgeTrav.set.remove(route);</span>
<span class="nc" id="L167">            route.setRouteCosts(edgeTrav.set.size());</span>
            //    route.setRouteCosts(-(route.getSource().getValue() + route.getTarget().getValue()));
            // define route costs as the size of the travel set
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (edgeTrav.set.size() != 0) {</span>
<span class="nc" id="L171">                edgeSets.put(route, edgeTrav);</span>
            }
<span class="nc" id="L173">        }</span>



<span class="nc" id="L177">        return edgeSets;</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>