<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GUIHex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.ui.swing.hexmap</a> &gt; <span class="el_source">GUIHex.java</span></div><h1>GUIHex.java</h1><pre class="source lang-java linenums">package net.sf.rails.ui.swing.hexmap;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import rails.game.action.LayBaseToken;
import rails.game.action.LayBonusToken;
import net.sf.rails.algorithms.RevenueBonusTemplate;
import net.sf.rails.game.BaseToken;
import net.sf.rails.game.BonusToken;
import net.sf.rails.game.HexSide;
import net.sf.rails.game.MapHex;
import net.sf.rails.game.MapOrientation;
import net.sf.rails.game.PrivateCompany;
import net.sf.rails.game.PublicCompany;
import net.sf.rails.game.Station;
import net.sf.rails.game.Stop;
import net.sf.rails.game.Tile;
import net.sf.rails.game.financial.Bank;
import net.sf.rails.game.state.Observable;
import net.sf.rails.game.state.Observer;
import net.sf.rails.ui.swing.GUIGlobals;
import net.sf.rails.ui.swing.GUIToken;

import com.google.common.collect.Lists;


/**
 * Base class that holds common components for GUIHexes of all orientations.
 */

public class GUIHex implements Observer {

    /**
     * Static class that describes x-y coordinates for GUIHexes
     */
    public static class HexPoint {
        private final Point2D point;

<span class="nc" id="L54">        public HexPoint(double x, double y) {</span>
<span class="nc" id="L55">            this.point = new Point2D.Double(x, y);</span>
<span class="nc" id="L56">        }</span>

<span class="nc" id="L58">        public HexPoint(Point2D point) {</span>
<span class="nc" id="L59">           this.point = point;</span>
<span class="nc" id="L60">        }</span>

        public Point2D get2D() {
<span class="nc" id="L63">            return point;</span>
        }

        public double getX() {
<span class="nc" id="L67">            return point.getX();</span>
        }

        public double getY() {
<span class="nc" id="L71">            return point.getY();</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L76">            return point.toString();</span>
        }

        public HexPoint rotate(double radians) {
<span class="nc bnc" id="L80" title="All 2 branches missed.">            if (radians == 0) return this;</span>
<span class="nc" id="L81">            double x = getX() * Math.cos(radians) + getY() * Math.sin(radians);</span>
<span class="nc" id="L82">            double y = getY() * Math.cos(radians) - getX() * Math.sin(radians);</span>
<span class="nc" id="L83">            return new HexPoint(x, y);</span>
        }

        public HexPoint translate(double x, double y) {
<span class="nc bnc" id="L87" title="All 4 branches missed.">            if (x == 0 &amp;&amp; y == 0) return this;</span>
<span class="nc" id="L88">            return new HexPoint(this.getX() + x, this.getY() + y);</span>
        }

        public static HexPoint middle(HexPoint a, HexPoint b) {
<span class="nc" id="L92">            return new HexPoint((a.getX() + b.getX()) / 2.0, (a.getY() + b.getY()) / 2.0);</span>
        }

        public static HexPoint add(HexPoint a, HexPoint b) {
<span class="nc" id="L96">            return new HexPoint(a.getX() + b.getX(), a.getY() + b.getY());</span>
        }

        public static HexPoint difference(HexPoint a, HexPoint b) {
<span class="nc" id="L100">            return new HexPoint(a.getX() - b.getX(), a.getY()- b.getY());</span>
        }

    }

<span class="nc" id="L105">    public static enum State {</span>

<span class="nc" id="L107">        NORMAL(1.0, Color.black), SELECTABLE(0.9, Color.red), SELECTED(0.8, Color.red), INVALIDS (0.9, Color.pink);</span>

        private final double scale;
        private final Color color;

<span class="nc" id="L112">        private State(double scale, Color color) {</span>
<span class="nc" id="L113">            this.scale = scale;</span>
<span class="nc" id="L114">            this.color = color;</span>
<span class="nc" id="L115">        }</span>

        private double getScale() {
<span class="nc" id="L118">            return scale;</span>
        }

        private Color getColor() {
<span class="nc" id="L122">            return color;</span>
        }

        private double getHexDrawScale() {
<span class="nc" id="L126">            return 1 - (1 - scale) / 2;</span>
        }

        private GeneralPath getInnerHexagon(GeneralPath hexagon, HexPoint center) {
            //inner hexagons are drawn outlined (not filled)
            //for this draw, the stroke width is half the scale reduction
            //the scale factor is multiplied by the average of hex width / height in order
            //to get a good estimate for which for stroke width the hex borders are touched
            //by the stroke

<span class="nc" id="L136">            AffineTransform at =</span>
<span class="nc" id="L137">                    AffineTransform.getScaleInstance(getHexDrawScale(), getHexDrawScale());</span>
<span class="nc" id="L138">            GeneralPath innerHexagon = (GeneralPath) hexagon.createTransformedShape(at);</span>

            // Translate innerHexagon to make it concentric.
<span class="nc" id="L141">            Rectangle2D innerBounds = innerHexagon.getBounds2D();</span>
<span class="nc" id="L142">            HexPoint innerCenter = new HexPoint(</span>
<span class="nc" id="L143">                    innerBounds.getX() + innerBounds.getWidth() / 2.0,</span>
<span class="nc" id="L144">                    innerBounds.getY() + innerBounds.getHeight() / 2.0</span>
            );
<span class="nc" id="L146">            HexPoint difference = HexPoint.difference(center, innerCenter);</span>

<span class="nc" id="L148">            at = AffineTransform.getTranslateInstance(difference.getX(), difference.getY());</span>
<span class="nc" id="L149">            innerHexagon.transform(at);</span>

<span class="nc" id="L151">            return innerHexagon;</span>
        }


        private double getStrokeWidth(GeneralPath hexagon) {
<span class="nc" id="L156">            return ( 1 - getHexDrawScale() ) *</span>
<span class="nc" id="L157">                    ( hexagon.getBounds().width + hexagon.getBounds().height ) / 2;</span>
        }
    }

    /**
     * Static class for GUIHex Dimensions
     */
    private static class Dimensions {
        private final double zoomFactor;
        private final double tokenDiameter;

        private final Map&lt;HexSide, HexPoint&gt; points;
        private final HexPoint center;

        private final GeneralPath hexagon;

        private final Rectangle rectBound;
        // The area which would have to be repainted if any hex marking is changed
        private final Rectangle marksDirtyRectBound;

<span class="nc" id="L177">        private Dimensions(HexMap hexMap, MapHex hex, double scale, double zoomFactor) {</span>
<span class="nc" id="L178">            this.zoomFactor = zoomFactor;</span>

<span class="nc" id="L180">            double cx = hexMap.calcXCoordinates(hex.getCoordinates().getCol(), hexMap.tileXOffset);</span>
<span class="nc" id="L181">            double cy = hexMap.calcYCoordinates(hex.getCoordinates().getRow(), hexMap.tileYOffset);</span>
<span class="nc" id="L182">            points = hexMap.getMapManager().getMapOrientation().setGUIVertices(cx, cy, scale);</span>

<span class="nc" id="L184">            tokenDiameter = NORMAL_TOKEN_SIZE * zoomFactor;</span>

<span class="nc" id="L186">            hexagon = makePolygon();</span>

<span class="nc" id="L188">            center = HexPoint.middle(points.get(HexSide.defaultRotation()),</span>
<span class="nc" id="L189">                    points.get(HexSide.defaultRotation().opposite()));</span>

<span class="nc" id="L191">            rectBound = hexagon.getBounds();</span>
<span class="nc" id="L192">            marksDirtyRectBound = new Rectangle (</span>
                    rectBound.x - MARKS_DIRTY_MARGIN,
                    rectBound.y - MARKS_DIRTY_MARGIN,
                    rectBound.width + MARKS_DIRTY_MARGIN * 2,
                    rectBound.height + MARKS_DIRTY_MARGIN * 2
            );
<span class="nc" id="L198">        }</span>

        // Replace with Path2D
        private GeneralPath makePolygon() {
<span class="nc" id="L202">            GeneralPath polygon = new GeneralPath(GeneralPath.WIND_EVEN_ODD, 6);</span>

<span class="nc" id="L204">            HexPoint start = points.get(HexSide.defaultRotation());</span>
<span class="nc" id="L205">            polygon.moveTo((float) start.getX(), (float) start.getY());</span>

<span class="nc bnc" id="L207" title="All 2 branches missed.">            for (HexSide side:HexSide.allExceptDefault()) {</span>
<span class="nc" id="L208">                HexPoint point = points.get(side);</span>
<span class="nc" id="L209">                polygon.lineTo((float) point.getX(), (float) point.getY());</span>
<span class="nc" id="L210">            }</span>
<span class="nc" id="L211">            polygon.closePath();</span>
<span class="nc" id="L212">            return polygon;</span>
        }


    }

    // STATIC CONSTANTS
    private static final int NORMAL_TOKEN_SIZE = 15;
    private static final double TILE_GRID_SCALE = 14.0;
    private static final double CITY_SIZE = 16.0;

<span class="nc" id="L223">    private static final Color BAR_COLOUR = Color.BLUE;</span>
    private static final int BAR_WIDTH = 5;

<span class="nc" id="L226">    private static final Color highlightedFillColor = new Color(255,255,255,128);</span>
<span class="nc" id="L227">    private static final Color highlightedBorderColor = Color.BLACK;</span>
<span class="nc" id="L228">    private static final Stroke highlightedBorderStroke = new BasicStroke(3);</span>


    // Defines by how much the hex bounds have to be increased in each direction
    // for obtaining the dirty rectangle (markings could got beyond hex limits)
    private static final int MARKS_DIRTY_MARGIN = 4;

    // positions of offStation Tokens
<span class="nc" id="L236">    private static final int[] offStationTokenX = new int[] { -11, 0 };</span>
<span class="nc" id="L237">    private static final int[] offStationTokenY = new int[] { -19, 0 };</span>

    // static fields
    private final HexMap hexMap;
    private final MapHex hex;

    // dynamic fields
    private Dimensions dimensions;

    private State state;

    private HexUpgrade upgrade;

    private List&lt;HexSide&gt; barSides;

    // A counter instead of a boolean is used here in order to be able to correctly
    // handle racing conditions for mouse events.
<span class="nc" id="L254">    private int highlightCounter = 0;</span>

<span class="nc" id="L256">    public GUIHex(HexMap hexMap, MapHex hex, double scale) {</span>
<span class="nc" id="L257">        this.hexMap = hexMap;</span>
<span class="nc" id="L258">        this.hex = hex;</span>
<span class="nc" id="L259">        hex.addObserver(this);</span>
<span class="nc" id="L260">        this.setDimensions(scale, 1.0);</span>
<span class="nc" id="L261">        this.state = State.NORMAL;</span>
<span class="nc" id="L262">    }</span>

    public void setDimensions(double scale, double zoomFactor) {
<span class="nc" id="L265">        dimensions = new Dimensions(hexMap, hex, scale, zoomFactor);</span>
<span class="nc" id="L266">    }</span>

    // TODO: rename to getModel()
    public MapHex getHex() {
<span class="nc" id="L270">        return this.hex;</span>
    }

    public HexMap getHexMap() {
<span class="nc" id="L274">        return hexMap;</span>
    }

    public Point2D getStopPoint2D(Stop stop){
<span class="nc" id="L278">        return getTokenCenter(0, stop).get2D();</span>
    }

    public Point2D getSidePoint2D(HexSide side){
<span class="nc" id="L282">        HexPoint middle = HexPoint.middle(dimensions.points.get(side),</span>
<span class="nc" id="L283">                dimensions.points.get(side.next()));</span>
<span class="nc" id="L284">        return middle.get2D();</span>
    }

    public Point2D getCenterPoint2D() {
<span class="nc" id="L288">        return dimensions.center.get2D();</span>
    }


    // TODO: Make this based on MapHex model
    public void addBar(HexSide side) {
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (barSides == null) {</span>
<span class="nc" id="L295">            barSides = Lists.newArrayListWithCapacity(2);</span>
        }
<span class="nc" id="L297">        barSides.add(side);</span>
<span class="nc" id="L298">    }</span>

    public Rectangle getBounds() {
<span class="nc" id="L301">        return dimensions.rectBound;</span>
    }

    public Rectangle getMarksDirtyBounds() {
<span class="nc" id="L305">        return dimensions.marksDirtyRectBound;</span>
    }

    public boolean contains(Point2D.Double point) {
<span class="nc" id="L309">        return (dimensions.hexagon.contains(point));</span>
    }

    public boolean contains(Point point) {
<span class="nc" id="L313">        return (dimensions.hexagon.contains(point));</span>
    }

    public boolean intersects(Rectangle2D r) {
<span class="nc" id="L317">        return (dimensions.hexagon.intersects(r));</span>
    }

    public void setState(State state) {
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (this.state != state) {</span>
            //trigger hexmap marks repaint if status changes
<span class="nc" id="L323">            hexMap.repaintMarks(getMarksDirtyBounds());</span>
<span class="nc" id="L324">            hexMap.repaintTiles(getBounds()); // tile is drawn smaller if selected</span>
        }
<span class="nc" id="L326">        this.state = state;</span>
<span class="nc" id="L327">    }</span>

    public State getState() {
<span class="nc" id="L330">        return state;</span>
    }

    /**
     * Indicate that this hex should be highlighted
     */
    public void addHighlightRequest() {
        //trigger hexmap marks repaint if hex becomes highlighted
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (highlightCounter == 0) hexMap.repaintMarks(getMarksDirtyBounds());</span>

<span class="nc" id="L340">        highlightCounter++;</span>
<span class="nc" id="L341">    }</span>

    /**
     * Indicate that this hex does not need to be highlighted any more (from the
     * caller's point of view).
     * Note that the hex could still remain highlighted if another entity has requested
     * highlighting.
     */
    public void removeHighlightRequest() {
<span class="nc" id="L350">        highlightCounter--;</span>
        //trigger hexmap marks repaint if hex becomes not highlighted
<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (highlightCounter == 0) hexMap.repaintMarks(getMarksDirtyBounds());</span>
<span class="nc" id="L353">    }</span>

    public boolean isHighlighted() {
<span class="nc bnc" id="L356" title="All 2 branches missed.">        return (highlightCounter &gt; 0);</span>
    }

    public void setUpgrade(HexUpgrade upgrade) {
<span class="nc" id="L360">        this.upgrade = upgrade;</span>
<span class="nc" id="L361">        hexMap.repaintTiles(getBounds());</span>
<span class="nc" id="L362">        hexMap.repaintTokens(getBounds()); // needed if new tile has new token placement spot</span>
<span class="nc" id="L363">    }</span>

    public HexUpgrade getUpgrade() {
<span class="nc" id="L366">        return upgrade;</span>
    }

    /**
     * @return the current tile shown on the map (if an upgrade is shown the upgrade target tile is returned)
     */
    private Tile getVisibleTile() {
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (upgrade instanceof TileHexUpgrade) {</span>
<span class="nc" id="L374">            return ((TileHexUpgrade)upgrade).getUpgrade().getTargetTile();</span>
        } else {
<span class="nc" id="L376">            return hex.getCurrentTile();</span>
        }
    }

    /**
     * @return the current tile rotation (if an upgrade is shown the rotation of that tile is returned)
     */
    private HexSide getVisibleRotation() {
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (upgrade instanceof TileHexUpgrade) {</span>
<span class="nc" id="L385">            return ((TileHexUpgrade)upgrade).getCurrentRotation();</span>
        } else {
<span class="nc" id="L387">            return hex.getCurrentTileRotation();</span>
        }
    }

    private boolean isTilePainted() {
<span class="nc" id="L392">        Tile visibleTile = getVisibleTile();</span>
<span class="nc bnc" id="L393" title="All 4 branches missed.">        return visibleTile != null &amp;&amp; hexMap.isTilePainted(visibleTile);</span>
    }

    public void paintTile(Graphics2D g) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (isTilePainted()) {</span>
<span class="nc" id="L398">            GUIGlobals.setRenderingHints(g);</span>
<span class="nc" id="L399">            paintOverlay(g);</span>
        }
<span class="nc" id="L401">    }</span>

    /**
     * Marks are selected / selectable / highlighted
     * @param g
     */
    public void paintMarks(Graphics2D g) {
<span class="nc" id="L408">        GUIGlobals.setRenderingHints(g);</span>

<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (state != State.NORMAL) {</span>
<span class="nc" id="L411">            Stroke oldStroke = g.getStroke();</span>
<span class="nc" id="L412">            g.setStroke(new BasicStroke((float) state.getStrokeWidth(dimensions.hexagon)));</span>
<span class="nc" id="L413">            g.setColor(state.getColor());</span>
<span class="nc" id="L414">            g.draw(state.getInnerHexagon(dimensions.hexagon, dimensions.center));</span>
<span class="nc" id="L415">            g.setStroke(oldStroke);</span>
        }

        //highlight on top of tiles
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (isHighlighted()) {</span>
<span class="nc" id="L420">            g.setColor(highlightedFillColor);</span>
<span class="nc" id="L421">            g.fill(dimensions.hexagon);</span>
<span class="nc" id="L422">            Stroke oldStroke = g.getStroke();</span>
<span class="nc" id="L423">            g.setStroke(highlightedBorderStroke);</span>
<span class="nc" id="L424">            g.setColor(highlightedBorderColor);</span>
<span class="nc" id="L425">            g.draw(dimensions.hexagon);</span>
<span class="nc" id="L426">            g.setStroke(oldStroke);</span>
        }

<span class="nc" id="L429">    }</span>

    public void paintTokensAndText(Graphics2D g) {

<span class="nc" id="L433">        GUIGlobals.setRenderingHints(g);</span>

<span class="nc" id="L435">        paintStationTokens(g);</span>
<span class="nc" id="L436">        paintOffStationTokens(g);</span>

<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (!isTilePainted()) return;</span>

<span class="nc" id="L440">        FontMetrics fontMetrics = g.getFontMetrics();</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">        if (getHex().getTileCost() &gt; 0 ) {</span>
<span class="nc" id="L442">            g.drawString(</span>
<span class="nc" id="L443">                    Bank.format(getHex(), getHex().getTileCost()),</span>
                    dimensions.rectBound.x
<span class="nc" id="L445">                            + (dimensions.rectBound.width - fontMetrics.stringWidth(Integer.toString(getHex().getTileCost())))</span>
                            * 3 / 5,
                    dimensions.rectBound.y
<span class="nc" id="L448">                            + ((fontMetrics.getHeight() + dimensions.rectBound.height) * 9 / 15));</span>
        }

<span class="nc" id="L451">        Map&lt;PublicCompany, Stop&gt; homes = getHex().getHomes();</span>

<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (homes  != null) {</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">            for (PublicCompany company : homes.keySet()) {</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">                if (company.isClosed()) continue;</span>

                // Only draw the company name if there isn't yet a token of that company
<span class="nc bnc" id="L458" title="All 2 branches missed.">                if (hex.hasTokenOfCompany(company)) continue;</span>
                // Do not draw if hex is never blocked for token lays
<span class="nc bnc" id="L460" title="All 2 branches missed.">                if (hex.getBlockedForTokenLays() == MapHex.BlockedToken.NEVER) continue;</span>

<span class="nc" id="L462">                Stop homeCity = homes.get(company);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                if (homeCity.getRelatedStation() == null) { // not yet decided where the token will be</span>
                    // find a free slot
<span class="nc" id="L465">                    Set&lt;Stop&gt; stops = getHex().getStops();</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                    for (Stop stop:stops) {</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                        if (stop.hasTokenSlotsLeft()) {</span>
<span class="nc" id="L468">                            homeCity = stop;</span>
<span class="nc" id="L469">                            break;</span>
                        }
<span class="nc" id="L471">                    }</span>
                }
                // check the number of tokens laid there already
<span class="nc" id="L474">                HexPoint p = getTokenCenter (1, homeCity);</span>
<span class="nc" id="L475">                drawHome(g, company, p);</span>
<span class="nc" id="L476">            }</span>
        }

<span class="nc bnc" id="L479" title="All 2 branches missed.">        if (hex.isBlockedByPrivateCompany()) {</span>
<span class="nc" id="L480">           PrivateCompany p = hex.getBlockingPrivateCompany();</span>
<span class="nc" id="L481">           String text = &quot;(&quot; + p.getId() + &quot;)&quot;;</span>
<span class="nc" id="L482">           g.drawString(</span>
                   text,
                   dimensions.rectBound.x
<span class="nc" id="L485">                   + (dimensions.rectBound.width - fontMetrics.stringWidth(text))</span>
                   * 1 / 2,
                   dimensions.rectBound.y
<span class="nc" id="L488">                   + ((fontMetrics.getHeight() + dimensions.rectBound.height) * 5 / 15));</span>
        }

<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (hex.isReservedForCompany()</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        		&amp;&amp; hex.isPreprintedTileCurrent()) {</span>
<span class="nc" id="L493">        	String text = &quot;[&quot; + hex.getReservedForCompany().getId() + &quot;]&quot;;</span>
<span class="nc" id="L494">            g.drawString(</span>
                  text,
                  dimensions.rectBound.x
<span class="nc" id="L497">                  + (dimensions.rectBound.width - fontMetrics.stringWidth(text))</span>
                  * 1 / 2,
                  dimensions.rectBound.y
<span class="nc" id="L500">                  + ((fontMetrics.getHeight() + dimensions.rectBound.height) * 5 / 25));</span>
        }

<span class="nc" id="L503">    }</span>

    private void paintOverlay(Graphics2D g2) {
<span class="nc" id="L506">        Tile visibleTile = this.getVisibleTile();</span>
<span class="nc" id="L507">        HexSide visibleRotation = this.getVisibleRotation();</span>

<span class="nc" id="L509">        GUITile.paintTile(g2, dimensions.center, this, visibleTile, visibleRotation,</span>
<span class="nc" id="L510">                state.getScale(), hexMap.getZoomStep());</span>
<span class="nc" id="L511">    }</span>

    public void paintBars(Graphics2D g) {
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (barSides == null) return;</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">        for (HexSide startPoint : barSides) {</span>
<span class="nc" id="L516">            drawBar(g, dimensions.points.get(startPoint), dimensions.points.get(startPoint.next()));</span>
<span class="nc" id="L517">        }</span>
<span class="nc" id="L518">    }</span>

    protected void drawBar(Graphics2D g2d, HexPoint start, HexPoint end) {
<span class="nc" id="L521">        Color oldColor = g2d.getColor();</span>
<span class="nc" id="L522">        Stroke oldStroke = g2d.getStroke();</span>

<span class="nc" id="L524">        g2d.setColor(BAR_COLOUR);</span>
<span class="nc" id="L525">        g2d.setStroke(new BasicStroke(BAR_WIDTH));</span>
<span class="nc" id="L526">        g2d.draw(new Line2D.Double(start.get2D(),end.get2D()));</span>

<span class="nc" id="L528">        g2d.setColor(oldColor);</span>
<span class="nc" id="L529">        g2d.setStroke(oldStroke);</span>
<span class="nc" id="L530">    }</span>

    private void paintStationTokens(Graphics2D g2) {
<span class="nc bnc" id="L533" title="All 2 branches missed.">        for (Stop stop:getHex().getStops()) {</span>
<span class="nc" id="L534">            int j = 0;</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">            for (BaseToken token:stop.getBaseTokens()) {</span>
<span class="nc" id="L536">                HexPoint origin = getTokenCenter(j++, stop);</span>
<span class="nc" id="L537">                PublicCompany company = token.getParent();</span>
<span class="nc" id="L538">                drawBaseToken(g2, company, origin, dimensions.tokenDiameter);</span>
<span class="nc" id="L539">            }</span>
            // check for temporary token
<span class="nc bnc" id="L541" title="All 4 branches missed.">            if (upgrade instanceof TokenHexUpgrade &amp;&amp; ((TokenHexUpgrade) upgrade).getAction() instanceof LayBaseToken) {</span>
<span class="nc" id="L542">                TokenHexUpgrade tokenUpgrade = (TokenHexUpgrade) upgrade;</span>
<span class="nc" id="L543">                HexPoint origin = getTokenCenter(j++, tokenUpgrade.getSelectedStop());</span>
<span class="nc" id="L544">                PublicCompany company = tokenUpgrade.getAction().getCompany();</span>
<span class="nc" id="L545">                drawBaseToken(g2, company, origin, dimensions.tokenDiameter);</span>
            }
<span class="nc" id="L547">        }</span>
<span class="nc" id="L548">    }</span>

    // FIXME: Where to paint more than one offStationTokens?
    private void paintOffStationTokens(Graphics2D g2) {
<span class="nc" id="L552">        int i = 0;</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        for (BonusToken token : hex.getBonusTokens())  {</span>
<span class="nc" id="L554">            HexPoint origin = dimensions.center.translate(offStationTokenX[i], offStationTokenY[i]);</span>
<span class="nc" id="L555">            drawBonusToken(g2, token, origin);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">            if (++i &gt; 1) return;</span>

<span class="nc" id="L558">        }</span>
        // check for temporary token
<span class="nc bnc" id="L560" title="All 4 branches missed.">        if (upgrade instanceof TokenHexUpgrade &amp;&amp; ((TokenHexUpgrade) upgrade).getAction() instanceof LayBonusToken) {</span>
<span class="nc" id="L561">            HexPoint origin = dimensions.center.translate(offStationTokenX[i], offStationTokenY[i]);</span>
<span class="nc" id="L562">            BonusToken token = ((LayBonusToken)((TokenHexUpgrade) upgrade).getAction()).getToken();</span>
<span class="nc" id="L563">            drawBonusToken(g2, token, origin);</span>
        }
<span class="nc" id="L565">    }</span>

    private void drawBaseToken(Graphics2D g2, PublicCompany co, HexPoint center, double diameter) {

<span class="nc" id="L569">        GUIToken token = new GUIToken(</span>
<span class="nc" id="L570">                co.getFgColour(), co.getBgColour(), co.getId(), center, diameter);</span>
        // token.setBounds((int)Math.round(dimensions.center.getX()-0.5*diameter), (int) Math.round(dimensions.center.getY()-0.5*diameter),
        //        diameter, diameter);

<span class="nc" id="L574">        token.drawToken(g2);</span>

<span class="nc" id="L576">    }</span>

    private void drawHome (Graphics2D g2, PublicCompany co, HexPoint origin) {

<span class="nc" id="L580">        GUIToken.drawTokenText(co.getId(), g2, Color.BLACK, origin, dimensions.tokenDiameter);</span>
<span class="nc" id="L581">    }</span>

    private void drawBonusToken(Graphics2D g2, BonusToken bt, HexPoint origin) {
<span class="nc" id="L584">        GUIToken token =</span>
<span class="nc" id="L585">                new GUIToken(Color.BLACK, Color.WHITE, &quot;+&quot; + bt.getValue(),</span>
                        origin, 15);
<span class="nc" id="L587">        token.drawToken(g2);</span>
<span class="nc" id="L588">    }</span>

    private HexPoint getTokenCenter(int currentToken, Stop stop) {
        // Find the correct position on the tile
<span class="nc" id="L592">        int positionCode = stop.getRelatedStation().getPosition();</span>

        HexPoint tokenCenter;
<span class="nc bnc" id="L595" title="All 2 branches missed.">        if (positionCode != 0) {</span>
            // FIXME: Check if we need both x and y
            // or only y as in Rails1.x
<span class="nc" id="L598">            double initial = TILE_GRID_SCALE * dimensions.zoomFactor;</span>
<span class="nc" id="L599">            double r = MapOrientation.DEG30 * (positionCode / 50);</span>
<span class="nc" id="L600">            tokenCenter = new HexPoint(0, initial).rotate(r);</span>
<span class="nc" id="L601">        } else {</span>
<span class="nc" id="L602">            tokenCenter = new HexPoint(0.0, 0.0);</span>
        }

        // Correct for the number of base slots and the token number
<span class="nc" id="L606">        double delta_x = 0, delta_y = 0;</span>
<span class="nc bnc" id="L607" title="All 5 branches missed.">        switch (stop.getSlots()) {</span>
        case 2:
<span class="nc" id="L609">            delta_x = (-0.5 + currentToken) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L610">            break;</span>
        case 3:
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (currentToken &lt; 2) {</span>
<span class="nc" id="L613">                delta_x = (-0.5 + currentToken) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L614">                delta_y = -3 + 0.25 * MapOrientation.SQRT3 * CITY_SIZE * dimensions.zoomFactor;</span>
            } else {
<span class="nc" id="L616">               delta_y = -(3 + 0.5 * CITY_SIZE * dimensions.zoomFactor);</span>
            }
<span class="nc" id="L618">            break;</span>
        case 4:
<span class="nc" id="L620">            delta_x = (-0.5 + currentToken % 2) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L621">            delta_y = (0.5 - currentToken / 2) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L622">            break;</span>
        case 6:
<span class="nc bnc" id="L624" title="All 7 branches missed.">            switch (currentToken)  {</span>
            case 0:
<span class="nc" id="L626">                delta_x += (-1) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L627">                delta_y += (-0.5) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L628">                break;</span>
            case 1:
<span class="nc" id="L630">                delta_x += (-1) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L631">                delta_y += (0.5) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L632">                break;</span>
            case 2:
<span class="nc" id="L634">                delta_y += (1) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L635">                break;</span>
            case 3:
<span class="nc" id="L637">                delta_x += (1) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L638">                delta_y += (0.5) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L639">                break;</span>
            case 4:
<span class="nc" id="L641">                delta_x += (1) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L642">                delta_y += (-0.5) * CITY_SIZE * dimensions.zoomFactor;</span>
<span class="nc" id="L643">                break;</span>
            case 5:
<span class="nc" id="L645">                delta_y += (-1) * CITY_SIZE * dimensions.zoomFactor;</span>
                break;
            }

        }
<span class="nc" id="L650">        tokenCenter = tokenCenter.translate(delta_x, delta_y);</span>

        // Correct for the tile base and actual rotations
<span class="nc" id="L653">        HexSide rotation = hex.getCurrentTileRotation();</span>

<span class="nc" id="L655">        double radians = MapOrientation.rotationInRadians(hex, rotation);</span>
<span class="nc" id="L656">        tokenCenter = tokenCenter.rotate(radians);</span>

<span class="nc" id="L658">        tokenCenter = dimensions.center.translate(tokenCenter.getX(), - tokenCenter.getY());</span>
<span class="nc" id="L659">        return tokenCenter;</span>
    }

    public String getToolTip() {
<span class="nc bnc" id="L663" title="All 2 branches missed.">        if (upgrade != null)</span>
<span class="nc" id="L664">            return upgrade.getUpgradeToolTip();</span>
        else
<span class="nc" id="L666">            return getDefaultToolTip();</span>
    }

    private String bonusToolTipText(List&lt;RevenueBonusTemplate&gt; bonuses) {
<span class="nc" id="L670">        StringBuilder tt = new StringBuilder();</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">        if (bonuses != null) {</span>
<span class="nc" id="L672">            Set&lt;String&gt; bonusNames = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">            for (RevenueBonusTemplate bonus:bonuses) {</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                if (bonus.getName() == null) {</span>
<span class="nc" id="L675">                    tt.append(&quot;&lt;br&gt;Bonus:&quot;);</span>
<span class="nc" id="L676">                    tt.append(bonus.getToolTip());</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">                } else if (!bonusNames.contains(bonus.getName())) {</span>
<span class="nc" id="L678">                    tt.append(&quot;&lt;br&gt;Bonus:&quot;).append(bonus.getName());</span>
<span class="nc" id="L679">                    bonusNames.add(bonus.getName());</span>
                }
<span class="nc" id="L681">            }</span>
        }
<span class="nc" id="L683">        return tt.toString();</span>
    }

    private String getDefaultToolTip() {
<span class="nc" id="L687">        Tile currentTile = hex.getCurrentTile();</span>

<span class="nc" id="L689">        StringBuilder tt = new StringBuilder(&quot;&lt;html&gt;&quot;);</span>
<span class="nc" id="L690">        tt.append(&quot;&lt;b&gt;Hex&lt;/b&gt;: &quot;).append(hex.toText());</span>
        // For debugging: display x,y-coordinates
        //tt.append(&quot;&lt;small&gt; x=&quot; + x + &quot; y=&quot;+y+&quot;&lt;/small&gt;&quot;);

<span class="nc" id="L694">        tt.append(&quot;&lt;br&gt;&lt;b&gt;Tile&lt;/b&gt;: &quot;).append(currentTile.toText());</span>

        // For debugging: display rotation
        //tt.append(&quot;&lt;small&gt; rot=&quot; + currentTileOrientation + &quot;&lt;/small&gt;&quot;);

<span class="nc bnc" id="L699" title="All 2 branches missed.">        if (hex.hasValuesPerPhase()) {</span>
<span class="nc" id="L700">            tt.append(&quot;&lt;br&gt;Value &quot;);</span>
<span class="nc" id="L701">            tt.append(hex.getCurrentValueForPhase(hexMap.getPhase())).append(&quot; [&quot;);</span>
<span class="nc" id="L702">            List&lt;Integer&gt; values = hex.getValuesPerPhase();</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">            for (int i = 0; i &lt; values.size(); i++) {</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                if (i &gt; 0) tt.append(&quot;,&quot;);</span>
<span class="nc" id="L705">                tt.append(values.get(i));</span>
            }
<span class="nc" id="L707">            tt.append(&quot;]&quot;);</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">        } else if (currentTile.hasStations()) {</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">            for (Stop stop : hex.getStops()) {</span>
<span class="nc" id="L710">                Station station = stop.getRelatedStation();</span>
<span class="nc" id="L711">                tt.append(&quot;&lt;br&gt;  &quot;).append(station.toText())</span>
<span class="nc" id="L712">                    .append(&quot; (&quot;).append(hex.getConnectionString(station))</span>
<span class="nc" id="L713">                    .append(&quot;): value &quot;);</span>
<span class="nc" id="L714">                tt.append(station.getValue());</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                if (station.getBaseSlots() &gt; 0) {</span>
<span class="nc" id="L716">                    tt.append(&quot;, &quot;).append(station.getBaseSlots()).append(&quot; slots&quot;);</span>
<span class="nc" id="L717">                    Set&lt;BaseToken&gt; tokens = stop.getBaseTokens();</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">                    if (tokens.size() &gt; 0) {</span>
<span class="nc" id="L719">                        tt.append(&quot; (&quot;);</span>
<span class="nc" id="L720">                        int oldsize = tt.length();</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                        for (BaseToken token : tokens) {</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">                            if (tt.length() &gt; oldsize) tt.append(&quot;,&quot;);</span>
<span class="nc" id="L723">                            tt.append(token.getParent().getId());</span>
<span class="nc" id="L724">                        }</span>
<span class="nc" id="L725">                        tt.append(&quot;)&quot;);</span>
                    }
                }
                // TEMPORARY
<span class="nc" id="L729">                tt.append(&quot; &lt;small&gt;pos=&quot;).append(station.getPosition()).append(&quot;&lt;/small&gt;&quot;);</span>
<span class="nc" id="L730">            }</span>
<span class="nc" id="L731">            tt.append(bonusToolTipText(currentTile.getRevenueBonuses()));</span>
        }

        // revenueBonuses
<span class="nc" id="L735">        tt.append(bonusToolTipText(hex.getRevenueBonuses()));</span>

<span class="nc" id="L737">        String upgrades = currentTile.getUpgradesString(hex);</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if (upgrades.equals(&quot;&quot;)) {</span>
<span class="nc" id="L739">            tt.append(&quot;&lt;br&gt;No upgrades&quot;);</span>
        } else {
<span class="nc" id="L741">            tt.append(&quot;&lt;br&gt;&lt;b&gt;Upgrades&lt;/b&gt;: &quot;).append(upgrades);</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            if (hex.getTileCost() &gt; 0)</span>
<span class="nc" id="L743">                tt.append(&quot;&lt;br&gt;Upgrade cost: &quot;).append(Bank.format(hex, hex.getTileCost()));</span>
        }

<span class="nc bnc" id="L746" title="All 2 branches missed.">        if (getHex().getDestinations() != null) {</span>
<span class="nc" id="L747">            tt.append(&quot;&lt;br&gt;&lt;b&gt;Destination&lt;/b&gt;:&quot;);</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">            for (PublicCompany dest : getHex().getDestinations()) {</span>
<span class="nc" id="L749">                tt.append(&quot; &quot;);</span>
<span class="nc" id="L750">                tt.append(dest.getId());</span>
<span class="nc" id="L751">            }</span>
        }


<span class="nc" id="L755">        tt.append(&quot;&lt;/html&gt;&quot;);</span>
<span class="nc" id="L756">        return tt.toString();</span>
    }

    public void update() {
<span class="nc" id="L760">        hexMap.repaintTiles(getBounds());</span>
<span class="nc" id="L761">        hexMap.repaintTokens(getBounds()); // needed if new tile has new token placement spot</span>
<span class="nc" id="L762">    }</span>

    public String toText() {
<span class="nc" id="L765">        return hex.toText();</span>
    }


    // Observer methods
    @Override
    public void update(String text) {
<span class="nc" id="L772">        update();</span>
<span class="nc" id="L773">    }</span>

    @Override
    public Observable getObservable() {
<span class="nc" id="L777">        return hex;</span>
    }

    // Object methods
    @Override
    public String toString () {
<span class="nc" id="L783">        return toText() + &quot; (&quot; + hex.getCurrentTile().toText() + &quot;)&quot;;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>