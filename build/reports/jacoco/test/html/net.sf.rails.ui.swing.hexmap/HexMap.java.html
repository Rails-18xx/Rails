<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HexMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.ui.swing.hexmap</a> &gt; <span class="el_source">HexMap.java</span></div><h1>HexMap.java</h1><pre class="source lang-java linenums">package net.sf.rails.ui.swing.hexmap;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.GeneralPath;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;

import javax.swing.JComponent;
import javax.swing.JLayeredPane;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;

import net.sf.rails.common.Config;
import net.sf.rails.common.parser.ConfigurationException;
import net.sf.rails.game.HexSide;
import net.sf.rails.game.HexSidesSet;
import net.sf.rails.game.MapHex;
import net.sf.rails.game.MapManager;
import net.sf.rails.game.Phase;
import net.sf.rails.game.Tile;
import net.sf.rails.ui.swing.GameUIManager;
import net.sf.rails.ui.swing.ORUIManager;
import net.sf.rails.util.Util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;


/**
 * Base class that stores common info for HexMap independant of Hex
 * orientations. The hex map manages several layers. Content is seperated in
 * layers in order to ensure good performance in case of only some aspects of
 * the map need to be redrawn.
 *
 * In order to avert race conditions during layer drawing, the critical code is
 * synchronized on the hex map instance as monitor object.
 */
<span class="nc" id="L54">public abstract class HexMap implements MouseListener, MouseMotionListener {</span>

<span class="nc" id="L56">    private static final Logger log = LoggerFactory.getLogger(HexMap.class);</span>

    /**
     * class for managing sets of rectangles. Apart from several convenience
     * methods, this class aims at keeping the set as minimal as possible.
     */
<span class="nc" id="L62">    private static class RectangleSet {</span>
<span class="nc" id="L63">        private List&lt;Rectangle&gt; rs = ImmutableList.of();</span>

        /**
         * @param rOp Rectangle to be added to the set. Only added if not
         * contained in a rectangle of the set. If added, all of the set's
         * rectangles which are a sub-area of this rectangle are dropped (in
         * order to keep the rectangle list as small as possible).
         */
        public void add(Rectangle rOp) {
            // exit if rectangle already contained in set of rectangles
<span class="nc bnc" id="L73" title="All 2 branches missed.">            for (Rectangle r : rs) {</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">                if (r.contains(rOp)) return;</span>
<span class="nc" id="L75">            }</span>

            // build new set (do not include rectangles contained by new
            // rectangle)
<span class="nc" id="L79">            ImmutableList.Builder&lt;Rectangle&gt; newRs = ImmutableList.builder();</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">            for (Rectangle r : rs) {</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">                if (!rOp.contains(r)) newRs.add(r);</span>
<span class="nc" id="L82">            }</span>
<span class="nc" id="L83">            newRs.add(rOp);</span>
<span class="nc" id="L84">            rs = newRs.build();</span>
<span class="nc" id="L85">        }</span>

        /**
         * As a side-effect, the area defined by the given rectangle is removed
         * from the area defined by the set of rectangles. This might lead to
         * splitting the set's rectangles if only parts of their areas become
         * removed.
         *
         * @return The intersection between the given rectangle and the set of
         * rectangles. Returns null if the intersection is empty.
         */
        public Rectangle getIntersectionAndRemoveFromSet(Rectangle rOp) {
<span class="nc" id="L97">            Rectangle intersection = null;</span>
<span class="nc" id="L98">            RectangleSet newRs = new RectangleSet();</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">            for (Rectangle r : rs) {</span>
<span class="nc" id="L100">                Rectangle intersectionPart = null;</span>

                // check for the most common case: set's rectangle is a sub-area
                // of the given rectangle (common because repaint creates
                // unions)
                // avoid further (complex) processing for this case
<span class="nc bnc" id="L106" title="All 2 branches missed.">                if (rOp.contains(r)) {</span>
<span class="nc" id="L107">                    intersectionPart = r;</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">                } else if (r.intersects(rOp)) {</span>
                    // update intersection region
<span class="nc" id="L110">                    intersectionPart = r.intersection(rOp);</span>

                    // adjust rectangle: potentially split into 4 sub-rectangles
                    // ***************************
                    // * | 3 | *
                    // * ************* *
                    // * 1 * rOp * 2 *
                    // * ************* *
                    // * | 4 | *
                    // ***************************

                    // region 1
<span class="nc bnc" id="L122" title="All 4 branches missed.">                    if (r.x &lt; rOp.x &amp;&amp; (r.x + r.width) &gt; rOp.x) {</span>
<span class="nc" id="L123">                        newRs.add(new Rectangle(r.x, r.y, (rOp.x - r.x),</span>
                                r.height));
                    }
                    // region 2
<span class="nc bnc" id="L127" title="All 4 branches missed.">                    if ((r.x + r.width) &gt; (rOp.x + rOp.width)</span>
                        &amp;&amp; r.x &lt; (rOp.x + rOp.width)) {
<span class="nc" id="L129">                        newRs.add(new Rectangle((rOp.x + rOp.width), r.y,</span>
                                (r.x + r.width - rOp.x - rOp.width), r.height));
                    }
                    // region 3
<span class="nc bnc" id="L133" title="All 2 branches missed.">                    if (r.y &lt; rOp.y) {</span>
<span class="nc" id="L134">                        int x1 = Math.max(r.x, rOp.x);</span>
<span class="nc" id="L135">                        int x2 = Math.min(r.x + r.width, rOp.x + rOp.width);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">                        if (x1 &lt; x2)</span>
<span class="nc" id="L137">                            newRs.add(new Rectangle(x1, r.y, x2 - x1, rOp.y</span>
                                                                      - r.y));
                    }
                    // region 4
<span class="nc bnc" id="L141" title="All 2 branches missed.">                    if ((r.y + r.height) &gt; (rOp.y + rOp.height)) {</span>
<span class="nc" id="L142">                        int x1 = Math.max(r.x, rOp.x);</span>
<span class="nc" id="L143">                        int x2 = Math.min(r.x + r.width, rOp.x + rOp.width);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">                        if (x1 &lt; x2)</span>
<span class="nc" id="L145">                            newRs.add(new Rectangle(x1, (rOp.y + rOp.height),</span>
                                    x2 - x1,
                                    (r.y + r.height - rOp.y - rOp.height)));
                    }
                }

<span class="nc bnc" id="L151" title="All 2 branches missed.">                if (intersectionPart == null) {</span>
                    // if no intersection part, this rectangle remains unchanged
                    // in the set
<span class="nc" id="L154">                    newRs.add(r);</span>
                } else {
                    // expand the intersection region if intersection part found
<span class="nc bnc" id="L157" title="All 2 branches missed.">                    if (intersection == null) {</span>
<span class="nc" id="L158">                        intersection = (Rectangle) intersectionPart.clone();</span>
                    } else {
<span class="nc" id="L160">                        intersection.add(intersectionPart);</span>
                    }
                }
<span class="nc" id="L163">            }</span>
<span class="nc" id="L164">            rs = newRs.rs;</span>
<span class="nc" id="L165">            return intersection;</span>
        }
    }

    private static abstract class HexLayer extends JComponent {
        private static final long serialVersionUID = 1L;
        protected final HexMap hexMap;

        private BufferedImage bufferedImage;
        /*
         * list of regions for which the layer's image buffer is dirty
         */
<span class="nc" id="L177">        private RectangleSet bufferDirtyRegions = new RectangleSet();</span>

        protected abstract void paintImage(Graphics2D g);

        protected HexLayer(HexMap hexMap) {
<span class="nc" id="L182">            super();</span>
<span class="nc" id="L183">            this.hexMap = hexMap;</span>
<span class="nc" id="L184">        }</span>


        final public void repaint() {
<span class="nc" id="L188">            bufferDirtyRegions.add(new Rectangle(0, 0, getWidth(), getHeight()));</span>
<span class="nc" id="L189">            super.repaint();</span>
<span class="nc" id="L190">        }</span>

        public void repaint(Rectangle r) {
<span class="nc" id="L193">            bufferDirtyRegions.add(r);</span>
<span class="nc" id="L194">            super.repaint(r);</span>
<span class="nc" id="L195">        }</span>

        final public void paintComponent(Graphics g) {
<span class="nc" id="L198">            super.paintComponent(g);</span>

            // avoid that paintComponent is processed concurrently
<span class="nc" id="L201">            synchronized (HexLayer.this) {</span>

                // Abort if called too early or if bounds are invalid.
<span class="nc" id="L204">                Rectangle rectClip = g.getClipBounds();</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                if (rectClip == null) return;</span>

                // ensure that image buffer of this layer is valid
<span class="nc bnc" id="L208" title="All 2 branches missed.">                if (bufferedImage == null</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                    || bufferedImage.getWidth() != getWidth()</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                    || bufferedImage.getHeight() != getHeight()) {</span>
                    // create new buffer image
<span class="nc" id="L212">                    bufferedImage =</span>
<span class="nc" id="L213">                            new BufferedImage(getWidth(), getHeight(),</span>
                                    BufferedImage.TYPE_INT_ARGB);

                    // clear information of the image buffer's dirty regions
<span class="nc" id="L217">                    bufferDirtyRegions = new RectangleSet();</span>

<span class="nc" id="L219">                    bufferDirtyRegions.add(new Rectangle(0, 0, getWidth(),</span>
<span class="nc" id="L220">                            getHeight()));</span>

                    // since the buffered image is empty, it has to be
                    // completely redrawn
<span class="nc" id="L224">                    rectClip = new Rectangle(0, 0, getWidth(), getHeight());</span>
                }

                // determine which parts of the clip are dirty and have to be
                // redrawn
<span class="nc" id="L229">                Rectangle dirtyClipArea =</span>
<span class="nc" id="L230">                        bufferDirtyRegions.getIntersectionAndRemoveFromSet(rectClip);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">                if (dirtyClipArea != null) {</span>
                    // buffer redraw is necessary
<span class="nc" id="L233">                    Graphics2D imageGraphics =</span>
<span class="nc" id="L234">                            (Graphics2D) bufferedImage.getGraphics();</span>

                    // apply the clip of the component's repaint to its image
                    // buffer
<span class="nc" id="L238">                    imageGraphics.setClip(dirtyClipArea.x, dirtyClipArea.y,</span>
                            dirtyClipArea.width, dirtyClipArea.height);

                    // set the background to transparent so that only drawn
                    // parts of the
                    // buffer will be taken over
<span class="nc" id="L244">                    imageGraphics.setBackground(new Color(0, 0, 0, 0));</span>
<span class="nc" id="L245">                    imageGraphics.setColor(Color.BLACK);</span>

                    // clear the clip (for a non-virtual graphic, this would
                    // have been
                    // done by super.paintComponent)
<span class="nc" id="L250">                    imageGraphics.clearRect(dirtyClipArea.x, dirtyClipArea.y,</span>
                            dirtyClipArea.width, dirtyClipArea.height);

                    // paint within the buffer
<span class="nc" id="L254">                    paintImage(imageGraphics);</span>

<span class="nc" id="L256">                    imageGraphics.dispose();</span>
                }

                // now buffer is valid and can be used
<span class="nc" id="L260">                BufferedImage bufferedRect =</span>
<span class="nc" id="L261">                        bufferedImage.getSubimage(rectClip.x, rectClip.y,</span>
                                rectClip.width, rectClip.height);
<span class="nc" id="L263">                g.drawImage(bufferedRect, rectClip.x, rectClip.y, null);</span>
<span class="nc" id="L264">            }</span>
<span class="nc" id="L265">        }</span>
    }

    /**
     * Layer containing tiles
     */
    private static class TilesLayer extends HexLayer {
        private static final long serialVersionUID = 1L;

        private TilesLayer(HexMap hexMap) {
<span class="nc" id="L275">            super(hexMap);</span>
<span class="nc" id="L276">        }</span>

        @Override
        public void paintImage(Graphics2D g) {
            try {
                // Paint tiles
<span class="nc bnc" id="L282" title="All 2 branches missed.">                for (GUIHex hex:hexMap.getHexes()) {</span>
<span class="nc" id="L283">                    Rectangle hexrect = hex.getBounds();</span>

<span class="nc bnc" id="L285" title="All 2 branches missed.">                    if (g.hitClip(hexrect.x, hexrect.y, hexrect.width,</span>
                            hexrect.height)) {
<span class="nc" id="L287">                        hex.paintTile(g);</span>
                    }
<span class="nc" id="L289">                }</span>

                // Paint the impassability bars
<span class="nc bnc" id="L292" title="All 2 branches missed.">                for (GUIHex hex:hexMap.getHexes()) {</span>
<span class="nc" id="L293">                    Rectangle hexrect = hex.getBounds();</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">                    if (g.hitClip(hexrect.x, hexrect.y, hexrect.width,</span>
                            hexrect.height)) {
<span class="nc" id="L297">                        hex.paintBars(g);</span>
                    }
<span class="nc" id="L299">                }</span>

<span class="nc" id="L301">            } catch (NullPointerException ex) {</span>
                // If we try to paint before something is loaded, just retry
                // later.
<span class="nc" id="L304">                log.debug(&quot;Premature call to TilesLayer.paintImage(Graphics g)&quot;);</span>
<span class="nc" id="L305">            }</span>
<span class="nc" id="L306">        }</span>
    }

    /**
     * Layer containing visualization of train routes
     */
    private static class RoutesLayer extends HexLayer {
        private static final long serialVersionUID = 1L;

        private static Color colour1, colour2, colour3, colour4;
        static {
            try {
<span class="nc" id="L318">                colour1 = Util.parseColour(Config.get(&quot;route.colour.1&quot;, null));</span>
<span class="nc" id="L319">                colour2 = Util.parseColour(Config.get(&quot;route.colour.2&quot;, null));</span>
<span class="nc" id="L320">                colour3 = Util.parseColour(Config.get(&quot;route.colour.3&quot;, null));</span>
<span class="nc" id="L321">                colour4 = Util.parseColour(Config.get(&quot;route.colour.4&quot;, null));</span>
<span class="nc" id="L322">            } catch (ConfigurationException e) {} finally {</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                if (colour1 == null) colour1 = Color.CYAN;</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">                if (colour2 == null) colour2 = Color.PINK;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">                if (colour3 == null) colour3 = Color.ORANGE;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                if (colour4 == null) colour4 = Color.GRAY;</span>
            }
<span class="nc" id="L328">        }</span>
        private static final int STROKE_WIDTH = 5;
        private static final int STROKE_CAP = BasicStroke.CAP_ROUND;
        private static final int STROKE_JOIN = BasicStroke.JOIN_BEVEL;

        private RoutesLayer(HexMap hexMap) {
<span class="nc" id="L334">            super(hexMap);</span>
<span class="nc" id="L335">        }</span>

        private Rectangle getRoutesBounds(List&lt;GeneralPath&gt; p1,
                List&lt;GeneralPath&gt; p2) {
<span class="nc" id="L339">            int margin = (int) Math.ceil(STROKE_WIDTH * hexMap.getZoomFactor());</span>

<span class="nc" id="L341">            List&lt;Rectangle&gt; pathRects = new ArrayList&lt;Rectangle&gt;();</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">            if (p1 != null) {</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                for (GeneralPath p : p1)</span>
<span class="nc" id="L344">                    pathRects.add(p.getBounds());</span>
            }
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if (p2 != null) {</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">                for (GeneralPath p : p2)</span>
<span class="nc" id="L348">                    pathRects.add(p.getBounds());</span>
            }

<span class="nc" id="L351">            Rectangle r = null;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            for (Rectangle pathRect : pathRects) {</span>
                // enlarge path rectangle with margin
<span class="nc" id="L354">                Rectangle pathMarginRect =</span>
                        new Rectangle(pathRect.x - margin, pathRect.y - margin,
                                pathRect.width + margin * 2, pathRect.height
                                                             + margin * 2);
<span class="nc bnc" id="L358" title="All 2 branches missed.">                if (r == null) {</span>
<span class="nc" id="L359">                    r = pathMarginRect;</span>
                } else {
<span class="nc" id="L361">                    r.add(pathMarginRect);</span>
                }
<span class="nc" id="L363">            }</span>
<span class="nc" id="L364">            return r;</span>
        };

        @Override
        public void paintImage(Graphics2D g) {
            try {
                // Abort if called too early.
<span class="nc" id="L371">                Rectangle rectClip = g.getClipBounds();</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                if (rectClip == null) {</span>
<span class="nc" id="L373">                    return;</span>
                }

                // paint train paths
<span class="nc bnc" id="L377" title="All 2 branches missed.">                if (hexMap.getTrainPaths() != null) {</span>
<span class="nc" id="L378">                    Stroke oldStroke = g.getStroke();</span>
<span class="nc" id="L379">                    Color oldColor = g.getColor();</span>
<span class="nc" id="L380">                    Stroke trainStroke =</span>
<span class="nc" id="L381">                            new BasicStroke((int) (STROKE_WIDTH * hexMap.getZoomFactor()),</span>
                                    STROKE_CAP, STROKE_JOIN);
<span class="nc" id="L383">                    g.setStroke(trainStroke);</span>

<span class="nc" id="L385">                    Color[] trainColors =</span>
                            new Color[] { colour1, colour2, colour3, colour4 };
<span class="nc" id="L387">                    int color = 0;</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">                    for (GeneralPath path:hexMap.getTrainPaths()) {</span>
<span class="nc" id="L389">                        g.setColor(trainColors[color++ % trainColors.length]);</span>
<span class="nc" id="L390">                        g.draw(path);</span>
<span class="nc" id="L391">                    }</span>
<span class="nc" id="L392">                    g.setStroke(oldStroke);</span>
<span class="nc" id="L393">                    g.setColor(oldColor);</span>
                }
<span class="nc" id="L395">            } catch (NullPointerException ex) {</span>
                // If we try to paint before something is loaded, just retry
                // later.
<span class="nc" id="L398">                log.debug(&quot;Premature call to RoutesLayer.paintImage(Graphics g)&quot;);</span>
<span class="nc" id="L399">            }</span>
<span class="nc" id="L400">        }</span>
    }

    /**
     * Layer containing marks on hexes (selected, selectable, highlighted).
     * Content may change very fast (due to mouse overs)
     */
    private static class MarksLayer extends HexLayer {

        private static final long serialVersionUID = 1L;

        private MarksLayer(HexMap hexMap) {
<span class="nc" id="L412">            super(hexMap);</span>
<span class="nc" id="L413">        }</span>

        @Override
        public void paintImage(Graphics2D g) {
            try {
                // Abort if called too early.
<span class="nc" id="L419">                Rectangle rectClip = g.getClipBounds();</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                if (rectClip == null) {</span>
<span class="nc" id="L421">                    return;</span>
                }

                // Paint tiles
<span class="nc bnc" id="L425" title="All 2 branches missed.">                for (GUIHex hex : hexMap.getHexes()) {</span>
<span class="nc" id="L426">                    Rectangle hexrect = hex.getBounds();</span>

<span class="nc bnc" id="L428" title="All 2 branches missed.">                    if (g.hitClip(hexrect.x, hexrect.y, hexrect.width,</span>
                            hexrect.height)) {
<span class="nc" id="L430">                        hex.paintMarks(g);</span>
                    }
<span class="nc" id="L432">                }</span>

<span class="nc" id="L434">            } catch (NullPointerException ex) {</span>
                // If we try to paint before something is loaded, just retry
                // later.
<span class="nc" id="L437">                log.debug(&quot;Premature call to MarksLayer.paintImage(Graphics g)&quot;);</span>
<span class="nc" id="L438">            }</span>
<span class="nc" id="L439">        }</span>
    }

    /**
     * Layer containing tokens and (if no background map is used) text
     * annotations
     */
    private static class TokensTextsLayer extends HexLayer {
        private static final long serialVersionUID = 1L;

        private TokensTextsLayer(HexMap hexMap) {
<span class="nc" id="L450">            super(hexMap);</span>
<span class="nc" id="L451">        }</span>

        private void drawLabel(Graphics2D g2, int index, int xCoordinate,
                int yCoordinate, boolean letter) {
            String label =
<span class="nc bnc" id="L456" title="All 2 branches missed.">                    letter ? getLetterLabel(index) : hexMap.getNumberLabel(index);</span>

<span class="nc" id="L458">            xCoordinate -= 4.0 * label.length();</span>
<span class="nc" id="L459">            yCoordinate += 4.0;</span>
<span class="nc" id="L460">            g2.drawString(label, xCoordinate, yCoordinate);</span>

            // log.debug(&quot;Draw Label &quot; + label + &quot; for &quot; + index + &quot; at x = &quot; +
            // xCoordinate + &quot;, y = &quot; + yCoordinate);
<span class="nc" id="L464">        }</span>

        private String getLetterLabel(int index) {
<span class="nc bnc" id="L467" title="All 2 branches missed.">            if (index &gt; 26) {</span>
<span class="nc" id="L468">                return &quot;A&quot; + String.valueOf((char) ('@' + (index - 26))); // For</span>
                                                                          // 1825U1
                                                                          // row
                                                                          // &quot;AA&quot;
            } else {
<span class="nc" id="L473">                return String.valueOf((char) ('@' + index));</span>
            }
        }

        @Override
        public void paintImage(Graphics2D g) {
            try {
                // Abort if called too early.
<span class="nc" id="L481">                Rectangle rectClip = g.getClipBounds();</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">                if (rectClip == null) {</span>
<span class="nc" id="L483">                    return;</span>
                }

                // Paint station tokens and texts
<span class="nc bnc" id="L487" title="All 2 branches missed.">                for (GUIHex hex : hexMap.getHexes()) {</span>
<span class="nc" id="L488">                    log.trace(&quot;hex ={}&quot;, hex);</span>
<span class="nc" id="L489">                    Rectangle hexrect = hex.getBounds();</span>

<span class="nc bnc" id="L491" title="All 2 branches missed.">                    if (g.hitClip(hexrect.x, hexrect.y, hexrect.width,</span>
                            hexrect.height)) {
<span class="nc" id="L493">                        hex.paintTokensAndText(g);</span>
                    }
<span class="nc" id="L495">                }</span>

                // paint coordinates
<span class="nc" id="L498">                boolean lettersGoHorizontal = hexMap.mapManager.getMapOrientation().lettersGoHorizontal();</span>
<span class="nc" id="L499">                int xLeft = (int) hexMap.calcXCoordinates(hexMap.minimum.getCol(), -hexMap.coordinateXMargin);</span>
<span class="nc" id="L500">                int xRight = (int) hexMap.calcXCoordinates(hexMap.maximum.getCol(), hexMap.coordinateXMargin);</span>

<span class="nc" id="L502">                int yTop = (int) hexMap.calcYCoordinates(hexMap.minimum.getRow(), -hexMap.coordinateYMargin);</span>
<span class="nc" id="L503">                int yBottom = (int) hexMap.calcYCoordinates(hexMap.maximum.getRow(), hexMap.coordinateYMargin);</span>

<span class="nc bnc" id="L505" title="All 2 branches missed.">                for (int iCol = hexMap.minimum.getCol(); iCol &lt;= hexMap.maximum.getCol(); iCol++) {</span>
<span class="nc" id="L506">                    int xCoordinate = (int) (hexMap.calcXCoordinates(iCol, 0));</span>
<span class="nc" id="L507">                    drawLabel(g, iCol, xCoordinate, yTop, lettersGoHorizontal);</span>
<span class="nc" id="L508">                    drawLabel(g, iCol, xCoordinate, yBottom,</span>
                            lettersGoHorizontal);
                }

<span class="nc bnc" id="L512" title="All 2 branches missed.">                for (int iRow = hexMap.minimum.getRow(); iRow &lt;= hexMap.maximum.getRow(); iRow++) {</span>
<span class="nc" id="L513">                    int yCoordinate = (int) (hexMap.calcYCoordinates(iRow, 0));</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">                    drawLabel(g, iRow, xLeft, yCoordinate,</span>
                            !lettersGoHorizontal);
<span class="nc bnc" id="L516" title="All 2 branches missed.">                    drawLabel(g, iRow, xRight, yCoordinate,</span>
                            !lettersGoHorizontal);
                }

<span class="nc" id="L520">            } catch (NullPointerException ex) {</span>
                // If we try to paint before something is loaded, just retry
                // later.
<span class="nc" id="L523">                log.debug(&quot;Premature call to TokensTextsLayer.paintImage(Graphics g)&quot;);</span>
<span class="nc" id="L524">            }</span>
<span class="nc" id="L525">        }</span>
    }

    /**
     * The only &quot;real&quot; (=swing managed) layer that is used for tool tips
     */
    private static class ToolTipsLayer extends JComponent {
        private static final long serialVersionUID = 1L;
    }

    // static fields (defined by init method)
    private ORUIManager orUIManager;
    private MapManager mapManager;

    // layers
    private TilesLayer tilesLayer;
    private RoutesLayer routesLayer;
    private MarksLayer marksLayer;
    private TokensTextsLayer tokensTextsLayer;
    private ToolTipsLayer toolTipsLayer;
    private List&lt;JComponent&gt; layers;

    protected Map&lt;MapHex, GUIHex&gt; hex2gui;

    // dynamic variables


    protected double scale;
<span class="nc" id="L553">    private int zoomStep = 10; // can be overwritten in config</span>
<span class="nc" id="L554">    private double zoomFactor = 1; // defined dynamically if zoomStep changed</span>

    protected Dimension originalSize;
    private Dimension currentSize;

<span class="nc" id="L559">    private GUIHex selectedHex = null;</span>

    /**
     * The hex over which the mouse pointer is currently situated
     */
<span class="nc" id="L564">    private GUIHex hexAtMousePosition = null;</span>

    /** list of generalpath elements to indicate train runs */
    private List&lt;GeneralPath&gt; trainPaths;

    // Definitions used by subclasses
    protected static final double PEAK_MARGIN = 1.0;
    protected static final double FLAT_MARGIN = 0.80;
    protected static final double COORDINATE_PEAK_MARGIN = 0.80;
    protected static final double COORDINATE_FLAT_MARGIN = 0.60;

    // (&quot;Abstract&quot;) Variables to be initialized by map type subclasses
    protected double tileXOffset;
    protected double tileYOffset;
    protected double coordinateXMargin;
    protected double coordinateYMargin;

    protected MapHex.Coordinates minimum;
    protected MapHex.Coordinates maximum;

    protected boolean displayMapImage;

    // Abstract Methods, implemented depending on the map type (EW or NS)
    protected abstract double calcXCoordinates(int col, double offset);

    protected abstract double calcYCoordinates(int row, double offset);

    protected abstract void setOriginalSize();


    public void init(ORUIManager orUIManager, MapManager mapManager) {

<span class="nc" id="L596">        this.orUIManager = orUIManager;</span>
<span class="nc" id="L597">        this.mapManager = mapManager;</span>

<span class="nc" id="L599">        displayMapImage = mapManager.isMapImageUsed();</span>

<span class="nc" id="L601">        minimum = mapManager.getMinimum();</span>
<span class="nc" id="L602">        maximum = mapManager.getMaximum();</span>

<span class="nc" id="L604">        log.trace(&quot;HexMap init: minimum = {}, maximum = {}&quot;, minimum, maximum);</span>

        // the following order of instantiation and list-adding defines the
        // layering
        // from the top to the bottom
<span class="nc" id="L609">        ImmutableList.Builder&lt;JComponent&gt; layerBuilder = ImmutableList.builder();</span>
<span class="nc" id="L610">        toolTipsLayer = new ToolTipsLayer();</span>
<span class="nc" id="L611">        layerBuilder.add(toolTipsLayer);</span>
<span class="nc" id="L612">        tokensTextsLayer = new TokensTextsLayer(this);</span>
<span class="nc" id="L613">        layerBuilder.add(tokensTextsLayer);</span>
<span class="nc" id="L614">        marksLayer = new MarksLayer(this);</span>
<span class="nc" id="L615">        layerBuilder.add(marksLayer);</span>
<span class="nc" id="L616">        routesLayer = new RoutesLayer(this);</span>
<span class="nc" id="L617">        layerBuilder.add(routesLayer);</span>
<span class="nc" id="L618">        tilesLayer = new TilesLayer(this);</span>
<span class="nc" id="L619">        layerBuilder.add(tilesLayer);</span>
<span class="nc" id="L620">        layers = layerBuilder.build();</span>

<span class="nc" id="L622">        initializeSettings();</span>
<span class="nc" id="L623">        setScale();</span>
<span class="nc" id="L624">        setupHexes();</span>
<span class="nc" id="L625">        setOriginalSize();</span>

<span class="nc" id="L627">        currentSize = (Dimension) originalSize.clone();</span>
<span class="nc" id="L628">        setPreferredSize(originalSize);</span>
        // always call zoom to adjust scaling
<span class="nc" id="L630">        zoom();</span>
<span class="nc" id="L631">    }</span>

    /**
     * defines settings from the config files
     */
    private void initializeSettings() {

        // define zoomStep from config
<span class="nc" id="L639">        String zoomStepSetting = Config.getGameSpecific(&quot;map.zoomstep&quot;);</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (Util.hasValue(zoomStepSetting)) {</span>
            try {
<span class="nc" id="L642">                int newZoomStep = Integer.parseInt(zoomStepSetting);</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                if (zoomStep != newZoomStep) {</span>
<span class="nc" id="L644">                    zoomStep = newZoomStep;</span>
                }
<span class="nc" id="L646">            } catch (NumberFormatException e) {</span>
                // otherwise keep default defined above
<span class="nc" id="L648">            }</span>
        }
<span class="nc" id="L650">    }</span>

    public void addLayers(JLayeredPane p, int startingZOffset) {
<span class="nc" id="L653">        int z = startingZOffset;</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">        for (JComponent l : layers) {</span>
<span class="nc" id="L655">            p.add(l, z++);</span>
<span class="nc" id="L656">        }</span>
<span class="nc" id="L657">    }</span>

    protected void setupHexesGUI() {
        ImmutableMap.Builder&lt;MapHex, GUIHex&gt; hexMapBuilder =
<span class="nc" id="L661">                ImmutableMap.builder();</span>

<span class="nc bnc" id="L663" title="All 2 branches missed.">        for (MapHex hex:mapManager.getHexes()) {</span>
<span class="nc" id="L664">            GUIHex guiHex = new GUIHex(this, hex, scale);</span>
<span class="nc" id="L665">            hexMapBuilder.put(hex, guiHex);</span>
<span class="nc" id="L666">        }</span>
<span class="nc" id="L667">        hex2gui = hexMapBuilder.build();</span>
<span class="nc" id="L668">    }</span>

    protected void scaleHexesGUI() {
<span class="nc bnc" id="L671" title="All 2 branches missed.">        for (GUIHex hex:hex2gui.values()) {</span>
<span class="nc" id="L672">            hex.setDimensions(scale, zoomFactor);</span>
<span class="nc" id="L673">        }</span>
<span class="nc" id="L674">    }</span>

    private String getNumberLabel(int index) {
<span class="nc bnc" id="L677" title="All 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L678">            return String.valueOf(100 + index); // For 1825U1 column &quot;99&quot;</span>
        } else {
<span class="nc" id="L680">            return String.valueOf(index);</span>
        }
    }

    public void setupHexes() {
<span class="nc" id="L685">        setupHexesGUI();</span>
<span class="nc" id="L686">        setupBars();</span>
<span class="nc" id="L687">        addMouseListener(this);</span>
<span class="nc" id="L688">        addMouseMotionListener(this);</span>
<span class="nc" id="L689">    }</span>

    public void setupBars() {
<span class="nc bnc" id="L692" title="All 2 branches missed.">        for (MapHex hex : hex2gui.keySet()) {</span>
<span class="nc" id="L693">            HexSidesSet barSides = hex.getImpassableSides();</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">            for (HexSide side:barSides) {</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">                if (side.getTrackPointNumber() &lt; 3) {</span>
<span class="nc" id="L696">                    hex2gui.get(hex).addBar(side);</span>
                }
<span class="nc" id="L698">            }</span>
<span class="nc" id="L699">        }</span>
<span class="nc" id="L700">    }</span>

    GUIHex getHexContainingPoint(Point point) {
<span class="nc bnc" id="L703" title="All 2 branches missed.">        for (GUIHex hex : hex2gui.values()) {</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">            if (hex.contains(point)) {</span>
<span class="nc" id="L705">                return hex;</span>
            }
<span class="nc" id="L707">        }</span>
<span class="nc" id="L708">        return null;</span>
    }

    public GUIHex getHex(MapHex hex) {
<span class="nc" id="L712">        return hex2gui.get(hex);</span>
    }

    public Collection&lt;GUIHex&gt;  getHexes() {
<span class="nc" id="L716">        return hex2gui.values();</span>
    }

    public boolean hasMapImage() {
<span class="nc" id="L720">        return displayMapImage;</span>
    }

    public boolean isTilePainted(Tile tile) {
<span class="nc bnc" id="L724" title="All 4 branches missed.">        return !(displayMapImage &amp;&amp; tile.isPrepainted());</span>
    }

    public void zoom(boolean in) {
<span class="nc bnc" id="L728" title="All 2 branches missed.">        if (in)</span>
<span class="nc" id="L729">            zoomStep++;</span>
        else
<span class="nc" id="L731">            zoomStep--;</span>
<span class="nc" id="L732">        zoom();</span>
<span class="nc" id="L733">    }</span>

    public void setZoomStep(int zoomStep) {
<span class="nc" id="L736">        this.zoomStep = zoomStep;</span>
<span class="nc" id="L737">        zoom();</span>
<span class="nc" id="L738">    }</span>

    public int getZoomStep() {
<span class="nc" id="L741">        return zoomStep;</span>
    }

    public double getZoomFactor() {
<span class="nc" id="L745">        return zoomFactor;</span>
    }

    private void zoom() {
<span class="nc" id="L749">        zoomFactor = GameUIManager.getImageLoader().getZoomFactor(zoomStep);</span>
<span class="nc" id="L750">        log.trace(&quot;HexMap: zoomStep = &quot; + zoomStep);</span>
<span class="nc" id="L751">        log.trace(&quot;HexMap: zoomFactor = &quot; + zoomFactor);</span>
<span class="nc" id="L752">        setScale();</span>
<span class="nc" id="L753">        scaleHexesGUI();</span>
<span class="nc" id="L754">        currentSize.width = (int) (originalSize.width * zoomFactor);</span>
<span class="nc" id="L755">        currentSize.height = (int) (originalSize.height * zoomFactor);</span>
<span class="nc" id="L756">        setPreferredSize(currentSize);</span>
<span class="nc" id="L757">    }</span>

    protected void setScale() {
<span class="nc" id="L760">        scale = (16 * zoomFactor);</span>
<span class="nc" id="L761">    }</span>

    public Dimension getOriginalSize() {
<span class="nc" id="L764">        return originalSize;</span>
    }

    public Dimension getCurrentSize() {
<span class="nc" id="L768">        return currentSize;</span>
    }

    public void selectHex(GUIHex clickedHex) {
<span class="nc" id="L772">        log.debug(&quot;selecthex called for hex &quot;</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">                  + (clickedHex != null ? clickedHex.toText() : &quot;null&quot;)</span>
                  + &quot;, selected was &quot;
<span class="nc bnc" id="L775" title="All 2 branches missed.">                  + (selectedHex != null ? selectedHex.toText() : &quot;null&quot;));</span>

<span class="nc bnc" id="L777" title="All 2 branches missed.">        if (selectedHex == clickedHex) return;</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (selectedHex != null) {</span>
            // Hexes with only invalids do not change state
<span class="nc bnc" id="L780" title="All 2 branches missed.">            if (selectedHex.getState() != GUIHex.State.INVALIDS) {</span>
<span class="nc" id="L781">                selectedHex.setState(GUIHex.State.SELECTABLE);</span>
            }
        }

<span class="nc bnc" id="L785" title="All 2 branches missed.">        if (clickedHex != null) {</span>
            // Hexes with only invalids do not change state
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (clickedHex.getState() != GUIHex.State.INVALIDS) {</span>
<span class="nc" id="L788">                clickedHex.setState(GUIHex.State.SELECTED);</span>
            }
        }
<span class="nc" id="L791">        selectedHex = clickedHex;</span>

<span class="nc" id="L793">    }</span>

    public GUIHex getSelectedHex() {
<span class="nc" id="L796">        return selectedHex;</span>
    }

    public void setSelectedHex(GUIHex hex) {
<span class="nc" id="L800">        selectedHex = hex;</span>
<span class="nc" id="L801">    }</span>

    public List&lt;GUIHex&gt; getHexesByCurrentTileId(Tile tile) {
        ImmutableList.Builder&lt;GUIHex&gt; hexBuilder =
<span class="nc" id="L805">                ImmutableList.builder();</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">        for (MapHex hex : hex2gui.keySet()) {</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">            if (hex.getCurrentTile() == tile) {</span>
<span class="nc" id="L808">                hexBuilder.add(hex2gui.get(hex));</span>
            }
<span class="nc" id="L810">        }</span>
<span class="nc" id="L811">        return hexBuilder.build();</span>
    }


    // FIXME: Remove the code here, only used for reference during rewrite of token code
//    @SuppressWarnings(&quot;unchecked&quot;)
//    public &lt;T extends LayToken&gt; void setAllowedTokenLays(
//            List&lt;T&gt; allowedTokenLays) {
//
//        this.allowedTokenLays = (List&lt;LayToken&gt;) allowedTokenLays;
//        allowedTokensPerHex = new HashMap&lt;MapHex, List&lt;LayToken&gt;&gt;();
//        bonusTokenLayingEnabled = false;
//
//        /* Build the per-hex allowances map */
//        for (LayToken allowance : this.allowedTokenLays) {
//            List&lt;MapHex&gt; locations = allowance.getLocations();
//            if (locations == null) {
//                /*
//                 * The location may be null, which means: anywhere. This is
//                 * intended to be a temporary fixture, to be replaced by a
//                 * detailed allowed-tiles-per-hex specification later.
//                 */
//                // For now, allow all hexes having non-filled city stations
//                if (allowance instanceof LayBaseToken) {
//                    MapHex hex;
//                    for (GUIHex guiHex : hex2gui.values()) {
//                        hex = guiHex.getHexModel();
//                        if (hex.hasTokenSlotsLeft()) {
//                            allowTokenOnHex(hex, allowance);
//                        }
//                    }
//                } else {
//                    allowTokenOnHex(null, allowance);
//                }
//            } else {
//                for (MapHex location : locations) {
//                    allowTokenOnHex(location, allowance);
//                }
//            }
//            if (allowance instanceof LayBonusToken) {
//                bonusTokenLayingEnabled = true;
//            }
//        }
//    }
//
//    private void allowTokenOnHex(MapHex hex, LayToken allowance) {
//        if (!allowedTokensPerHex.containsKey(hex)) {
//            allowedTokensPerHex.put(hex, new ArrayList&lt;LayToken&gt;());
//        }
//        allowedTokensPerHex.get(hex).add(allowance);
//    }
//
//    public List&lt;LayToken&gt; getTokenAllowanceForHex(MapHex hex) {
//        List&lt;LayToken&gt; allowances = new ArrayList&lt;LayToken&gt;(2);
//        if (hex != null &amp;&amp; allowedTokensPerHex.containsKey(hex)) {
//            allowances.addAll(allowedTokensPerHex.get(hex));
//        }
//        if (allowedTokensPerHex.containsKey(null)) {
//            allowances.addAll(allowedTokensPerHex.get(null));
//        }
//        return allowances;
//    }
//
//    public List&lt;LayBaseToken&gt; getBaseTokenAllowanceForHex(MapHex hex) {
//        List&lt;LayBaseToken&gt; allowances = new ArrayList&lt;LayBaseToken&gt;(2);
//        for (LayToken allowance : getTokenAllowanceForHex(hex)) {
//            if (allowance instanceof LayBaseToken) {
//                allowances.add((LayBaseToken) allowance);
//            }
//        }
//        return allowances;
//    }
//
//    public List&lt;LayBonusToken&gt; getBonusTokenAllowanceForHex(MapHex hex) {
//        List&lt;LayBonusToken&gt; allowances = new ArrayList&lt;LayBonusToken&gt;(2);
//        for (LayToken allowance : getTokenAllowanceForHex(hex)) {
//            if (allowance instanceof LayBonusToken) {
//                allowances.add((LayBonusToken) allowance);
//            }
//        }
//        return allowances;
//    }
//
    public List&lt;GeneralPath&gt; getTrainPaths() {
<span class="nc" id="L895">        return trainPaths;</span>
    }

    public void setTrainPaths(List&lt;GeneralPath&gt; trainPaths) {
<span class="nc" id="L899">        Rectangle dirtyRect =</span>
<span class="nc" id="L900">                routesLayer.getRoutesBounds(this.trainPaths, trainPaths);</span>
<span class="nc" id="L901">        this.trainPaths = trainPaths;</span>

        // only repaint if routes existed before or exist now
<span class="nc bnc" id="L904" title="All 2 branches missed.">        if (dirtyRect != null) repaintRoutes(dirtyRect);</span>
<span class="nc" id="L905">    }</span>

    /**
     * Off-board tiles must be able to retrieve the current phase.
     *
     * @return The current Phase object.
     */
    public Phase getPhase() {
<span class="nc bnc" id="L913" title="All 2 branches missed.">        if (orUIManager != null) {</span>
<span class="nc" id="L914">            return orUIManager.getGameUIManager().getRoot().getPhaseManager().getCurrentPhase();</span>
        }
<span class="nc" id="L916">        return null;</span>
    }

    public MapManager getMapManager() {
<span class="nc" id="L920">        return mapManager;</span>
    }

    public ORUIManager getOrUIManager() {
<span class="nc" id="L924">        return orUIManager;</span>
    }

    /**
     * Mouse Listener methods (hexMap offers listener for all layers)
     */

    public synchronized void mouseClicked(MouseEvent arg0) {
<span class="nc" id="L932">        Point point = arg0.getPoint();</span>
<span class="nc" id="L933">        GUIHex clickedHex = getHexContainingPoint(point);</span>
<span class="nc" id="L934">        boolean rightClick = SwingUtilities.isRightMouseButton(arg0);</span>

        // if no action/correction was expected on the map panel
<span class="nc bnc" id="L937" title="All 2 branches missed.">        if (!orUIManager.hexClicked(clickedHex, selectedHex, rightClick)) {</span>

            // force the tool tip popup to appear immediately
<span class="nc" id="L940">            ToolTipManager ttm = ToolTipManager.sharedInstance();</span>
<span class="nc" id="L941">            MouseEvent phantomME =</span>
                    new MouseEvent(toolTipsLayer, MouseEvent.MOUSE_MOVED,
<span class="nc" id="L943">                            System.currentTimeMillis(), 0, arg0.getX(),</span>
<span class="nc" id="L944">                            arg0.getY(), 0, false);</span>

<span class="nc" id="L946">            int priorToolTipDelay = ttm.getInitialDelay();</span>
<span class="nc" id="L947">            ttm.setInitialDelay(0);</span>
<span class="nc" id="L948">            ttm.mouseMoved(phantomME);</span>
<span class="nc" id="L949">            ttm.setInitialDelay(priorToolTipDelay);</span>

            // int priorToolTipDelay = ttm.getInitialDelay();
            // ttm.mouseEntered(new MouseAdapter());
            // ToolTipManager.sharedInstance().setInitialDelay(0);
            // try {
            // this.wait(1);
            // } catch (InterruptedException e) {}
            // map = map;
        }
<span class="nc" id="L959">    }</span>

<span class="nc" id="L961">    public void mouseDragged(MouseEvent arg0) {}</span>

    public synchronized void mouseMoved(MouseEvent arg0) {
<span class="nc" id="L964">        Point point = arg0.getPoint();</span>
<span class="nc" id="L965">        GUIHex newHex = getHexContainingPoint(point);</span>

        // ignore if mouse has not entered a new hex
<span class="nc bnc" id="L968" title="All 2 branches missed.">        if (hexAtMousePosition == newHex) return;</span>

        // provide for hex highlighting
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (hexAtMousePosition != null)</span>
<span class="nc" id="L972">            hexAtMousePosition.removeHighlightRequest();</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">        if (newHex != null) newHex.addHighlightRequest();</span>

        // display tool tip
<span class="nc bnc" id="L976" title="All 2 branches missed.">        setToolTipText(newHex != null ? newHex.getToolTip() : null);</span>

<span class="nc" id="L978">        hexAtMousePosition = newHex;</span>
<span class="nc" id="L979">    }</span>

<span class="nc" id="L981">    public void mouseEntered(MouseEvent arg0) {}</span>

    public synchronized void mouseExited(MouseEvent arg0) {
        // provide for hex highlighting
<span class="nc bnc" id="L985" title="All 2 branches missed.">        if (hexAtMousePosition != null) {</span>
<span class="nc" id="L986">            hexAtMousePosition.removeHighlightRequest();</span>
<span class="nc" id="L987">            hexAtMousePosition = null;</span>
        }
<span class="nc" id="L989">    }</span>

<span class="nc" id="L991">    public void mousePressed(MouseEvent arg0) {}</span>

<span class="nc" id="L993">    public void mouseReleased(MouseEvent arg0) {}</span>

    /**
     * Triggers for asynchronous repaint of specific layers If possible, these
     * triggers: - only apply for a specified area
     */

    public synchronized void repaintTiles(Rectangle r) {
<span class="nc" id="L1001">        tilesLayer.repaint(r);</span>
<span class="nc" id="L1002">    }</span>

    private synchronized void repaintRoutes(Rectangle r) {
<span class="nc" id="L1005">        routesLayer.repaint(r);</span>
<span class="nc" id="L1006">    }</span>

    public synchronized void repaintMarks(Rectangle r) {
<span class="nc" id="L1009">        marksLayer.repaint(r);</span>
<span class="nc" id="L1010">    }</span>

    public synchronized void repaintTokens(Rectangle r) {
<span class="nc" id="L1013">        tokensTextsLayer.repaint(r);</span>
<span class="nc" id="L1014">    }</span>

    /**
     * Do only call this method if you are sure that a complete repaint is
     * needed!
     */
    public synchronized void repaintAll(Rectangle r) {
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        for (JComponent l : layers) {</span>
<span class="nc" id="L1022">            l.repaint(r);</span>
<span class="nc" id="L1023">        }</span>
<span class="nc" id="L1024">    }</span>

    /**
     * JComponent methods delegating to the hexmap layers
     */

    public void setBounds(int x, int y, int width, int height) {
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        for (JComponent l : layers) {</span>
<span class="nc" id="L1032">            l.setBounds(x, y, width, height);</span>
<span class="nc" id="L1033">        }</span>
<span class="nc" id="L1034">    }</span>

    private void setPreferredSize(Dimension size) {
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        for (JComponent l : layers) {</span>
<span class="nc" id="L1038">            l.setPreferredSize(size);</span>
<span class="nc" id="L1039">        }</span>
<span class="nc" id="L1040">    }</span>

    private void setToolTipText(String text) {
<span class="nc" id="L1043">        toolTipsLayer.setToolTipText(text);</span>
<span class="nc" id="L1044">    }</span>

    public Dimension getSize() {
        // get size from top-most layer (all layers have the same size anyways)
<span class="nc" id="L1048">        return layers.get(layers.size() - 1).getSize();</span>
    }

    private void addMouseListener(MouseListener ml) {
<span class="nc bnc" id="L1052" title="All 2 branches missed.">        for (JComponent l : layers) {</span>
<span class="nc" id="L1053">            l.addMouseListener(ml);</span>
<span class="nc" id="L1054">        }</span>
<span class="nc" id="L1055">    }</span>

    private void addMouseMotionListener(MouseMotionListener ml) {
<span class="nc bnc" id="L1058" title="All 2 branches missed.">        for (JComponent l : layers) {</span>
<span class="nc" id="L1059">            l.addMouseMotionListener(ml);</span>
<span class="nc" id="L1060">        }</span>
<span class="nc" id="L1061">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>