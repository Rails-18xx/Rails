<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PublicCertificate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.game.financial</a> &gt; <span class="el_source">PublicCertificate.java</span></div><h1>PublicCertificate.java</h1><pre class="source lang-java linenums">package net.sf.rails.game.financial;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.SortedSet;

import net.sf.rails.common.LocalText;
import net.sf.rails.game.PublicCompany;
import net.sf.rails.game.RailsItem;
import net.sf.rails.game.RailsOwnableItem;
import net.sf.rails.game.RailsRoot;
import net.sf.rails.game.model.CertificatesModel;
import net.sf.rails.game.state.IntegerState;
import net.sf.rails.game.state.Ownable;
import net.sf.rails.game.state.Typable;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.ComparisonChain;
import com.google.common.collect.ImmutableSortedSet;


/**
 * Rails 2.x TODO:
 * Create an abstraction that defines a CertificateType (currently attributes president, shares, certificateCount)
 * Each certificate belongs to a Certificate Type and a Company
 * Then clean up the current mess, including the static map, which is only for backward compatibility for early 1.x versions
 */

public class PublicCertificate extends RailsOwnableItem&lt;PublicCertificate&gt; implements Certificate, Cloneable, Typable&lt;PublicCompany&gt; {

    /**
     * Combination defines a set of certificates
     */
    public static class Combination implements Comparable&lt;Combination&gt;, Iterable&lt;PublicCertificate&gt; {

        private final SortedSet&lt;PublicCertificate&gt; certs;

<span class="fc" id="L41">        private Combination(SortedSet&lt;PublicCertificate&gt; certs) {</span>
<span class="fc" id="L42">            this.certs = certs;</span>
<span class="fc" id="L43">        }</span>

        public static Combination create(Iterable&lt;PublicCertificate&gt; certs) {
<span class="fc" id="L46">            return new Combination(ImmutableSortedSet.copyOf(certs));</span>
        }

        public SortedSet&lt;PublicCertificate&gt; getCertificates() {
<span class="nc" id="L50">            return certs;</span>
        }

        public int size() {
<span class="fc" id="L54">            return certs.size();</span>
        }

        @Override
        public int compareTo(Combination other) {
<span class="fc" id="L59">            return ((Integer)certs.size()).compareTo(other.size());</span>
        }

        @Override
        public Iterator&lt;PublicCertificate&gt; iterator() {
<span class="fc" id="L64">            return certs.iterator();</span>
        }

    }


    /** From which public company is this a certificate */
    protected PublicCompany company;
    /**
     * Share percentage represented by this certificate
     */
<span class="fc" id="L75">    protected IntegerState shares = IntegerState.create(this, &quot;shares&quot;);</span>
    /** President's certificate? */
    protected boolean president;
    // FIXME: If this is changable, it should be a state variable, otherwise UNDO problems
    /** Count against certificate limits */
<span class="fc" id="L80">    protected float certificateCount = 1.0f;</span>

    /** Availability at the start of the game */
    protected boolean initiallyAvailable;

    /** A key identifying the certificate's unique ID */
    protected String certId;

    // FIMXE:
    /** Index within company (to be maintained in the IPO) */
    protected int indexInCompany;

    /** A map allowing to find certificates by unique id */
    // FIXME: Remove static map, replace by other location mechanisms
<span class="fc" id="L94">    protected static Map&lt;String, PublicCertificate&gt; certMap =</span>
            new HashMap&lt;String, PublicCertificate&gt;();


<span class="fc" id="L98">    private static final Logger log =</span>
<span class="fc" id="L99">            LoggerFactory.getLogger(PublicCertificate.class);</span>

    // TODO: Rewrite constructors
    // TODO: Should every certificate have its own id and be registered with the parent?
    public PublicCertificate(RailsItem parent, String id, int shares, boolean president,
            boolean available, float certificateCount, int index) {
<span class="fc" id="L105">        super(parent, id, PublicCertificate.class);</span>
<span class="fc" id="L106">        this.shares.set(shares);</span>
<span class="fc" id="L107">        this.president = president;</span>
<span class="fc" id="L108">        this.initiallyAvailable = available;</span>
<span class="fc" id="L109">        this.certificateCount = certificateCount;</span>
<span class="fc" id="L110">        this.indexInCompany = index;</span>
<span class="fc" id="L111">    }</span>

// TODO: Can be removed, as
//    most likely this does not work, as it duplicates ids
//    public PublicCertificate(PublicCertificate oldCert) {
//        super(oldCert.getParent(), oldCert.getId(), PublicCertificate.class);
//        this.shares = oldCert.getShares();
//        this.president = oldCert.isPresidentShare();
//        this.initiallyAvailable = oldCert.isInitiallyAvailable();
//        this.certificateCount = oldCert.getCertificateCount();
//        this.indexInCompany = oldCert.getIndexInCompany();
//    }

    @Override
    public RailsItem getParent(){
<span class="nc" id="L126">        return (RailsItem)super.getParent();</span>
    }

    @Override
    public RailsRoot getRoot() {
<span class="fc" id="L131">        return (RailsRoot)super.getRoot();</span>
    }

    /** Set the certificate's unique ID, for use in deserializing */
    public void setUniqueId(String name, int index) {
<span class="fc" id="L136">        certId = name + &quot;-&quot; + index;</span>
<span class="fc" id="L137">        certMap.put(certId, this);</span>
<span class="fc" id="L138">    }</span>

    /** Set the certificate's unique ID */
    public String getUniqueId() {
<span class="nc" id="L142">        return certId;</span>
    }

    public int getIndexInCompany() {
<span class="fc" id="L146">        return indexInCompany;</span>
    }

    public static PublicCertificate getByUniqueId(String certId) {
<span class="fc" id="L150">        return certMap.get(certId);</span>
    }


    // FIXME: There is no guarantee that the parent of a certificate portfolio is a portfolioModel
    // Replace that by something that works
    public CertificatesModel getHolder() {
        //return getPortfolio().getParent().getShareModel(company);
<span class="nc" id="L158">        return null;</span>
    }

    /**
     * @return if this is a president's share
     */
    public boolean isPresidentShare() {
<span class="fc" id="L165">        return president;</span>
    }

    /**
     * Get the number of shares that this certificate represents.
     *
     * @return The number of shares.
     */
    public int getShares() {
<span class="fc" id="L174">        return (Integer) shares.value();</span>
    }

    /**
     * Get the percentage of ownership that this certificate represents. This is
     * equal to the number of shares * the share unit.
     *
     * @return The share percentage.
     */
    public int getShare() {
<span class="fc" id="L184">        return ((Integer) shares.value()) * company.getShareUnit();</span>
    }


    public void setInitiallyAvailable(boolean initiallyAvailable) {
<span class="fc" id="L189">        this.initiallyAvailable = initiallyAvailable;</span>
<span class="fc" id="L190">    }</span>

    public boolean isInitiallyAvailable() {
<span class="fc" id="L193">        return initiallyAvailable;</span>
    }

    public void setPresident(boolean b) {
<span class="nc" id="L197">        president = b;</span>
<span class="nc" id="L198">    }</span>

    public PublicCompany getCompany() {
<span class="fc" id="L201">        return company;</span>
    }

    public void setCompany(PublicCompany companyI) {
<span class="fc" id="L205">        company = companyI;</span>
<span class="fc" id="L206">    }</span>

    public String getTypeId() {
<span class="fc" id="L209">        String certTypeId = company.getId() + &quot;_&quot; + getShare() + &quot;%&quot;;</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (president) certTypeId += &quot;_P&quot;;</span>
<span class="fc" id="L211">        return certTypeId;</span>
    }

    // Typable interface
    @Override
    public PublicCompany getType() {
<span class="fc" id="L217">        return company;</span>
    }

    @Override
    protected Object clone() {
        try {
<span class="nc" id="L223">            return super.clone();</span>
<span class="nc" id="L224">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L225">            log.error(&quot;Cannot clone certificate:&quot;, e);</span>
<span class="nc" id="L226">            return null;</span>
        }
    }

    public PublicCertificate copy() {
<span class="nc" id="L231">        return (PublicCertificate) this.clone();</span>
    }

    /**
     * Compare is based on
     * A) Presidency (presidency comes first in natural ordering)
     * B) Number of Shares (more shares means come first)
     * C) Id of CertificateType
     * D) Id of Certificate
     */
    // FIXME: The default comparator can only contain final attributes, otherwise
    // otherwise Portfolios (TreeMaps) might get confused
    // Implement another comparator for display that does not define a standard sorting
    @Override
    public int compareTo(Ownable other) {
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        if (other instanceof PublicCertificate) {</span>
<span class="fc" id="L247">            PublicCertificate otherCert = (PublicCertificate)other;</span>
            // sort by the criteria defined above
<span class="fc" id="L249">            return ComparisonChain.start()</span>
<span class="fc" id="L250">                    .compare(this.getCompany(), otherCert.getCompany())</span>
//                    .compare(otherCert.isPresidentShare(), this.isPresidentShare())
//                    .compare(otherCert.getShares(), this.getShares())
//                    .compare(this.getType().getId(), otherCert.getType().getId())
<span class="fc" id="L254">                    .compare(this.getId(), otherCert.getId())</span>
<span class="fc" id="L255">                    .result();</span>
        } else {
<span class="nc" id="L257">            return super.compareTo(other);</span>
        }
    }

    public void setShares(int numShares) {
<span class="fc" id="L262">       this.shares.set(numShares);</span>

<span class="fc" id="L264">    }</span>

    // Certificate Interface
    public float getCertificateCount() {
<span class="fc" id="L268">        return certificateCount;</span>
    }

    @Deprecated
    public void setCertificateCount(float certificateCount) {
<span class="fc" id="L273">        this.certificateCount = certificateCount;</span>
<span class="fc" id="L274">    }</span>

    // Item interface
    /**
     * Get the name of a certificate. The name is derived from the company name
     * and the share percentage of this certificate. If it is a 100% share (as
     * occurs with e.g. 1835 minors), only the company name is given. If it is a
     * president's share, that fact is mentioned.
     */
    @Override
    public String toText() {
<span class="fc" id="L285">        int share = getShare();</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (share == 100) {</span>
            /* Applies to shareless minors: just name the company */
<span class="fc" id="L288">            return company.getId();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        } else if (president) {</span>
<span class="fc" id="L290">            return LocalText.getText(&quot;PRES_CERT_NAME&quot;,</span>
<span class="fc" id="L291">                    company.getId(),</span>
<span class="fc" id="L292">                    getShare() );</span>
        } else {
<span class="fc" id="L294">            return LocalText.getText(&quot;CERT_NAME&quot;,</span>
<span class="fc" id="L295">                    company.getId(),</span>
<span class="fc" id="L296">                    getShare());</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>