<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StockRound.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Rails</a> &gt; <a href="index.source.html" class="el_package">net.sf.rails.game.financial</a> &gt; <span class="el_source">StockRound.java</span></div><h1>StockRound.java</h1><pre class="source lang-java linenums">package net.sf.rails.game.financial;

import java.util.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import net.sf.rails.game.StartRound;
import rails.game.action.*;
import net.sf.rails.common.*;
import net.sf.rails.game.GameDef;
import net.sf.rails.game.GameManager;
import net.sf.rails.game.Player;
import net.sf.rails.game.PlayerManager;
import net.sf.rails.game.PrivateCompany;
import net.sf.rails.game.PublicCompany;
import net.sf.rails.game.Round;
import net.sf.rails.game.GameDef.Parm;
import net.sf.rails.game.model.PortfolioModel;
import net.sf.rails.game.round.Activity;
import net.sf.rails.game.special.*;
import net.sf.rails.game.state.*;
import net.sf.rails.game.state.Currency;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSetMultimap;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;
import com.google.common.collect.SortedMultiset;


/**
 * Implements a basic Stock Round. &lt;p&gt; A new instance must be created for each
 * new Stock Round. At the end of a round, the current instance should be
 * discarded. &lt;p&gt; Permanent memory is formed by static attributes (like who has
 * the Priority Deal).
 */
public class StockRound extends Round {
<span class="fc" id="L39">    private static final Logger log = LoggerFactory.getLogger(StockRound.class);</span>

	/* Transient memory (per round only) */
	protected int numberOfPlayers;
	protected Player currentPlayer;
	protected Player startingPlayer;

<span class="fc" id="L46">	protected final GenericState&lt;PublicCompany&gt; companyBoughtThisTurnWrapper =</span>
<span class="fc" id="L47">			GenericState.create(this, &quot;companyBoughtThisTurnWrapper&quot;);</span>

<span class="fc" id="L49">	protected final BooleanState hasSoldThisTurnBeforeBuying =</span>
<span class="fc" id="L50">			BooleanState.create(this, &quot;hasSoldThisTurnBeforeBuying&quot;);</span>

<span class="fc" id="L52">	protected final BooleanState hasActed = BooleanState.create(this, &quot;hasActed&quot;);</span>

<span class="fc" id="L54">	protected final IntegerState numPasses = IntegerState.create(this, &quot;numPasses&quot;);</span>

<span class="fc" id="L56">	protected HashMapState&lt;PublicCompany, StockSpace&gt; sellPrices = HashMapState.create(this, &quot;sellPrices&quot;);</span>

	/** Records lifted share selling obligations in the current round&lt;p&gt;
	 * Example: &gt;60% ownership allowed after a merger in 18EU.
	 */
<span class="fc" id="L61">	protected HashSetState&lt;PublicCompany&gt; sellObligationLifted = null;</span>


	/* Rule constants */
	public static final int SELL_BUY_SELL = 0;
	public static final int SELL_BUY = 1;
	public static final int SELL_BUY_OR_BUY_SELL = 2;

	/* Action constants */
	static public final int BOUGHT = 0;
	static public final int SOLD = 1;

	/* Rules */
	protected int sequenceRule;
<span class="fc" id="L75">	protected boolean raiseIfSoldOut = false;</span>

	/* Temporary variables */
<span class="fc" id="L78">	protected boolean isOverLimits = false;</span>
<span class="fc" id="L79">	protected String overLimitsDetail = null;</span>

	/** Autopasses */
<span class="fc" id="L82">	private final ArrayListState&lt;Player&gt; autopasses = ArrayListState.create(this, &quot;autopasses&quot;);</span>
<span class="fc" id="L83">	private final ArrayListState&lt;Player&gt; canRequestTurn = ArrayListState.create(this, &quot;canRequestTurn&quot;);</span>
<span class="fc" id="L84">	private final ArrayListState&lt;Player&gt; hasRequestedTurn = ArrayListState.create(this, &quot;hasRequestedTurn&quot;);</span>


	/**
	 * Constructed via Configure
	 */
	public StockRound (GameManager parent, String id) {
<span class="fc" id="L91">		super(parent, id);</span>

<span class="pc bpc" id="L93" title="1 of 2 branches missed.">		if (numberOfPlayers == 0)</span>
<span class="fc" id="L94">			numberOfPlayers = getRoot().getPlayerManager().getPlayers().size();</span>

<span class="fc" id="L96">		sequenceRule = GameDef.getGameParameterAsInt(this, GameDef.Parm.STOCK_ROUND_SEQUENCE);</span>

<span class="fc" id="L98">		guiHints.setVisibilityHint(GuiDef.Panel.MAP, true);</span>
<span class="fc" id="L99">		guiHints.setVisibilityHint(GuiDef.Panel.STOCK_MARKET, true);</span>
<span class="fc" id="L100">		guiHints.setActivePanel(GuiDef.Panel.STATUS);</span>
<span class="fc" id="L101">	}</span>

	/** Start the Stock Round. &lt;p&gt;
	 * Please note: subclasses that are NOT real stock rounds should NOT call this method
	 * (or set raiseIfSoldOut to false after calling this method).
	 */
	// called by:
	// GameManager: startStockRound
	// StockRound 1837, 18EU: (start)

	// overridden by:
	// StockRound 1837, 18EU
	// NationalFormationRound, PrussianFormationRound
	public void start() {

<span class="fc" id="L116">		ReportBuffer.add(this, LocalText.getText(&quot;StartStockRound&quot;,</span>
<span class="fc" id="L117">				getStockRoundNumber()));</span>

<span class="fc" id="L119">		playerManager.setCurrentToPriorityPlayer();</span>
<span class="fc" id="L120">		startingPlayer = playerManager.getCurrentPlayer(); // For the Report</span>
<span class="fc" id="L121">		ReportBuffer.add(this, LocalText.getText(&quot;HasPriority&quot;,</span>
<span class="fc" id="L122">				startingPlayer.getId() ));</span>

<span class="fc" id="L124">		initPlayer();</span>

<span class="fc" id="L126">		raiseIfSoldOut = true;</span>

<span class="fc" id="L128">	}</span>

	/*----- General methods -----*/
	// called by
	// StockRound: checkFirstRoundSellRestriction, finishRound, getRoundName, start
	// StockRound 1837, 1880: finishRound
	// StatusWindow: updateStatus

	// not overridden
	public int getStockRoundNumber() {
<span class="fc" id="L138">		return gameManager.getSRNumber();</span>
	}

	// called by:
	// GameManager: process, processOnReload
	// GameLoader: replayGame
	// StockRound 1837, 1856, 18EU: setPossibleActions

	// overridden by
	// ShareSellingRound
	// TreasuryShareRound
	// NationalFormationRound, PrussianFormationRound
	// StockRound 1837, 1856, 18EU
	// ShareSellingRound 1880
	// FinalMinorExchangeRound, FinalCoalExchangeRound
	@Override
	public boolean setPossibleActions() {

		// fix of the forced undo bug
<span class="fc" id="L157">		currentPlayer = playerManager.getCurrentPlayer();</span>

<span class="fc" id="L159">		boolean passAllowed = false;</span>

<span class="fc" id="L161">		setSellableShares();</span>

		// Certificate limits must be obeyed by selling excess shares
		// before any other action is allowed.
<span class="fc bfc" id="L165" title="All 2 branches covered.">		if (isOverLimits) {</span>
<span class="fc" id="L166">			return true;</span>
		}

<span class="fc" id="L169">		passAllowed = true;</span>

<span class="fc" id="L171">		setBuyableCerts();</span>

<span class="fc" id="L173">		setSpecialActions();</span>

<span class="fc" id="L175">		setGameSpecificActions();</span>

<span class="pc bpc" id="L177" title="1 of 2 branches missed.">		if (passAllowed) {</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">			if (hasActed.value()) {</span>
<span class="fc" id="L179">				possibleActions.add(new NullAction(NullAction.Mode.DONE));</span>
			} else {
<span class="fc" id="L181">				possibleActions.add(new NullAction(NullAction.Mode.PASS));</span>
<span class="fc" id="L182">				possibleActions.add(new NullAction(NullAction.Mode.AUTOPASS));</span>
			}
		}

<span class="pc bpc" id="L186" title="1 of 2 branches missed.">		if (getAutopasses() != null) {</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">			for (Player player : getAutopasses()) {</span>
<span class="fc" id="L188">				possibleActions.add(new RequestTurn(player));</span>
<span class="fc" id="L189">			}</span>
		}

<span class="fc" id="L192">		return true;</span>
	}

	/** Stub, can be overridden in subclasses */
	// called by:
	// StockRound: setPossibleActions

	// overridden by:
	// StockRound 1837, 18EU
	protected void setGameSpecificActions() {

<span class="fc" id="L203">	}</span>

	/**
	 * Create a list of certificates that a player may buy in a Stock Round,
	 * taking all rules into account.
	 *
	 * @return List of buyable certificates.
	 */
	// called by
	// StockRound: setPossibleActions
	// StockRound 1835: (setBuyableCerts)

	// overridden by
	// TreasuryShareRound
	// StockRound 1835, 1880,18EU
	public void setBuyableCerts() {
<span class="fc bfc" id="L219" title="All 2 branches covered.">		if (!mayCurrentPlayerBuyAnything()) return;</span>

		ImmutableSet&lt;PublicCertificate&gt; certs;
		PublicCertificate cert;
		StockSpace stockSpace;
		PortfolioModel from;
		int price;
		int number;
		int unitsForPrice;

<span class="fc" id="L229">		int playerCash = currentPlayer.getCashValue();</span>

		/* Get the next available IPO certificates */
		// Never buy more than one from the IPO
<span class="fc" id="L233">		PublicCompany companyBoughtThisTurn =</span>
<span class="fc" id="L234">				(PublicCompany) companyBoughtThisTurnWrapper.value();</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">		if (companyBoughtThisTurn == null) {</span>
<span class="fc" id="L236">			from = ipo;</span>
<span class="fc" id="L237">			ImmutableSetMultimap&lt;PublicCompany, PublicCertificate&gt; map =</span>
<span class="fc" id="L238">					from.getCertsPerCompanyMap();</span>

<span class="fc bfc" id="L240" title="All 2 branches covered.">			for (PublicCompany comp : map.keySet()) {</span>
<span class="fc" id="L241">				certs = map.get(comp);</span>
				// if (certs.isEmpty()) continue; // TODO: is this removal correct?

				/* Only the top certificate is buyable from the IPO */
				// TODO: This is code that should be deprecated
<span class="fc" id="L246">				int lowestIndex = 99;</span>
<span class="fc" id="L247">				cert = null;</span>
				int index;
<span class="fc bfc" id="L249" title="All 2 branches covered.">				for (PublicCertificate c : certs) {</span>
<span class="fc" id="L250">					index = c.getIndexInCompany();</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">					if (index &lt; lowestIndex) {</span>
<span class="fc" id="L252">						lowestIndex = index;</span>
<span class="fc" id="L253">						cert = c;</span>
					}
<span class="fc" id="L255">				}</span>

<span class="fc" id="L257">				unitsForPrice = comp.getShareUnitsForSharePrice();</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">				if (currentPlayer.hasSoldThisRound(comp)) continue;</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">				if (maxAllowedNumberOfSharesToBuy(currentPlayer, comp,</span>
<span class="fc" id="L260">						cert.getShare()) &lt; 1 ) continue;</span>

				/* Would the player exceed the total certificate limit? */
<span class="fc" id="L263">				stockSpace = comp.getCurrentSpace();</span>
<span class="fc bfc" id="L264" title="All 6 branches covered.">				if ((stockSpace == null || !stockSpace.isNoCertLimit()) &amp;&amp; !mayPlayerBuyCertificate(</span>
<span class="fc" id="L265">						currentPlayer, comp, cert.getCertificateCount())) continue;</span>

<span class="fc bfc" id="L267" title="All 2 branches covered.">				if (!cert.isPresidentShare()) {</span>
<span class="fc" id="L268">					price = comp.getIPOPrice() / unitsForPrice;</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">					if ((price*cert.getShares()) &lt;= playerCash) {</span>
<span class="fc" id="L270">						possibleActions.add(new BuyCertificate(comp, cert.getShare(),</span>
<span class="fc" id="L271">								from.getParent(), price));</span>
					}
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">				} else if (!comp.hasStarted()) {</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">					if (comp.getIPOPrice() != 0) {</span>
<span class="fc" id="L275">						price = comp.getIPOPrice() * cert.getShares() / unitsForPrice;</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">						if (price &lt;= playerCash) {</span>
<span class="fc" id="L277">							possibleActions.add(new StartCompany(comp, price));</span>
						}
					} else {
<span class="fc" id="L280">						List&lt;Integer&gt; startPrices = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">						for (int startPrice : stockMarket.getStartPrices()) {</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">							if (startPrice * cert.getShares()&lt;= playerCash) {</span>
<span class="fc" id="L283">								startPrices.add(startPrice);</span>
							}
<span class="fc" id="L285">						}</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">						if (startPrices.size() &gt; 0) {</span>
<span class="fc" id="L287">							int[] prices = new int[startPrices.size()];</span>
<span class="fc" id="L288">							Arrays.sort(prices);</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">							for (int i = 0; i &lt; prices.length; i++) {</span>
<span class="fc" id="L290">								prices[i] = startPrices.get(i);</span>
							}
<span class="fc" id="L292">							possibleActions.add(new StartCompany(comp, prices));</span>
						}
					}
				}

<span class="fc" id="L297">			}</span>
		}

		/* Get the unique Pool certificates and check which ones can be bought */
<span class="fc" id="L301">		from = pool;</span>
<span class="fc" id="L302">		ImmutableSetMultimap&lt;PublicCompany, PublicCertificate&gt; map =</span>
<span class="fc" id="L303">				from.getCertsPerCompanyMap();</span>
		/* Allow for multiple share unit certificates (e.g. 1835) */
		PublicCertificate[] uniqueCerts;
		int[] numberOfCerts;
		int shares;
		int shareUnit;
		int maxNumberOfSharesToBuy;

<span class="fc bfc" id="L311" title="All 2 branches covered.">		for (PublicCompany comp : map.keySet()) {</span>
<span class="fc" id="L312">			certs = map.get(comp);</span>
			// if (certs.isEmpty()) continue; // TODO: Is this removal correct?

<span class="fc" id="L315">			stockSpace = comp.getCurrentSpace();</span>
<span class="fc" id="L316">			unitsForPrice = comp.getShareUnitsForSharePrice();</span>
<span class="fc" id="L317">			price = stockSpace.getPrice() / unitsForPrice;</span>
<span class="fc" id="L318">			shareUnit = comp.getShareUnit();</span>
<span class="fc" id="L319">			maxNumberOfSharesToBuy</span>
<span class="fc" id="L320">			= maxAllowedNumberOfSharesToBuy(currentPlayer, comp, shareUnit);</span>

			/* Checks if the player can buy any shares of this company */
<span class="fc bfc" id="L323" title="All 2 branches covered.">			if (maxNumberOfSharesToBuy &lt; 1) continue;</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">			if (currentPlayer.hasSoldThisRound(comp)) continue;</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">			if (companyBoughtThisTurn != null) {</span>
				// If a cert was bought before, only brown zone ones can be
				// bought again in the same turn
<span class="nc bnc" id="L328" title="All 2 branches missed.">				if (comp != companyBoughtThisTurn) continue;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">				if (!stockSpace.isNoBuyLimit()) continue;</span>
			}

			/* Check what share multiples are available
			 * Normally only 1, but 1 and 2 in 1835. Allow up to 4.
			 */
<span class="fc" id="L335">			uniqueCerts = new PublicCertificate[5];</span>
<span class="fc" id="L336">			numberOfCerts = new int[5];</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">			for (PublicCertificate cert2 : certs) {</span>
<span class="fc" id="L338">				shares = cert2.getShares();</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">				if (maxNumberOfSharesToBuy &lt; shares) continue;</span>
<span class="fc" id="L340">				numberOfCerts[shares]++;</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">				if (uniqueCerts[shares] != null) continue;</span>
<span class="fc" id="L342">				uniqueCerts[shares] = cert2;</span>
<span class="fc" id="L343">			}</span>

			/* Create a BuyCertificate action per share size */
<span class="fc bfc" id="L346" title="All 2 branches covered.">			for (shares = 1; shares &lt; 5; shares++) {</span>
				/* Only certs in the brown zone may be bought all at once */
<span class="fc" id="L348">				number = numberOfCerts[shares];</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">				if (number == 0) continue;</span>

<span class="pc bpc" id="L351" title="1 of 2 branches missed.">				if (!stockSpace.isNoBuyLimit()) {</span>
<span class="fc" id="L352">					number = 1;</span>
					/* Would the player exceed the per-company share hold limit? */
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">					if (!checkAgainstHoldLimit(currentPlayer, comp, number)) continue;</span>

					/* Would the player exceed the total certificate limit? */
<span class="fc bfc" id="L357" title="All 2 branches covered.">					if (!stockSpace.isNoCertLimit()</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">							&amp;&amp; !mayPlayerBuyCertificate(currentPlayer, comp,</span>
<span class="fc" id="L359">									number * uniqueCerts[shares].getCertificateCount()))</span>
<span class="fc" id="L360">						continue;</span>
				}

				// Does the player have enough cash?
<span class="fc bfc" id="L364" title="All 4 branches covered.">				while (number &gt; 0 &amp;&amp; playerCash &lt; number * price * shares) {</span>
<span class="fc" id="L365">					number--;</span>
				}

<span class="fc bfc" id="L368" title="All 2 branches covered.">				if (number &gt; 0) {</span>
<span class="fc" id="L369">					possibleActions.add(new BuyCertificate(comp,</span>
<span class="fc" id="L370">							uniqueCerts[shares].getShare(),</span>
<span class="fc" id="L371">							from.getParent(), price,</span>
							number));
				}
			}
<span class="fc" id="L375">		}</span>

		// Get any shares in company treasuries that can be bought
<span class="fc bfc" id="L378" title="All 2 branches covered.">		if (gameManager.canAnyCompanyHoldShares()) {</span>

<span class="fc bfc" id="L380" title="All 2 branches covered.">			for (PublicCompany company : companyManager.getAllPublicCompanies()) {</span>
				// TODO: Has to be rewritten (director)
<span class="fc" id="L382">				certs = company.getPortfolioModel().getCertificates(company);</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">				if (certs.isEmpty()) continue;</span>
<span class="fc" id="L384">				cert = Iterables.get(certs, 0);</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">				if (currentPlayer.hasSoldThisRound(company)) continue;</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">				if (!checkAgainstHoldLimit(currentPlayer, company, 1)) continue;</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">				if (maxAllowedNumberOfSharesToBuy(currentPlayer, company,</span>
<span class="pc" id="L388">						cert.getShare()) &lt; 1) continue;</span>
<span class="fc" id="L389">				stockSpace = company.getCurrentSpace();</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">				if (!stockSpace.isNoCertLimit()</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">						&amp;&amp; !mayPlayerBuyCertificate(currentPlayer, company, 1)) continue;</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">				if (company.getMarketPrice() &lt;= playerCash) {</span>
<span class="fc" id="L393">					possibleActions.add(new BuyCertificate(company, cert.getShare(),</span>
<span class="fc" id="L394">							company, company.getMarketPrice()));</span>
				}
<span class="fc" id="L396">			}</span>
		}
<span class="fc" id="L398">	}</span>

	/**
	 * Create a list of certificates that a player may sell in a Stock Round,
	 * taking all rules taken into account.
	 *
	 * @return List of sellable certificates.
	 */

	// FIXME Rails 2.0:
	// This is rewritten taken into account that actions will not be changed for now
	// A change of action will allow to simplify this strongly

	// called by:
	// StockRound: setPossibleActions

	// overridden by:
	// ShareSellingRound
	public void setSellableShares() {

<span class="fc bfc" id="L418" title="All 2 branches covered.">		if (!mayCurrentPlayerSellAnything()) return;</span>

<span class="fc" id="L420">		boolean choiceOfPresidentExchangeCerts = false;</span>
<span class="fc" id="L421">		isOverLimits = false;</span>
<span class="fc" id="L422">		overLimitsDetail = null;</span>

<span class="fc" id="L424">		StringBuilder violations = new StringBuilder();</span>
<span class="fc" id="L425">		PortfolioModel playerPortfolio = currentPlayer.getPortfolioModel();</span>

		/*
		 * First check of which companies the player owns stock, and what
		 * maximum percentage he is allowed to sell.
		 */
<span class="fc bfc" id="L431" title="All 2 branches covered.">		for (PublicCompany company : companyManager.getAllPublicCompanies()) {</span>

			// Check if shares of this company can be sold at all
<span class="fc bfc" id="L434" title="All 2 branches covered.">			if (!mayPlayerSellShareOfCompany(company)) {</span>
<span class="fc" id="L435">				continue;</span>
			}

<span class="fc" id="L438">			int ownedShare = playerPortfolio.getShareNumber(company);</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">			if (ownedShare == 0) {</span>
<span class="fc" id="L440">				continue;</span>
			}

			/* May not sell more than the Pool can accept */
<span class="fc" id="L444">			int poolAllowsShares = PlayerShareUtils.poolAllowsShareNumbers(company);</span>
<span class="fc" id="L445">			log.debug(&quot;company = &quot; + company);</span>
<span class="fc" id="L446">			log.debug(&quot;poolAllowShares = &quot;+ poolAllowsShares);</span>
<span class="fc" id="L447">			int maxShareToSell = Math.min(ownedShare, poolAllowsShares );</span>

			// if no share can be sold
<span class="fc bfc" id="L450" title="All 2 branches covered.">			if (maxShareToSell == 0) {</span>
<span class="fc" id="L451">				continue;</span>
			}

			// Is player over the hold limit of this company?
<span class="fc bfc" id="L455" title="All 2 branches covered.">			if (!checkAgainstHoldLimit(currentPlayer, company, 0)) {</span>
				// The first time this happens, remove all non-over-limits sell options
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">				if (!isOverLimits) possibleActions.clear();</span>
<span class="fc" id="L458">				isOverLimits = true;</span>
<span class="fc" id="L459">				violations.append(LocalText.getText(&quot;ExceedCertificateLimitCompany&quot;,</span>
<span class="fc" id="L460">						company.getId(),</span>
<span class="fc" id="L461">						playerPortfolio.getShare(company),</span>
<span class="fc" id="L462">						GameDef.getGameParameterAsInt(this, GameDef.Parm.PLAYER_SHARE_LIMIT)</span>
						));

			} else {
				// If within limits, but an over-limits situation exists: correct that first.
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">				if (isOverLimits) continue;</span>
			}

			/*
			 * If the current Player is president, check if there is a play to dump on
			 * =&gt; dumpThreshold = how many shareNumbers have to be sold for dump
			 * =&gt; possibleSharesToSell = list of shareNumbers that can be sold
			 *    (includes check for swapping the presidency)
			 * =&gt; dumpIsPossible = true
			 */
<span class="fc" id="L477">			int dumpThreshold = 0;</span>
<span class="fc" id="L478">			SortedSet&lt;Integer&gt; possibleSharesToSell = null;</span>
<span class="fc" id="L479">			boolean dumpIsPossible = false;</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">			if (company.getPresident() == currentPlayer) {</span>
<span class="fc" id="L481">				Player potential = company.findPlayerToDump();</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">				if (potential != null) {</span>
<span class="fc" id="L483">					dumpThreshold = ownedShare - potential.getPortfolioModel().getShareNumber(company) + 1;</span>
<span class="fc" id="L484">					possibleSharesToSell = PlayerShareUtils.sharesToSell(company, currentPlayer);</span>
<span class="fc" id="L485">					dumpIsPossible = true;</span>
<span class="fc" id="L486">					log.debug(&quot;dumpThreshold = &quot; + dumpThreshold);</span>
<span class="fc" id="L487">					log.debug(&quot;possibleSharesToSell = &quot; + possibleSharesToSell);</span>
<span class="fc" id="L488">					log.debug(&quot;dumpIsPossible = &quot; + dumpIsPossible);</span>
				}
			}

			/*
			 * Check what share units the player actually owns. In some games
			 * (e.g. 1835) companies may have different ordinary shares: 5% and
			 * 10%, or 10% and 20%. The president's share counts as a multiple
			 * of the smallest ordinary share unit type.
			 */


			// Check the price. If a cert was sold before this turn, the original price is still valid.
<span class="fc" id="L501">			int price = getCurrentSellPrice(company);</span>

			/* Allow for different share units (as in 1835) */
<span class="fc" id="L504">			SortedMultiset&lt;Integer&gt; certCount = playerPortfolio.getCertificateTypeCounts(company);</span>

			// Make sure that single shares are always considered (due to possible dumping)
<span class="fc" id="L507">			SortedSet&lt;Integer&gt; certSizeElements =Sets.newTreeSet(certCount.elementSet());</span>
<span class="fc" id="L508">			certSizeElements.add(1);</span>

<span class="fc bfc" id="L510" title="All 2 branches covered.">			for (int shareSize:certSizeElements) {</span>
<span class="fc" id="L511">				int number = certCount.count(shareSize);</span>

				// If you can dump a presidency, you add the shareNumbers of the presidency
				// to the single shares to be sold
<span class="fc bfc" id="L515" title="All 6 branches covered.">				if (dumpIsPossible &amp;&amp; shareSize == 1 &amp;&amp; number + company.getPresidentsShare().getShares() &gt;= dumpThreshold) {</span>
<span class="fc" id="L516">					number += company.getPresidentsShare().getShares();</span>
					// but limit this to the pool
<span class="fc" id="L518">					number = Math.min(number, poolAllowsShares);</span>
<span class="fc" id="L519">					log.debug(&quot;Dump is possible increased single shares to &quot; + number);</span>
				}

<span class="fc bfc" id="L522" title="All 2 branches covered.">				if (number == 0) {</span>
<span class="fc" id="L523">					continue;</span>
				}

				/* In some games (1856), a just bought share may not be sold */
				// This code ignores the possibility of different share units
<span class="fc bfc" id="L528" title="All 2 branches covered.">				if ((Boolean)gameManager.getGameParameter(GameDef.Parm.NO_SALE_OF_JUST_BOUGHT_CERT)</span>
<span class="fc bfc" id="L529" title="All 4 branches covered.">						&amp;&amp; company.equals(companyBoughtThisTurnWrapper.value())</span>
						/* An 1856 clarification by Steve Thomas (backed by Bill Dixon) states that
						 * in this situation a half-presidency may be sold
						 * (apparently even if a dump would otherwise not be allowed),
						 * as long as the number of shares does not become zero.
						 * So the rule &quot;can't sell a just bought share&quot; only means,
						 * that the number of shares may not be sold down to zero.
						 * Added 4jun2012 by EV */
						&amp;&amp; number == ownedShare) {
<span class="fc" id="L538">					number--;</span>
				}

<span class="fc bfc" id="L541" title="All 2 branches covered.">				if (number &lt;= 0) {</span>
<span class="fc" id="L542">					continue;</span>
				}

				// Check against the maximum share that can be sold
<span class="fc" id="L546">				number = Math.min(number, maxShareToSell / shareSize);</span>

<span class="fc bfc" id="L548" title="All 2 branches covered.">				if (number &lt;= 0) {</span>
<span class="fc" id="L549">					continue;</span>
				}

<span class="fc bfc" id="L552" title="All 2 branches covered.">				for (int i=1; i&lt;=number; i++) {</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">					if(checkIfSplitSaleOfPresidentAllowed()) {</span>
						// check if selling would dump the company
<span class="fc bfc" id="L555" title="All 4 branches covered.">						if (dumpIsPossible &amp;&amp; i*shareSize &gt;= dumpThreshold) {</span>
							// dumping requires that the total is in the possibleSharesToSell list and that shareSize == 1
							// multiple shares have to be sold separately
<span class="pc bpc" id="L558" title="2 of 4 branches missed.">							if (shareSize == 1 &amp;&amp; possibleSharesToSell.contains(i*shareSize)) {</span>
<span class="fc" id="L559">								possibleActions.add(new SellShares(company, shareSize, i, price, 1));</span>
							}
						} else {
							// ... no dumping: standard sell
<span class="fc" id="L563">							possibleActions.add(new SellShares(company, shareSize, i, price, 0));</span>
						}
					}
					else {
<span class="fc bfc" id="L567" title="All 4 branches covered.">						if (dumpIsPossible &amp;&amp; i*shareSize &gt;= dumpThreshold) {</span>
<span class="fc bfc" id="L568" title="All 4 branches covered.">							if ( certCount.isEmpty() &amp;&amp; number == 2) {</span>

<span class="fc" id="L570">								possibleActions.add(new SellShares(company, 2, 1, price, 1));</span>
							}
							else {
<span class="fc bfc" id="L573" title="All 6 branches covered.">								if (((!certCount.isEmpty()) &amp;&amp; (number ==1) ) || number &gt;2) {</span>
<span class="fc" id="L574">									possibleActions.add(new SellShares(company, shareSize, i, price, 1));</span>
								}
							}
						}
						else {
<span class="fc" id="L579">							possibleActions.add(new SellShares(company, shareSize, i, price, 0));</span>
						}
					}
				}
<span class="fc" id="L583">			}</span>
<span class="fc" id="L584">		}</span>



		// Is player over the total certificate hold limit?
<span class="fc" id="L589">		float certificateCount = playerPortfolio.getCertificateCount();</span>
<span class="fc" id="L590">		int certificateLimit = gameManager.getPlayerCertificateLimit(currentPlayer);</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">		if (certificateCount &gt; certificateLimit) {</span>
<span class="fc" id="L592">			violations.append(LocalText.getText(&quot;ExceedCertificateLimitTotal&quot;,</span>
<span class="fc" id="L593">					certificateCount,</span>
<span class="fc" id="L594">					certificateLimit));</span>
<span class="fc" id="L595">			isOverLimits = true;</span>
		}

<span class="fc bfc" id="L598" title="All 2 branches covered.">		if (isOverLimits) {</span>
<span class="fc" id="L599">			DisplayBuffer.add(this, LocalText.getText(&quot;ExceedCertificateLimit&quot;</span>
<span class="fc" id="L600">					, currentPlayer.getId()</span>
<span class="fc" id="L601">					, violations.toString()</span>
					));
		}
<span class="fc" id="L604">	}</span>

	protected boolean checkIfSplitSaleOfPresidentAllowed() {
		// To be overwritten in Stockround Classes for games where that is not allowed e.g. 1835
<span class="fc" id="L608">		return true;</span>
	}

	// called by:
	// StockRound: setPossibleActions

	// not overridden
	protected void setSpecialActions() {

<span class="fc" id="L617">		List&lt;SpecialProperty&gt; sps =</span>
<span class="fc" id="L618">				currentPlayer.getPortfolioModel().getSpecialProperties(</span>
						SpecialProperty.class, false);
<span class="fc bfc" id="L620" title="All 2 branches covered.">		for (SpecialProperty sp : sps) {</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">			if (sp.isUsableDuringSR()) {</span>
<span class="fc" id="L622">				possibleActions.add(new UseSpecialProperty(sp));</span>
			}
<span class="fc" id="L624">		}</span>
<span class="fc" id="L625">	}</span>

	/*----- METHODS THAT PROCESS PLAYER ACTIONS -----*/
	// called by:
	// GameManager: process, processOnReload
	// StockRound 1880: (process)
	// ShareSellingRound 1880: (process)

	// overridden by
	// StockRound 1880
	// ShareSellingRound 1880
	@Override
	public boolean process(PossibleAction action) {

<span class="fc" id="L639">		boolean result = false;</span>
<span class="fc" id="L640">		String playerName = action.getPlayerName();</span>
<span class="fc" id="L641">		currentPlayer = playerManager.getCurrentPlayer();</span>

<span class="fc bfc" id="L643" title="All 2 branches covered.">		if (action instanceof NullAction) {</span>

<span class="fc" id="L645">			NullAction nullAction = (NullAction) action;</span>
<span class="pc bpc" id="L646" title="1 of 3 branches missed.">			switch (nullAction.getMode()) {</span>
			case PASS:
			case DONE:
<span class="fc" id="L649">				result = done((NullAction)action, playerName, false);</span>
<span class="fc" id="L650">				break;</span>
			case AUTOPASS:
<span class="fc" id="L652">				result = done(null, playerName, true);</span>
<span class="fc" id="L653">				break;</span>
			default:
				break;
			}

<span class="fc bfc" id="L658" title="All 2 branches covered.">		} else if (action instanceof StartCompany) {</span>

<span class="fc" id="L660">			StartCompany startCompanyAction = (StartCompany) action;</span>

<span class="fc" id="L662">			result = startCompany(playerName, startCompanyAction);</span>

<span class="fc bfc" id="L664" title="All 2 branches covered.">		} else if (action instanceof BuyCertificate) {</span>

<span class="fc" id="L666">			result = buyShares(playerName, (BuyCertificate) action);</span>

<span class="fc bfc" id="L668" title="All 2 branches covered.">		} else if (action instanceof SellShares) {</span>

<span class="fc" id="L670">			result = sellShares((SellShares) action);</span>

<span class="fc bfc" id="L672" title="All 2 branches covered.">		} else if (action instanceof UseSpecialProperty) {</span>

<span class="fc" id="L674">			result = useSpecialProperty((UseSpecialProperty) action);</span>

<span class="fc bfc" id="L676" title="All 2 branches covered.">		} else if (action instanceof RequestTurn) {</span>

<span class="fc" id="L678">			result = requestTurn ((RequestTurn)action);</span>

<span class="pc bpc" id="L680" title="1 of 2 branches missed.">		} else if (!!(result = processGameSpecificAction(action))) {</span>

		} else {

<span class="nc" id="L684">			DisplayBuffer.add(this, LocalText.getText(&quot;UnexpectedAction&quot;,</span>
<span class="nc" id="L685">					action.toString()));</span>
		}

<span class="fc" id="L688">		return result;</span>
	}

	// Return value indicates whether the action has been processed.
	// called by:
	// StockRound: process

	// overridden by:
	// StockRound 1837, 18EU
	// PrussianFormationRound, NationalFormationRound
	protected boolean processGameSpecificAction(PossibleAction action) {

<span class="nc" id="L700">		return false;</span>
	}

	/**
	 * Start a company by buying one or more shares (more applies to e.g. 1841)
	 *
	 * @param player The player that wants to start a company.
	 * @param company The company to start.
	 * @param price The start (par) price (ignored if the price is fixed).
	 * @param shares The number of shares to buy (can be more than 1 in e.g.
	 * 1841).
	 * @return True if the company could be started. False indicates an error.
	 */
	// called by:
	// StockRound: process
	// StockRound 1880: startCompany (not overridden!)

	// overridden by:
	// StockRound 18EU
	public boolean startCompany(String playerName, StartCompany action) {
<span class="fc" id="L720">		PublicCompany company = action.getCompany();</span>
<span class="fc" id="L721">		int price = action.getPrice();</span>
<span class="fc" id="L722">		int shares = action.getNumberBought();</span>

<span class="fc" id="L724">		String errMsg = null;</span>
<span class="fc" id="L725">		StockSpace startSpace = null;</span>
<span class="fc" id="L726">		int numberOfCertsToBuy = 0;</span>
<span class="fc" id="L727">		PublicCertificate cert = null;</span>
<span class="fc" id="L728">		String companyName = company.getId();</span>
<span class="fc" id="L729">		int cost = 0;</span>

<span class="fc" id="L731">		currentPlayer = playerManager.getCurrentPlayer();</span>

		// Dummy loop to allow a quick jump out
		while (true) {

			// Check everything
			// Only the player that has the turn may buy
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">			if (!playerName.equals(currentPlayer.getId())) {</span>
<span class="nc" id="L739">				errMsg = LocalText.getText(&quot;WrongPlayer&quot;, playerName, currentPlayer.getId());</span>
<span class="nc" id="L740">				break;</span>
			}

			// The player may not have bought this turn.
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">			if (companyBoughtThisTurnWrapper.value() != null) {</span>
<span class="nc" id="L745">				errMsg = LocalText.getText(&quot;AlreadyBought&quot;, playerName);</span>
<span class="nc" id="L746">				break;</span>
			}

			// Check company
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">			if (company == null) {</span>
<span class="nc" id="L751">				errMsg = LocalText.getText(&quot;CompanyDoesNotExist&quot;, companyName);</span>
<span class="nc" id="L752">				break;</span>
			}
			// The company may not have started yet.
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">			if (company.hasStarted()) {</span>
<span class="nc" id="L756">				errMsg =</span>
<span class="nc" id="L757">						LocalText.getText(&quot;CompanyAlreadyStarted&quot;, companyName);</span>
<span class="nc" id="L758">				break;</span>
			}

			// Find the President's certificate
<span class="fc" id="L762">			cert = ipo.findCertificate(company, true);</span>
			// Make sure that we buy at least one!
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">			if (shares &lt; cert.getShares()) shares = cert.getShares();</span>

			// Determine the number of Certificates to buy
			// (shortcut: assume that any additional certs are one share each)
<span class="fc" id="L768">			numberOfCertsToBuy = shares - (cert.getShares() - 1);</span>
			// Check if the player may buy that many certificates.
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">			if (!mayPlayerBuyCertificate(currentPlayer, company, numberOfCertsToBuy)) {</span>
<span class="nc" id="L771">				errMsg = LocalText.getText(&quot;CantBuyMoreCerts&quot;);</span>
<span class="nc" id="L772">				break;</span>
			}

			// Check if the company has a fixed par price (1835).
<span class="fc" id="L776">			startSpace = company.getStartSpace();</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">			if (startSpace != null) {</span>
				// If so, it overrides whatever is given.
<span class="fc" id="L779">				price = startSpace.getPrice();</span>
			} else {
				// Else the given price must be a valid start price
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">				if ((startSpace = stockMarket.getStartSpace(price)) == null) {</span>
<span class="nc" id="L783">					errMsg = LocalText.getText(&quot;InvalidStartPrice&quot;,</span>
<span class="nc" id="L784">							Bank.format(this, price),</span>
<span class="nc" id="L785">							company.getId() );</span>
<span class="nc" id="L786">					break;</span>
				}
			}

			// Check if the Player has the money.
<span class="fc" id="L791">			cost = shares * price;</span>
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">			if (currentPlayer.getCashValue() &lt; cost) {</span>
<span class="nc" id="L793">				errMsg = LocalText.getText(&quot;NoMoney&quot;);</span>
				break;
			}

			break;
		}

<span class="pc bpc" id="L800" title="1 of 2 branches missed.">		if (errMsg != null) {</span>
<span class="nc" id="L801">			DisplayBuffer.add(this, LocalText.getText(&quot;CantStart&quot;,</span>
					playerName,
					companyName,
<span class="nc" id="L804">					Bank.format(this, price),</span>
					errMsg ));
<span class="nc" id="L806">			return false;</span>
		}



		// All is OK, now start the company
<span class="fc" id="L812">		company.start(startSpace);</span>

<span class="fc" id="L814">		MoneyOwner priceRecipient = getSharePriceRecipient (company, ipo.getParent(), price);</span>

		// Transfer the President's certificate
<span class="fc" id="L817">		cert.moveTo(currentPlayer);</span>

		// If more than one certificate is bought at the same time, transfer
		// these too.
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">		for (int i = 1; i &lt; numberOfCertsToBuy; i++) {</span>
<span class="nc" id="L822">			cert = ipo.findCertificate(company, false);</span>
<span class="nc" id="L823">			cert.moveTo(currentPlayer);</span>
		}

		// Pay for these shares
<span class="fc" id="L827">		String costText = Currency.wire(currentPlayer, cost, priceRecipient);</span>

<span class="fc" id="L829">		ReportBuffer.add(this, LocalText.getText(&quot;START_COMPANY_LOG&quot;,</span>
				playerName,
				companyName,
<span class="fc" id="L832">				bank.getCurrency().format(price), // TODO: Do this nicer</span>
				costText,
<span class="fc" id="L834">				shares,</span>
<span class="fc" id="L835">				cert.getShare(),</span>
<span class="fc" id="L836">				priceRecipient.getId() ));</span>
<span class="fc" id="L837">		ReportBuffer.getAllWaiting(this);</span>

<span class="fc" id="L839">		checkFlotation(company);</span>

<span class="fc" id="L841">		companyBoughtThisTurnWrapper.set(company);</span>
<span class="fc" id="L842">		hasActed.set(true);</span>
<span class="fc" id="L843">		setPriority(&quot;StartCompany&quot;);</span>

		// Check for any game-specific consequences
		// (such as making another company available in the IPO)
<span class="fc" id="L847">		gameSpecificChecks(ipo, company);</span>

<span class="fc" id="L849">		return true;</span>
	}

	/**
	 * Buying one or more single or double-share certificates (more is sometimes
	 * possible)
	 *
	 * @param player The player that wants to buy shares.
	 * @param action The executed BuyCertificates action
	 * @return True if the certificates could be bought. False indicates an
	 * error.
	 */
	// called by:
	// StockRound: process

	// overriden by:
	// TreasuryShareRound
	public boolean buyShares(String playerName, BuyCertificate action) {

<span class="fc" id="L868">		PublicCompany company = action.getCompany();</span>
<span class="fc" id="L869">		PortfolioModel from = action.getFromPortfolio();</span>
<span class="fc" id="L870">		String companyName = company.getId();</span>
<span class="fc" id="L871">		int number = action.getNumberBought();</span>
<span class="fc" id="L872">		int shareUnit = company.getShareUnit();</span>
<span class="fc" id="L873">		int sharePerCert = action.getSharePerCertificate();</span>
<span class="fc" id="L874">		int share = number * sharePerCert;</span>
<span class="fc" id="L875">		int shares = share / shareUnit;</span>

<span class="fc" id="L877">		String errMsg = null;</span>
<span class="fc" id="L878">		int price = 0;</span>
<span class="fc" id="L879">		int cost = 0;</span>

<span class="fc" id="L881">		currentPlayer = playerManager.getCurrentPlayer();</span>

		// Dummy loop to allow a quick jump out
		while (true) {

			// Check everything
			// Only the player that has the turn may buy
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">			if (!playerName.equals(currentPlayer.getId())) {</span>
<span class="nc" id="L889">				errMsg = LocalText.getText(&quot;WrongPlayer&quot;, playerName, currentPlayer.getId());</span>
<span class="nc" id="L890">				break;</span>
			}

			// Check company
<span class="fc" id="L894">			company = companyManager.getPublicCompany(companyName);</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">			if (company == null) {</span>
<span class="nc" id="L896">				errMsg = LocalText.getText(&quot;CompanyDoesNotExist&quot;, companyName);</span>
<span class="nc" id="L897">				break;</span>
			}

			// The player may not have sold the company this round.
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">			if (currentPlayer.hasSoldThisRound(company)) {</span>
<span class="nc" id="L902">				errMsg =</span>
<span class="nc" id="L903">						LocalText.getText(&quot;AlreadySoldThisTurn&quot;,</span>
<span class="nc" id="L904">								currentPlayer.getId(),</span>
								companyName );
<span class="nc" id="L906">				break;</span>
			}

<span class="pc bpc" id="L909" title="1 of 2 branches missed.">			if (!company.isBuyable()) {</span>
<span class="nc" id="L910">				errMsg = LocalText.getText(&quot;NotYetStarted&quot;, companyName);</span>
<span class="nc" id="L911">				break;</span>
			}

			// The player may not have bought this turn, unless the company
			// bought before and now is in the brown area.
<span class="fc" id="L916">			PublicCompany companyBoughtThisTurn =</span>
<span class="fc" id="L917">					(PublicCompany) companyBoughtThisTurnWrapper.value();</span>
<span class="pc bpc" id="L918" title="3 of 4 branches missed.">			if (companyBoughtThisTurn != null</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">					&amp;&amp; (companyBoughtThisTurn != company || !company.getCurrentSpace().isNoBuyLimit())) {</span>
<span class="nc" id="L920">				errMsg = LocalText.getText(&quot;AlreadyBought&quot;, playerName);</span>
<span class="nc" id="L921">				break;</span>
			}

			// Check if that many shares are available
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">			if (shares &gt; from.getShare(company)) {</span>
<span class="nc" id="L926">				errMsg =</span>
<span class="nc" id="L927">						LocalText.getText(&quot;NotAvailable&quot;,</span>
								companyName,
<span class="nc" id="L929">								from.getId() );</span>
<span class="nc" id="L930">				break;</span>
			}

			StockSpace currentSpace;
<span class="fc bfc" id="L934" title="All 4 branches covered.">			if (from == ipo &amp;&amp; company.hasParPrice()) {</span>
<span class="fc" id="L935">				currentSpace = company.getStartSpace();</span>
			} else {
<span class="fc" id="L937">				currentSpace = company.getCurrentSpace();</span>
			}

			// Check if it is allowed to buy more than one certificate (if
			// requested)
<span class="pc bpc" id="L942" title="3 of 4 branches missed.">			if (number &gt; 1 &amp;&amp; !currentSpace.isNoBuyLimit()) {</span>
<span class="nc" id="L943">				errMsg = LocalText.getText(&quot;CantBuyMoreThanOne&quot;, companyName);</span>
<span class="nc" id="L944">				break;</span>
			}

			// Check if player would not exceed the certificate limit.
			// (shortcut: assume 1 cert == 1 certificate)
<span class="fc" id="L949">			PublicCertificate cert = from.findCertificate(company, sharePerCert/shareUnit, false);</span>
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">			if (cert == null) {</span>
<span class="nc" id="L951">				log.error(&quot;Cannot find &quot;+sharePerCert+&quot;% of &quot;+company.getId()+&quot; in &quot;+from.getId());</span>
			}
<span class="fc bfc" id="L953" title="All 2 branches covered.">			if (!currentSpace.isNoCertLimit()</span>
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">					&amp;&amp; !mayPlayerBuyCertificate(currentPlayer, company, number * cert.getCertificateCount())) {</span>
<span class="nc" id="L955">				errMsg =</span>
<span class="nc" id="L956">						currentPlayer.getId()</span>
<span class="nc" id="L957">						+ LocalText.getText(&quot;WouldExceedCertLimit&quot;,</span>
<span class="nc" id="L958">								String.valueOf(gameManager.getPlayerCertificateLimit(currentPlayer)));</span>
<span class="nc" id="L959">				break;</span>
			}

			// Check if player would exceed the per-company share limit
<span class="fc bfc" id="L963" title="All 2 branches covered.">			if (!currentSpace.isNoHoldLimit()</span>
<span class="pc bpc" id="L964" title="1 of 2 branches missed.">					&amp;&amp; !checkAgainstHoldLimit(currentPlayer, company, shares)) {</span>
<span class="nc" id="L965">				errMsg = LocalText.getText(&quot;WouldExceedHoldLimit&quot;,</span>
<span class="nc" id="L966">						currentPlayer.getId(),</span>
<span class="nc" id="L967">						GameDef.Parm.PLAYER_SHARE_LIMIT.defaultValueAsInt());</span>
<span class="nc" id="L968">				break;</span>
			}

<span class="fc" id="L971">			price = getBuyPrice (action, currentSpace);</span>
<span class="fc" id="L972">			cost = shares * price / company.getShareUnitsForSharePrice();</span>

			// Check if the Player has the money.
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">			if (currentPlayer.getCashValue() &lt; cost) {</span>
<span class="nc" id="L976">				errMsg = LocalText.getText(&quot;NoMoney&quot;);</span>
<span class="nc" id="L977">				break;</span>
			}

			break;
		}

<span class="pc bpc" id="L983" title="1 of 2 branches missed.">		if (errMsg != null) {</span>
<span class="nc" id="L984">			DisplayBuffer.add(this, LocalText.getText(&quot;CantBuy&quot;,</span>
					playerName,
<span class="nc" id="L986">					shares,</span>
					companyName,
<span class="nc" id="L988">					from.getId(),</span>
					errMsg ));
<span class="nc" id="L990">			return false;</span>
		}

		// All seems OK, now buy the shares.


<span class="fc" id="L996">		MoneyOwner priceRecipient = getSharePriceRecipient(company, from.getParent(), cost);</span>

<span class="pc bpc" id="L998" title="1 of 2 branches missed.">		if (number == 1) {</span>
<span class="fc" id="L999">			ReportBuffer.add(this, LocalText.getText(&quot;BUY_SHARE_LOG&quot;,</span>
					playerName,
<span class="fc" id="L1001">					share,</span>
					companyName,
<span class="fc" id="L1003">					from.getName(),</span>
<span class="fc" id="L1004">					Bank.format(this, cost) ));</span>
		} else {
<span class="nc" id="L1006">			ReportBuffer.add(this, LocalText.getText(&quot;BUY_SHARES_LOG&quot;,</span>
					playerName,
<span class="nc" id="L1008">					number,</span>
<span class="nc" id="L1009">					share,</span>
<span class="nc" id="L1010">					shares,</span>
					companyName,
<span class="nc" id="L1012">					from.getName(),</span>
<span class="nc" id="L1013">					Bank.format(this, cost) ));</span>
		}
<span class="fc" id="L1015">		ReportBuffer.getAllWaiting(this );</span>

		PublicCertificate cert2;
<span class="fc bfc" id="L1018" title="All 2 branches covered.">		for (int i = 0; i &lt; number; i++) {</span>
<span class="fc" id="L1019">			cert2 = from.findCertificate(company, sharePerCert/shareUnit, false);</span>
<span class="pc bpc" id="L1020" title="1 of 2 branches missed.">			if (cert2 == null) {</span>
<span class="nc" id="L1021">				log.error(&quot;Cannot find &quot; + companyName + &quot; &quot; + shareUnit*sharePerCert</span>
<span class="nc" id="L1022">						+ &quot;% share in &quot; + from.getId());</span>
			}
<span class="fc" id="L1024">			cert2.moveTo(currentPlayer);</span>
		}

<span class="fc" id="L1027">		String costText = Currency.wire(currentPlayer, cost, priceRecipient);</span>
<span class="fc bfc" id="L1028" title="All 2 branches covered.">		if (priceRecipient != from.getMoneyOwner()) {</span>
<span class="fc" id="L1029">			ReportBuffer.add(this, LocalText.getText(&quot;PriceIsPaidTo&quot;,</span>
					costText,
<span class="fc" id="L1031">					priceRecipient.getId() ));</span>
		}

<span class="fc" id="L1034">		companyBoughtThisTurnWrapper.set(company);</span>
<span class="fc" id="L1035">		hasActed.set(true);</span>
<span class="fc" id="L1036">		setPriority(&quot;BuyCert&quot;);</span>

		// Check if presidency has changed
<span class="fc" id="L1039">		company.checkPresidencyOnBuy(currentPlayer);</span>

		// Check if the company has floated
<span class="fc bfc" id="L1042" title="All 2 branches covered.">		if (!company.hasFloated()) checkFlotation(company);</span>

		// Check for any game-specific consequences
		// (such as making another company available in the IPO)
<span class="fc" id="L1046">		gameSpecificChecks(from, company);</span>

<span class="fc" id="L1048">		return true;</span>
	}

	/** Stub, may be overridden in subclasses */
	// called by:
	// StockRound: buyShares, startCompany
	// StockRound 1880: (gameSpecificChecks)

	// overridden by:
	// StockRound 1825, 1835, 1856, 1880

	protected void gameSpecificChecks(PortfolioModel boughtFrom,
			PublicCompany company) {

<span class="fc" id="L1062">	}</span>

	/** Allow different price setting in subclasses (i.e. 1835 Nationalisation) */
	// called by:
	// StockRound: buyShares

	// overridden by:
	// StockRound 1835

	protected int getBuyPrice (BuyCertificate action, StockSpace currentSpace) {
<span class="fc" id="L1072">		return currentSpace.getPrice();</span>
	}

	/**
	 * Who receives the cash when a certificate is bought.
	 * With incremental capitalization, this can be the company treasure.
	 * This method must be called &lt;i&gt;before&lt;/i&gt; transferring the certificate.
	 * @param cert
	 * @return
	 */
	// called by:
	// StockRound: buyShares, startCompany

	// overridden by:
	// StockRound 1856
	protected MoneyOwner getSharePriceRecipient (PublicCompany comp,
			Owner from, int price) {

		MoneyOwner recipient;
<span class="fc bfc" id="L1091" title="All 2 branches covered.">		if (comp.hasFloated()</span>
<span class="fc bfc" id="L1092" title="All 2 branches covered.">				&amp;&amp; from == ipo.getParent()</span>
<span class="fc bfc" id="L1093" title="All 2 branches covered.">				&amp;&amp; comp.getCapitalisation() == PublicCompany.CAPITALISE_INCREMENTAL) {</span>
<span class="fc" id="L1094">			recipient = comp;</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">		} else if (from instanceof BankPortfolio) {</span>
<span class="fc" id="L1096">			recipient = bank;</span>
		} else {
<span class="fc" id="L1098">			recipient = (MoneyOwner)from;</span>
		}
<span class="fc" id="L1100">		return recipient;</span>
	}

	/** Make the certificates of one company available for buying
	 * by putting these in the IPO.
	 * @param company The company to be released.
	 */
	// called by:
	// StockRound 1825, 1835: gameSpecificChecks

	// not overridden
	protected void releaseCompanyShares(PublicCompany company) {
<span class="fc" id="L1112">		Portfolio.moveAll(unavailable.getCertificates(company), ipo.getParent());</span>
<span class="fc" id="L1113">	}</span>

	// called by:
	// StockRound: process
	// StockRound 1880: (sellsShares)

	// overridden by:
	// ShareSellingRound
	// TreasuryShareRound
	// StockRound 1880
	// ShareSellingRound 1880
	public boolean sellShares(SellShares action)
	// NOTE: Don't forget to keep ShareSellingRound.sellShares() in sync
	{

<span class="fc" id="L1128">		PortfolioModel portfolio = currentPlayer.getPortfolioModel();</span>
<span class="fc" id="L1129">		String playerName = currentPlayer.getId();</span>
<span class="fc" id="L1130">		String errMsg = null;</span>
<span class="fc" id="L1131">		String companyName = action.getCompanyName();</span>
<span class="fc" id="L1132">		PublicCompany company =</span>
<span class="fc" id="L1133">				companyManager.getPublicCompany(action.getCompanyName());</span>
<span class="fc" id="L1134">		PublicCertificate presCert = null;</span>
<span class="fc" id="L1135">		List&lt;PublicCertificate&gt; certsToSell =</span>
				new ArrayList&lt;PublicCertificate&gt;();
<span class="fc" id="L1137">		Player dumpedPlayer = null;</span>
<span class="fc" id="L1138">		int presidentShareNumbersToSell = 0;</span>
<span class="fc" id="L1139">		int numberToSell = action.getNumber();</span>
<span class="fc" id="L1140">		int shareUnits = action.getShareUnits();</span>

		// Dummy loop to allow a quick jump out
		while (true) {

			// Check everything
<span class="pc bpc" id="L1146" title="1 of 2 branches missed.">			if (checkFirstRoundSellRestriction()) {</span>
<span class="nc" id="L1147">				errMsg = LocalText.getText(&quot;FirstSRNoSell&quot;);</span>
<span class="nc" id="L1148">				break;</span>
			}
<span class="pc bpc" id="L1150" title="1 of 2 branches missed.">			if (numberToSell &lt;= 0) {</span>
<span class="nc" id="L1151">				errMsg = LocalText.getText(&quot;NoSellZero&quot;);</span>
<span class="nc" id="L1152">				break;</span>
			}

			// May not sell in certain cases
<span class="pc bpc" id="L1156" title="1 of 2 branches missed.">			if (!mayCurrentPlayerSellAnything()) {</span>
<span class="nc" id="L1157">				errMsg = LocalText.getText(&quot;SoldEnough&quot;);</span>
<span class="nc" id="L1158">				break;</span>
			}

			// Check company
<span class="pc bpc" id="L1162" title="1 of 2 branches missed.">			if (company == null) {</span>
<span class="nc" id="L1163">				errMsg = LocalText.getText(&quot;NoCompany&quot;);</span>
<span class="nc" id="L1164">				break;</span>
			}

			// May player sell this company
<span class="pc bpc" id="L1168" title="1 of 2 branches missed.">			if (!mayPlayerSellShareOfCompany(company)) {</span>
<span class="nc" id="L1169">				errMsg = LocalText.getText(&quot;SaleNotAllowed&quot;, companyName);</span>
<span class="nc" id="L1170">				break;</span>
			}

			// The player must have the share(s)
<span class="pc bpc" id="L1174" title="1 of 2 branches missed.">			if (portfolio.getShare(company) &lt; numberToSell) {</span>
<span class="nc" id="L1175">				errMsg = LocalText.getText(&quot;NoShareOwned&quot;);</span>
<span class="nc" id="L1176">				break;</span>
			}

			// The pool may not get over its limit.
<span class="fc" id="L1180">			if (pool.getShare(company) + numberToSell * company.getShareUnit()</span>
<span class="pc bpc" id="L1181" title="1 of 2 branches missed.">			&gt; GameDef.getGameParameterAsInt(this, GameDef.Parm.POOL_SHARE_LIMIT)) {</span>
<span class="nc" id="L1182">				errMsg = LocalText.getText(&quot;PoolOverHoldLimit&quot;);</span>
<span class="nc" id="L1183">				break;</span>
			}

			// Find the certificates to sell

			// ... check if there is a dump required
			// Player is president =&gt; dump is possible
<span class="fc bfc" id="L1190" title="All 4 branches covered.">			if (currentPlayer == company.getPresident() &amp;&amp; shareUnits == 1) {</span>
<span class="fc" id="L1191">				dumpedPlayer = company.findPlayerToDump();</span>
<span class="fc bfc" id="L1192" title="All 2 branches covered.">				if (dumpedPlayer != null) {</span>
<span class="fc" id="L1193">					presidentShareNumbersToSell = PlayerShareUtils.presidentShareNumberToSell(</span>
							company, currentPlayer, dumpedPlayer, numberToSell);
					// reduce the numberToSell by the president (partial) sold certificate
<span class="fc" id="L1196">					numberToSell -= presidentShareNumbersToSell;</span>
				}
			}
			else {
<span class="pc bpc" id="L1200" title="1 of 4 branches missed.">				if (currentPlayer == company.getPresident() &amp;&amp; shareUnits == 2) {</span>
<span class="fc" id="L1201">					dumpedPlayer = company.findPlayerToDump();</span>
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">					if (dumpedPlayer != null) {</span>
<span class="fc" id="L1203">						presidentShareNumbersToSell = PlayerShareUtils.presidentShareNumberToSell(</span>
								company, currentPlayer, dumpedPlayer, numberToSell+1);
						// reduce the numberToSell by the president (partial) sold certificate
<span class="fc" id="L1206">						numberToSell -= presidentShareNumbersToSell;</span>
					}
				}
			}

<span class="fc" id="L1211">			certsToSell = PlayerShareUtils.findCertificatesToSell(company, currentPlayer, numberToSell, shareUnits);</span>

			// reduce numberToSell to double check
<span class="fc bfc" id="L1214" title="All 2 branches covered.">			for (PublicCertificate c:certsToSell) {</span>
<span class="fc" id="L1215">				numberToSell -= c.getShares();</span>
<span class="fc" id="L1216">			}</span>

			// Check if we could sell them all
<span class="pc bpc" id="L1219" title="1 of 2 branches missed.">			if (numberToSell &gt; 0) {</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">				if (presCert != null) {</span>
<span class="nc" id="L1221">					errMsg = LocalText.getText(&quot;NoDumping&quot;);</span>
				} else {
<span class="nc" id="L1223">					errMsg = LocalText.getText(&quot;NotEnoughShares&quot;);</span>
				}
				break;
			}

			break;
		}

<span class="fc" id="L1231">		int numberSold = action.getNumber();</span>
<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">		if (errMsg != null) {</span>
<span class="nc" id="L1233">			DisplayBuffer.add(this, LocalText.getText(&quot;CantSell&quot;,</span>
					playerName,
<span class="nc" id="L1235">					numberSold,</span>
					companyName,
					errMsg ));
<span class="nc" id="L1238">			return false;</span>
		}

		// All seems OK, now do the selling.

		// Selling price
<span class="fc" id="L1244">		int price = getCurrentSellPrice (company);</span>
<span class="fc" id="L1245">		int cashAmount = numberSold * price * shareUnits;</span>

		// Save original price as it may be reused in subsequent sale actions in the same turn
<span class="fc" id="L1248">		boolean soldBefore = sellPrices.containsKey(company);</span>
<span class="fc bfc" id="L1249" title="All 2 branches covered.">		if (!soldBefore) {</span>
<span class="fc" id="L1250">			sellPrices.put(company, company.getCurrentSpace());</span>
		}



<span class="fc" id="L1255">		String cashText = Currency.fromBank(cashAmount, currentPlayer);</span>
<span class="fc bfc" id="L1256" title="All 2 branches covered.">		if (numberSold == 1) {</span>
<span class="fc" id="L1257">			ReportBuffer.add(this, LocalText.getText(&quot;SELL_SHARE_LOG&quot;,</span>
					playerName,
<span class="fc" id="L1259">					company.getShareUnit() * shareUnits,</span>
					companyName,
					cashText));
		} else {
<span class="fc" id="L1263">			ReportBuffer.add(this, LocalText.getText(&quot;SELL_SHARES_LOG&quot;,</span>
					playerName,
<span class="fc" id="L1265">					numberSold,</span>
<span class="fc" id="L1266">					company.getShareUnit() * shareUnits,</span>
<span class="fc" id="L1267">					numberSold * company.getShareUnit() * shareUnits,</span>
					companyName,
					cashText ));
		}

<span class="fc" id="L1272">		adjustSharePrice (company, numberSold, soldBefore);</span>

<span class="pc bpc" id="L1274" title="1 of 2 branches missed.">		if (!company.isClosed()) {</span>

<span class="fc" id="L1276">			executeShareTransfer (company, certsToSell,</span>
					dumpedPlayer, presidentShareNumbersToSell);
		}

		// Remember that the player has sold this company this round.
<span class="fc" id="L1281">		currentPlayer.setSoldThisRound(company);</span>

<span class="fc bfc" id="L1283" title="All 2 branches covered.">		if (companyBoughtThisTurnWrapper.value() == null)</span>
<span class="fc" id="L1284">			hasSoldThisTurnBeforeBuying.set(true);</span>
<span class="fc" id="L1285">		hasActed.set(true);</span>
<span class="fc" id="L1286">		setPriority(&quot;SellCert&quot;);</span>

<span class="fc" id="L1288">		return true;</span>
	}

	// FIXME: Rails 2.x This has to be rewritten to give the new presidency a choice which shares to swap (if he has multiple share certificates)
	// called by:
	// StockRound: executeShareTransfer
	// StockRound 1880: executeShareTransfer
	// ShareSellingRound 1880: executeShareTransfer

	// not overriden
	protected final void executeShareTransferTo( PublicCompany company,
			List&lt;PublicCertificate&gt; certsToSell, Player dumpedPlayer, int presSharesToSell,
			BankPortfolio bankTo) {

		// Check if the presidency has changed
<span class="fc bfc" id="L1303" title="All 4 branches covered.">		if (dumpedPlayer != null &amp;&amp; presSharesToSell &gt; 0) {</span>

<span class="fc" id="L1305">			PlayerShareUtils.executePresidentTransferAfterDump(company, dumpedPlayer, bankTo, presSharesToSell);</span>

<span class="fc" id="L1307">			ReportBuffer.add(this, LocalText.getText(&quot;IS_NOW_PRES_OF&quot;,</span>
<span class="fc" id="L1308">					dumpedPlayer.getId(),</span>
<span class="fc" id="L1309">					company.getId() ));</span>

		}

		// Transfer the sold certificates
<span class="fc" id="L1314">		Portfolio.moveAll(certsToSell, bankTo);</span>

<span class="fc" id="L1316">	}</span>

	// called by:
	// StockRound: sellShares
	// ShareSellingRound. sellShares

	// overridden by
	// StockRound 1880
	// ShareSellingRound 1880
	protected void executeShareTransfer( PublicCompany company,
			List&lt;PublicCertificate&gt; certsToSell,
			Player dumpedPlayer, int presSharesToSell) {

<span class="fc" id="L1329">		executeShareTransferTo(company, certsToSell, dumpedPlayer, presSharesToSell, (BankPortfolio)pool.getParent() );</span>
<span class="fc" id="L1330">	}</span>

	// called by:
	// StockRound: sellShares, setSellableShares

	// overridden by:
	// StockRound 1835

	protected int getCurrentSellPrice (PublicCompany company) {

		int price;

<span class="fc bfc" id="L1342" title="All 2 branches covered.">		if (sellPrices.containsKey(company)</span>
<span class="fc bfc" id="L1343" title="All 2 branches covered.">				&amp;&amp; GameOption.getAsBoolean(this, &quot;SeparateSalesAtSamePrice&quot;)) {</span>
<span class="fc" id="L1344">			price = (sellPrices.get(company)).getPrice();</span>
		} else {
<span class="fc" id="L1346">			price = company.getCurrentSpace().getPrice();</span>
		}
		// stored price is the previous unadjusted price
<span class="fc" id="L1349">		price = price / company.getShareUnitsForSharePrice();</span>
<span class="fc" id="L1350">		return price;</span>
	}

	// called by:
	// StockRound: sellShares
	// StockRound 1835, 1856, 1880: (adjustSharePrice)
	// ShareSellingRound 1856: (adjustSharePrice)
	// ShareSellingRound: sellShares
	// ShareSellingRound 1880: sellShares

	// overriden by:
	// StockRound 1825, 1835, 1856, 1880
	// ShareSellingRound 1856
	protected void adjustSharePrice (PublicCompany company, int numberSold, boolean soldBefore) {

<span class="pc bpc" id="L1365" title="1 of 2 branches missed.">		if (!company.canSharePriceVary()) return;</span>

<span class="fc" id="L1367">		stockMarket.sell(company, numberSold);</span>

<span class="fc" id="L1369">		StockSpace newSpace = company.getCurrentSpace();</span>

<span class="pc bpc" id="L1371" title="3 of 4 branches missed.">		if (newSpace.closesCompany() &amp;&amp; company.canClose()) {</span>
<span class="nc" id="L1372">			company.setClosed();</span>
<span class="nc" id="L1373">			ReportBuffer.add(this, LocalText.getText(&quot;CompanyClosesAt&quot;,</span>
<span class="nc" id="L1374">					company.getId(),</span>
<span class="nc" id="L1375">					newSpace.getId()));</span>
<span class="nc" id="L1376">			return;</span>
		}

		// Company is still open

<span class="fc" id="L1381">	}</span>

	// called by:
	// StockRound: process

	// not overridden
	public boolean useSpecialProperty(UseSpecialProperty action) {

<span class="fc" id="L1389">		SpecialProperty sp = action.getSpecialProperty();</span>

		// TODO This should work for all subclasses, but not all have execute()
		// yet.
<span class="pc bpc" id="L1393" title="1 of 2 branches missed.">		if (sp instanceof ExchangeForShare) {</span>

<span class="fc" id="L1395">			boolean result = executeExchangeForShare(action, (ExchangeForShare) sp);</span>
<span class="pc bpc" id="L1396" title="1 of 2 branches missed.">			if (result) hasActed.set(true);</span>
<span class="fc" id="L1397">			return result;</span>

		} else {
<span class="nc" id="L1400">			return false;</span>
		}
	}

	// TODO: Check if this still does work, there is a cast involved now

	// called by:
	// StockRound: useSpecialProperty

	// not overridden
	public boolean executeExchangeForShare (UseSpecialProperty action, ExchangeForShare sp) {

<span class="fc" id="L1412">		PublicCompany publicCompany =</span>
<span class="fc" id="L1413">				companyManager.getPublicCompany(sp.getPublicCompanyName());</span>
<span class="fc" id="L1414">		PrivateCompany privateCompany = (PrivateCompany)sp.getOriginalCompany();</span>
<span class="fc" id="L1415">		Owner owner= privateCompany.getOwner();</span>
<span class="fc" id="L1416">		Player player = null;</span>
<span class="fc" id="L1417">		String errMsg = null;</span>
<span class="fc bfc" id="L1418" title="All 2 branches covered.">		boolean ipoHasShare = ipo.getShare(publicCompany) &gt;= sp.getShare();</span>
<span class="fc bfc" id="L1419" title="All 2 branches covered.">		boolean poolHasShare = pool.getShare(publicCompany) &gt;= sp.getShare();</span>

		while (true) {

			/* Check if the private is owned by a player */
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">			if (!(owner instanceof Player)) {</span>
<span class="nc" id="L1425">				errMsg =</span>
<span class="nc" id="L1426">						LocalText.getText(&quot;PrivateIsNotOwnedByAPlayer&quot;,</span>
<span class="nc" id="L1427">								privateCompany.getId());</span>
<span class="nc" id="L1428">				break;</span>
			}

<span class="fc" id="L1431">			player = (Player) owner;</span>

			/* Check if a share is available */
<span class="pc bpc" id="L1434" title="1 of 4 branches missed.">			if (!ipoHasShare &amp;&amp; !poolHasShare) {</span>
<span class="nc" id="L1435">				errMsg =</span>
<span class="nc" id="L1436">						LocalText.getText(&quot;NoSharesAvailable&quot;,</span>
<span class="nc" id="L1437">								publicCompany.getId());</span>
<span class="nc" id="L1438">				break;</span>
			}
			/* Check if the player has room for a share of this company */
<span class="pc bpc" id="L1441" title="1 of 2 branches missed.">			if (!checkAgainstHoldLimit(player, publicCompany, 1)) {</span>
				// TODO: Not nice to use '1' here, should be percentage.
<span class="nc" id="L1443">				errMsg =</span>
<span class="nc" id="L1444">						LocalText.getText(&quot;WouldExceedHoldLimit&quot;,</span>
<span class="nc" id="L1445">								String.valueOf(GameDef.getGameParameterAsInt(this, GameDef.Parm.PLAYER_SHARE_LIMIT)));</span>
				break;
			}
			break;
		}
<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">		if (errMsg != null) {</span>
<span class="nc" id="L1451">			DisplayBuffer.add(this, LocalText.getText(</span>
					&quot;CannotSwapPrivateForCertificate&quot;,
<span class="nc" id="L1453">					player.getId(),</span>
<span class="nc" id="L1454">					privateCompany.getId(),</span>
<span class="nc" id="L1455">					sp.getShare(),</span>
<span class="nc" id="L1456">					publicCompany.getId(),</span>
					errMsg ));
<span class="nc" id="L1458">			return false;</span>
		}



		Certificate cert =
<span class="fc bfc" id="L1464" title="All 2 branches covered.">				ipoHasShare ? ipo.findCertificate(publicCompany,</span>
<span class="fc" id="L1465">						false) : pool.findCertificate(publicCompany,</span>
								false);
<span class="fc" id="L1467">				cert.moveTo(player);</span>
<span class="fc" id="L1468">				ReportBuffer.add(this, LocalText.getText(&quot;SwapsPrivateForCertificate&quot;,</span>
<span class="fc" id="L1469">						player.getId(),</span>
<span class="fc" id="L1470">						privateCompany.getId(),</span>
<span class="fc" id="L1471">						sp.getShare(),</span>
<span class="fc" id="L1472">						publicCompany.getId()));</span>
<span class="fc" id="L1473">				sp.setExercised();</span>
<span class="fc" id="L1474">				privateCompany.setClosed();</span>

				// Check if the company has floated
<span class="fc bfc" id="L1477" title="All 2 branches covered.">				if (!publicCompany.hasFloated()) checkFlotation(publicCompany);</span>

<span class="fc" id="L1479">				return true;</span>
	}

	/**
	 * The current Player passes or is done.
	 * @param action TODO
	 * @param player Name of the passing player.
	 *
	 * @return False if an error is found.
	 */
	// called by
	// StockRound: finishTurn, process

	// overridden by
	// StockRound 1837, 18EU
	// TreasuryShareRound
	public boolean done(NullAction action, String playerName, boolean hasAutopassed) {

		//currentPlayer = getCurrentPlayer();

<span class="pc bpc" id="L1499" title="1 of 2 branches missed.">		if (!playerName.equals(currentPlayer.getId())) {</span>
<span class="nc" id="L1500">			DisplayBuffer.add(this, LocalText.getText(&quot;WrongPlayer&quot;, playerName, currentPlayer.getId()));</span>
<span class="nc" id="L1501">			return false;</span>
		}



<span class="fc bfc" id="L1506" title="All 2 branches covered.">		if (hasActed.value()) {</span>
<span class="fc" id="L1507">			numPasses.set(0);</span>
		} else {
<span class="fc" id="L1509">			numPasses.add(1);</span>
<span class="fc bfc" id="L1510" title="All 2 branches covered.">			if (hasAutopassed) {</span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">				if (!hasAutopassed(currentPlayer)) {</span>
<span class="fc" id="L1512">					setAutopass (currentPlayer, true);</span>
<span class="fc" id="L1513">					setCanRequestTurn (currentPlayer, true);</span>
				}
<span class="fc" id="L1515">				ReportBuffer.add(this, LocalText.getText(&quot;Autopasses&quot;,</span>
<span class="fc" id="L1516">						currentPlayer.getId()));</span>
			} else {
<span class="fc" id="L1518">				ReportBuffer.add(this, LocalText.getText(&quot;PASSES&quot;,</span>
<span class="fc" id="L1519">						currentPlayer.getId()));</span>
			}
		}

<span class="fc bfc" id="L1523" title="All 2 branches covered.">		if (numPasses.value() &gt;= PlayerManager.getNumberOfActivePlayers(this)) {</span>

<span class="fc" id="L1525">			finishRound();</span>

		} else {

<span class="fc" id="L1529">			finishTurn();</span>

		}
<span class="fc" id="L1532">		return true;</span>
	}

	// called by:
	// StockRound: done
	// StockRound 18367, 18EU: (finishRound)

	// overridden by:
	// StockRound 1837, 1880, 18EU
	// NationalFormationRound, PrussianFormationRound

	@Override
	protected void finishRound () {

<span class="fc" id="L1546">		ReportBuffer.add(this, &quot; &quot;);</span>
<span class="fc" id="L1547">		ReportBuffer.add(this, LocalText.getText(&quot;END_SR&quot;,</span>
<span class="fc" id="L1548">				String.valueOf(getStockRoundNumber())));</span>

<span class="fc bfc" id="L1550" title="All 2 branches covered.">		if (raiseIfSoldOut) {</span>
			/* Check if any companies are sold out. */
<span class="fc bfc" id="L1552" title="All 2 branches covered.">			for (PublicCompany company : gameManager.getCompaniesInRunningOrder()) {</span>
<span class="fc bfc" id="L1553" title="All 4 branches covered.">				if (company.hasStockPrice() &amp;&amp; company.isSoldOut()) {</span>
<span class="fc" id="L1554">					StockSpace oldSpace = company.getCurrentSpace();</span>
<span class="fc" id="L1555">					stockMarket.soldOut(company);</span>
<span class="fc" id="L1556">					StockSpace newSpace = company.getCurrentSpace();</span>
<span class="fc bfc" id="L1557" title="All 2 branches covered.">					if (newSpace != oldSpace) {</span>
<span class="fc" id="L1558">						ReportBuffer.add(this, LocalText.getText(&quot;SoldOut&quot;,</span>
<span class="fc" id="L1559">								company.getId(),</span>
<span class="fc" id="L1560">								Bank.format(this, oldSpace.getPrice()),</span>
<span class="fc" id="L1561">								oldSpace.getId(),</span>
<span class="fc" id="L1562">								Bank.format(this, newSpace.getPrice()),</span>
<span class="fc" id="L1563">								newSpace.getId()));</span>
					} else {
<span class="fc" id="L1565">						ReportBuffer.add(this, LocalText.getText(&quot;SoldOutNoRaise&quot;,</span>
<span class="fc" id="L1566">								company.getId(),</span>
<span class="fc" id="L1567">								Bank.format(this, newSpace.getPrice()),</span>
<span class="fc" id="L1568">								newSpace.getId()));</span>
					}
				}
<span class="fc" id="L1571">			}</span>
		}

		// reset soldThisRound
<span class="fc bfc" id="L1575" title="All 2 branches covered.">		for (Player player:playerManager.getPlayers()) {</span>
<span class="fc" id="L1576">			player.resetSoldThisRound();</span>
<span class="fc" id="L1577">		}</span>


<span class="fc" id="L1580">		super.finishRound();</span>
<span class="fc" id="L1581">	}</span>

	// called by:
	// StockRound: process

	// not overridden
	protected boolean requestTurn (RequestTurn action) {

<span class="fc" id="L1589">		Player requestingPlayer = playerManager.getPlayerByName(action.getRequestingPlayerName());</span>

<span class="fc" id="L1591">		boolean result = canRequestTurn(requestingPlayer);</span>

<span class="pc bpc" id="L1593" title="1 of 2 branches missed.">		if (!result) {</span>
<span class="nc" id="L1594">			DisplayBuffer.add(this, LocalText.getText(&quot;CannotRequestTurn&quot;,</span>
<span class="nc" id="L1595">					requestingPlayer.getId()));</span>
<span class="nc" id="L1596">			return false;</span>
		}


<span class="pc bpc" id="L1600" title="1 of 2 branches missed.">		if (hasAutopassed(requestingPlayer)) {</span>
<span class="fc" id="L1601">			setAutopass(requestingPlayer, false);</span>
		} else {
<span class="nc" id="L1603">			requestTurn(requestingPlayer); // TODO: Check if this still works, replaces requestTurn.add(..)</span>
		}

<span class="fc" id="L1606">		return true;</span>
	}


	// called by:
	// StockRound: done
	// StockRound 1837, 18EU: (finishTurn)

	// overridden by:
	// StockRound 1837, 18EU

	protected void finishTurn() {

<span class="fc" id="L1619">		setNextPlayer();</span>
<span class="fc" id="L1620">		sellPrices.clear();</span>
<span class="fc bfc" id="L1621" title="All 2 branches covered.">		if (hasAutopassed(currentPlayer)) {</span>
<span class="pc bpc" id="L1622" title="1 of 2 branches missed.">			if (isPlayerOverLimits(currentPlayer)) {</span>
				// Being over a share/certificate limit undoes an Autopass setting
<span class="nc" id="L1624">				setAutopass (currentPlayer, false);</span>
			} else {
				// Process a pass for a player that has set Autopass
<span class="fc" id="L1627">				done (null, currentPlayer.getId(), true);</span>
			}
		}
<span class="fc" id="L1630">	}</span>

	/**
	 * Internal method: pass the turn to the next player.
	 */

	// called by
	// StockRound: finishTurn
	// NationalFormationRound, 1835 PrussianFormationRound: findNextMergingPlayer
	// 1837FinalCoalExchangeRound: setMinorMergeActions
	// 18EUFinalMInorExchangeRound: setMinorMergeActions

	// not overridden
	protected void setNextPlayer() {

<span class="fc" id="L1645">		getRoot().getPlayerManager().setCurrentToNextPlayer();</span>
<span class="fc" id="L1646">		initPlayer();</span>
<span class="fc" id="L1647">	}</span>

	// called by
	// StockRound: setNextPlayer, start
	// StockRound 1856: (initPlayer)

	// overridden by:
	// StockRound 1837, 1856, 18EU
	// FinalCoalExchangeRound
	// FinalMinorExchangeRound
	protected void initPlayer() {

<span class="fc" id="L1659">		currentPlayer = playerManager.getCurrentPlayer();</span>
<span class="fc" id="L1660">		companyBoughtThisTurnWrapper.set(null);</span>
<span class="fc" id="L1661">		hasSoldThisTurnBeforeBuying.set(false);</span>
<span class="fc" id="L1662">		hasActed.set(false);</span>
<span class="fc bfc" id="L1663" title="All 2 branches covered.">		if (currentPlayer == startingPlayer) ReportBuffer.add(this, &quot;&quot;);</span>
<span class="fc" id="L1664">	}</span>

	/**
	 * Remember the player that has the Priority Deal. &lt;b&gt;Must be called BEFORE
	 * setNextPlayer()!&lt;/b&gt;
	 * @param string
	 */
	// called by
	// StockRound: buyShares, sellShares, startCompany
	// StockRound 18EU: mergeCompanies, startCompany
	// StockRound 1837: mergeCompanies

	// To be overridden in 1825, 1829,1835 (done), 1847, 1881, 18Africa
	protected void setPriority(String string) {
		//Standard: All actions change Priority but not in
		//1825, 1829, 1835, 1847, 1881, 18Africa Each player
		//consecutively not making a purchase. The priority then
		//goes to the player after the one who last made a purchase.
<span class="fc" id="L1682">		getRoot().getPlayerManager().setPriorityPlayerToNext();</span>
<span class="fc" id="L1683">	}</span>

	// called by
	// Stockround 1837, 18EU: finishRound, finishTurn
	// NationalFormationRound, 1835PrussianFormationRound: setPossibleActions, start

	// not overridden
	@Deprecated
	public void setCurrentPlayer(Player player) {
<span class="fc" id="L1692">		getRoot().getPlayerManager().setCurrentPlayer(player);</span>
<span class="fc" id="L1693">		currentPlayer = player;</span>
<span class="fc" id="L1694">	}</span>

	/*----- METHODS TO BE CALLED TO SET UP THE NEXT TURN -----*/

	/**
	 * @return The index of the player that has the turn.
	 */
	// called by
	// ShareSellingRound 1880: sellShares

	// not overridden
	public int getCurrentPlayerIndex() {
<span class="nc" id="L1706">		return currentPlayer.getIndex();</span>
	}

	/**
	 * @return true if first round sell restriction is active
	 */
	// called by
	// StockRound: mayCurrentPlayerSellAnything, sellShares

	// not overridden
	private boolean checkFirstRoundSellRestriction() {
<span class="fc bfc" id="L1717" title="All 4 branches covered.">		if (noSaleInFirstSR() &amp;&amp; getStockRoundNumber() == 1) {</span>
			// depending on GameOption restriction is either valid during the first (true) Stock Round or the first Round
<span class="fc bfc" id="L1719" title="All 2 branches covered.">			if (GameOption.getValue(this, &quot;FirstRoundSellRestriction&quot;).equals(&quot;First Stock Round&quot;)) {</span>
<span class="fc" id="L1720">				return true;</span>
<span class="pc bpc" id="L1721" title="1 of 2 branches missed.">			} else if (GameOption.getValue(this, &quot;FirstRoundSellRestriction&quot;).equals(&quot;First Round&quot;)) {</span>
				// if all players have passed it is not the first round
<span class="fc bfc" id="L1723" title="All 2 branches covered.">				return !gameManager.getFirstAllPlayersPassed();</span>
			}
		}
<span class="fc" id="L1726">		return false;</span>
	}

	/**
	 * Can the current player do any selling?
	 *
	 * @return True if any selling is allowed.
	 */
	// called by
	// StockRound: sellShares, sellSellableShares

	// overridden by
	// ShareSellingRound
	// TreasuryShareRound
	public boolean mayCurrentPlayerSellAnything() {

<span class="fc bfc" id="L1742" title="All 2 branches covered.">		if (checkFirstRoundSellRestriction()) {</span>
<span class="fc" id="L1743">			return false;</span>
		}

<span class="fc bfc" id="L1746" title="All 4 branches covered.">		if (companyBoughtThisTurnWrapper.value() != null</span>
				&amp;&amp; (sequenceRule == SELL_BUY_OR_BUY_SELL
<span class="fc bfc" id="L1748" title="All 4 branches covered.">				&amp;&amp; hasSoldThisTurnBeforeBuying.value() || sequenceRule == SELL_BUY)) {</span>
<span class="fc" id="L1749">			return false;</span>
		}
<span class="fc" id="L1751">		return true;</span>
	}


	// called by
	// StockRound: sellShares, setSellableShares
	// StockRound 1880: (mayPlayerSellShareOfCompany), sellShares
	// ShareSellingRound: getSellableShares

	// overridden by
	// StockRound 1880
	public boolean mayPlayerSellShareOfCompany(PublicCompany company) {

		// Can't sell shares that have no price
<span class="fc bfc" id="L1765" title="All 4 branches covered.">		if (!company.hasStarted() || !company.hasStockPrice()) return false;</span>

		// In some games, can't sell shares if not operated
<span class="fc bfc" id="L1768" title="All 2 branches covered.">		if (noSaleIfNotOperated()</span>
<span class="fc bfc" id="L1769" title="All 2 branches covered.">				&amp;&amp; !company.hasOperated()) return false;</span>

<span class="fc" id="L1771">		return true;</span>
	}


	/**
	 * Can the current player do any buying?
	 * &lt;p&gt;Note: requires sellable shares to be checked BEFORE buyable shares
	 *
	 * @return True if any buying is allowed.
	 */
	// called by
	// StockRound: setBuyableCerts
	// StockRound 1880, 18EU: setBuyableCerts
	// StockRound 1837, 18EU: setGameSpecificActions

	// overridden by
	// ShareSellingRound
	// TreasuryShareRound
	public boolean mayCurrentPlayerBuyAnything() {
<span class="pc bpc" id="L1790" title="1 of 4 branches missed.">		return !isOverLimits &amp;&amp; companyBoughtThisTurnWrapper.value() == null;</span>
	}

	// Only used now to check if Autopass must be reset.
	// called by
	// StockRound: finishTurn

	// not overridden
	protected boolean isPlayerOverLimits(Player player) {

		// Over the total certificate hold Limit?
<span class="pc bpc" id="L1801" title="1 of 2 branches missed.">		if (player.getPortfolioModel().getCertificateCount() &gt; gameManager.getPlayerCertificateLimit(player)) {</span>
<span class="nc" id="L1802">			return true;</span>
		}

		// Over the hold limit of any company?
<span class="fc bfc" id="L1806" title="All 2 branches covered.">		for (PublicCompany company : companyManager.getAllPublicCompanies()) {</span>
<span class="fc bfc" id="L1807" title="All 4 branches covered.">			if (company.hasStarted() &amp;&amp; company.hasStockPrice()</span>
<span class="pc bpc" id="L1808" title="1 of 2 branches missed.">					&amp;&amp; !checkAgainstHoldLimit(player, company, 0)) {</span>
<span class="nc" id="L1809">				return true;</span>
			}
<span class="fc" id="L1811">		}</span>

<span class="fc" id="L1813">		return false;</span>
	}

	/**
	 * Check if a player may buy the given number of certificates.
	 *
	 * @param number Number of certificates to buy (usually 1 but not always
	 * so).
	 * @return True if it is allowed.
	 */
	// called by
	// StockRound: buyShares, setBuyableCerts, startCompany
	// StockRound 1835, 1880, 18EU: setBuyableCerts
	// StockRound 18EU: startCompany

	// not overridden
	public boolean mayPlayerBuyCertificate(Player player, PublicCompany comp, float number) {
<span class="fc bfc" id="L1830" title="All 4 branches covered.">		if (comp.hasFloated() &amp;&amp; comp.getCurrentSpace().isNoCertLimit())</span>
<span class="fc" id="L1831">			return true;</span>
<span class="fc bfc" id="L1832" title="All 2 branches covered.">		if (player.getPortfolioModel().getCertificateCount() + number &gt; gameManager.getPlayerCertificateLimit(player))</span>
<span class="fc" id="L1833">			return false;</span>
<span class="fc" id="L1834">		return true;</span>
	}

	/**
	 * Check if a player may buy the given number of shares from a given
	 * company, given the &quot;hold limit&quot; per company, that is the percentage of
	 * shares of one company that a player may hold (typically 60%).
	 *
	 * @param player the buying player
	 * @param company The company from which to buy
	 * @param number The number of shares (usually 1 but not always so)
	 * @return True if it is allowed.
	 */
	// called by
	// StockRound: buyShares, executeExchangeForShare, isPlayerOverLimits, setBuyableCerts, setSellableShares
	// StockRound 18EU, 1880: setBuyableCerts

	// overriden by:
	// StockRound 1835
	public boolean checkAgainstHoldLimit(Player player, PublicCompany company,
			int number) {
		// Check for per-company share limit
<span class="fc" id="L1856">		if (player.getPortfolioModel().getShare(company)</span>
<span class="fc" id="L1857">				+ number * company.getShareUnit()</span>
<span class="fc bfc" id="L1858" title="All 2 branches covered.">				&gt; GameDef.getGameParameterAsInt(this, GameDef.Parm.PLAYER_SHARE_LIMIT)</span>
<span class="pc bpc" id="L1859" title="1 of 2 branches missed.">				&amp;&amp; !company.getCurrentSpace().isNoHoldLimit()</span>
<span class="pc bpc" id="L1860" title="1 of 2 branches missed.">				&amp;&amp; !isSellObligationLifted(company)) return false;</span>
<span class="fc" id="L1861">		return true;</span>
	}

	/**
	 * Return the number of &lt;i&gt;additional&lt;/i&gt; shares of a certain company and
	 * of a certain size that a player may buy, given the share &quot;hold limit&quot; per
	 * company, that is the percentage of shares of one company that a player
	 * may hold (typically 60%). &lt;p&gt;If no hold limit applies, it is taken to be
	 * 100%.
	 *
	 * @param company The company from which to buy
	 * @param number The share unit (typically 10%).
	 * @return The maximum number of such shares that would not let the player
	 * overrun the per-company share hold limit.
	 */
	// called by
	// StockRound setBuyableCerts
	// StockRound 1880, 18EU: setBuyableCerts

	// not overridden
	public int maxAllowedNumberOfSharesToBuy(Player player,
			PublicCompany company,
			int shareSize) {

		int limit;
<span class="fc" id="L1886">		int playerShareLimit = GameDef.getGameParameterAsInt(this, GameDef.Parm.PLAYER_SHARE_LIMIT);</span>
<span class="fc bfc" id="L1887" title="All 2 branches covered.">		if (!company.hasStarted()) {</span>
<span class="fc" id="L1888">			limit = playerShareLimit;</span>
		} else {
			limit =
<span class="fc bfc" id="L1891" title="All 2 branches covered.">					company.getCurrentSpace().isNoHoldLimit() ? 100</span>
<span class="fc" id="L1892">							: playerShareLimit;</span>
		}
<span class="fc" id="L1894">		int maxAllowed = (limit - player.getPortfolioModel().getShare(company)) / shareSize;</span>
		//        log.debug(&quot;MaxAllowedNumberOfSharesToBuy = &quot; + maxAllowed + &quot; for company =  &quot; + company + &quot; shareSize &quot; + shareSize);
<span class="fc" id="L1896">		return maxAllowed;</span>
	}


	// called by
	// StockRound: checkFirstRoundSellRestriction

	// not overridden
	protected boolean noSaleInFirstSR() {
<span class="fc" id="L1905">		return (Boolean) gameManager.getGameParameter(GameDef.Parm.NO_SALE_IN_FIRST_SR);</span>
	}


	// called by
	// StockRound: mayPlayerSellShareOfCompany

	// not overridden
	protected boolean noSaleIfNotOperated() {
<span class="fc" id="L1914">		return (Boolean) gameManager.getGameParameter(GameDef.Parm.NO_SALE_IF_NOT_OPERATED);</span>
	}

	// called by
	// 1835PrussianFormationRound: finishRound
	// GameManager: processOnReload
	// GameUIManager: initSaveSettings, saveGame

	// not overridden
	@Override
	public String getRoundName() {
<span class="nc" id="L1925">		return &quot;StockRound &quot; + getStockRoundNumber();</span>
	}

	// Called by
	// StockRound: checkAgainstHoldLimit

	// not overridden
	public boolean isSellObligationLifted(PublicCompany company) {
<span class="pc bpc" id="L1933" title="1 of 2 branches missed.">		return sellObligationLifted != null</span>
<span class="pc bnc" id="L1934" title="All 2 branches missed.">				&amp;&amp; sellObligationLifted.contains(company);</span>
	}

	// Called by
	// 18EU, 1837 StockRound: mergeCompanies

	// not overridden
	public void setSellObligationLifted (PublicCompany company) {
<span class="nc bnc" id="L1942" title="All 2 branches missed.">		if (sellObligationLifted == null) {</span>
<span class="nc" id="L1943">			sellObligationLifted = HashSetState.create(this, &quot;sellObligationLifted&quot;);</span>
		}
<span class="nc" id="L1945">		sellObligationLifted.add(company);</span>
<span class="nc" id="L1946">	}</span>

	public boolean requestTurn (Player player) {
<span class="nc bnc" id="L1949" title="All 2 branches missed.">		if (canRequestTurn(player)) {</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">			if (!hasRequestedTurn.contains(player)) hasRequestedTurn.add(player);</span>
<span class="nc" id="L1951">			return true;</span>
		}
<span class="nc" id="L1953">		return false;</span>
	}

	public boolean canRequestTurn (Player player) {
<span class="fc" id="L1957">		return canRequestTurn.contains(player);</span>
	}

	public void setCanRequestTurn (Player player, boolean value) {
<span class="pc bpc" id="L1961" title="1 of 4 branches missed.">		if (value &amp;&amp; !canRequestTurn.contains(player)) {</span>
<span class="fc" id="L1962">			canRequestTurn.add(player);</span>
<span class="pc bpc" id="L1963" title="3 of 4 branches missed.">		} else if (!value &amp;&amp; canRequestTurn.contains(player)) {</span>
<span class="nc" id="L1964">			canRequestTurn.remove(player);</span>
		}
<span class="fc" id="L1966">	}</span>

	public void setAutopass (Player player, boolean value) {
<span class="pc bpc" id="L1969" title="1 of 4 branches missed.">		if (value &amp;&amp; !autopasses.contains(player)) {</span>
<span class="fc" id="L1970">			autopasses.add(player);</span>
<span class="pc bpc" id="L1971" title="2 of 4 branches missed.">		} else if (!value &amp;&amp; autopasses.contains(player)) {</span>
<span class="fc" id="L1972">			autopasses.remove(player);</span>
		}
<span class="fc" id="L1974">	}</span>

	public boolean hasAutopassed (Player player) {
<span class="fc" id="L1977">		return autopasses.contains(player);</span>
	}

	public List&lt;Player&gt; getAutopasses() {
<span class="fc" id="L1981">		return autopasses.view();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>